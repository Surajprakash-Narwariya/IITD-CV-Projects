./file.c:33:    if(f->ref == 0){
./file.c:34:      f->ref = 1;
./file.c:48:  if(f->ref < 1)
./file.c:50:  f->ref++;
./file.c:62:  if(f->ref < 1)
./file.c:64:  if(--f->ref > 0){
./file.c:69:  f->ref = 0;
./file.c:70:  f->type = FD_NONE;
./file.c:86:  if(f->type == FD_INODE){
./file.c:87:    ilock(f->ip);
./file.c:88:    stati(f->ip, st);
./file.c:89:    iunlock(f->ip);
./file.c:92:  return -1;
./file.c:101:  if(f->readable == 0)
./file.c:102:    return -1;
./file.c:103:  if(f->type == FD_PIPE)
./file.c:104:    return piperead(f->pipe, addr, n);
./file.c:105:  if(f->type == FD_INODE){
./file.c:106:    ilock(f->ip);
./file.c:107:    if((r = readi(f->ip, addr, f->off, n)) > 0)
./file.c:108:      f->off += r;
./file.c:109:    iunlock(f->ip);
./file.c:122:  if(f->writable == 0)
./file.c:123:    return -1;
./file.c:124:  if(f->type == FD_PIPE)
./file.c:125:    return pipewrite(f->pipe, addr, n);
./file.c:126:  if(f->type == FD_INODE){
./file.c:129:    // i-node, indirect block, allocation blocks,
./file.c:130:    // and 2 blocks of slop for non-aligned writes.
./file.c:133:    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
./file.c:136:      int n1 = n - i;
./file.c:141:      ilock(f->ip);
./file.c:142:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
./file.c:143:        f->off += r;
./file.c:144:      iunlock(f->ip);
./file.c:153:    return i == n ? n : -1;
./test2.asm:2:_test2:     file format elf32-i386
./test2.asm:10:  return fib(n - 1) + fib(n - 2);
./test2.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./test2.asm:36:  return fib(n - 1) + fib(n - 2);
./test2.asm:57:  return fib(n - 1) + fib(n - 2);
./test2.asm:83:  94:	8d 78 ff             	lea    -0x1(%eax),%edi
./test2.asm:91:  ac:	89 5d b0             	mov    %ebx,-0x50(%ebp)
./test2.asm:92:  af:	39 7d b0             	cmp    %edi,-0x50(%ebp)
./test2.asm:99:  c8:	8d 4e ff             	lea    -0x1(%esi),%ecx
./test2.asm:100:  cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./test2.asm:102:  d0:	89 4d a8             	mov    %ecx,-0x58(%ebp)
./test2.asm:105:  d8:	89 5d e0             	mov    %ebx,-0x20(%ebp)
./test2.asm:107:  dd:	89 7d dc             	mov    %edi,-0x24(%ebp)
./test2.asm:109:  e2:	89 4d ac             	mov    %ecx,-0x54(%ebp)
./test2.asm:110:  e5:	89 75 d8             	mov    %esi,-0x28(%ebp)
./test2.asm:111:  e8:	39 75 ac             	cmp    %esi,-0x54(%ebp)
./test2.asm:114:  f4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test2.asm:116:  f9:	89 75 d0             	mov    %esi,-0x30(%ebp)
./test2.asm:121: 109:	8d 47 ff             	lea    -0x1(%edi),%eax
./test2.asm:123: 10e:	89 5d cc             	mov    %ebx,-0x34(%ebp)
./test2.asm:125: 113:	89 45 a0             	mov    %eax,-0x60(%ebp)
./test2.asm:128: 11b:	89 7d c8             	mov    %edi,-0x38(%ebp)
./test2.asm:129: 11e:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
./test2.asm:133: 127:	39 75 a4             	cmp    %esi,-0x5c(%ebp)
./test2.asm:142: 144:	8d 53 ff             	lea    -0x1(%ebx),%edx
./test2.asm:144: 149:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./test2.asm:145: 14c:	89 55 98             	mov    %edx,-0x68(%ebp)
./test2.asm:147: 152:	89 5d bc             	mov    %ebx,-0x44(%ebp)
./test2.asm:150: 159:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
./test2.asm:152: 15e:	89 7d c0             	mov    %edi,-0x40(%ebp)
./test2.asm:154: 163:	39 4d 9c             	cmp    %ecx,-0x64(%ebp)
./test2.asm:158: 171:	89 55 b8             	mov    %edx,-0x48(%ebp)
./test2.asm:160: 176:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
./test2.asm:167:  return fib(n - 1) + fib(n - 2);
./test2.asm:169: 189:	89 4d 90             	mov    %ecx,-0x70(%ebp)
./test2.asm:170: 18c:	89 55 94             	mov    %edx,-0x6c(%ebp)
./test2.asm:174:  return fib(n - 1) + fib(n - 2);
./test2.asm:178: 19b:	8b 55 94             	mov    -0x6c(%ebp),%edx
./test2.asm:179: 19e:	8b 4d 90             	mov    -0x70(%ebp),%ecx
./test2.asm:184: 1ac:	8d 43 fe             	lea    -0x2(%ebx),%eax
./test2.asm:192: 1c3:	8b 55 b8             	mov    -0x48(%ebp),%edx
./test2.asm:193: 1c6:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
./test2.asm:199: 1d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test2.asm:200: 1da:	8b 7d c0             	mov    -0x40(%ebp),%edi
./test2.asm:201: 1dd:	8b 5d bc             	mov    -0x44(%ebp),%ebx
./test2.asm:203: 1e3:	83 7d 98 01          	cmpl   $0x1,-0x68(%ebp)
./test2.asm:212: 204:	8b 5d cc             	mov    -0x34(%ebp),%ebx
./test2.asm:213: 207:	8b 7d c8             	mov    -0x38(%ebp),%edi
./test2.asm:215: 20d:	83 7d a0 01          	cmpl   $0x1,-0x60(%ebp)
./test2.asm:218: 21b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test2.asm:219: 21e:	8b 75 d0             	mov    -0x30(%ebp),%esi
./test2.asm:224: 230:	8b 75 d8             	mov    -0x28(%ebp),%esi
./test2.asm:225: 233:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./test2.asm:226: 236:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./test2.asm:227: 239:	8b 7d dc             	mov    -0x24(%ebp),%edi
./test2.asm:229: 23f:	83 7d a8 01          	cmpl   $0x1,-0x58(%ebp)
./test2.asm:237: 25c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:254: 280:	39 75 a4             	cmp    %esi,-0x5c(%ebp)
./test2.asm:257: 28b:	8b 5d cc             	mov    -0x34(%ebp),%ebx
./test2.asm:258: 28e:	8b 7d c8             	mov    -0x38(%ebp),%edi
./test2.asm:264: 2a4:	8b 55 b8             	mov    -0x48(%ebp),%edx
./test2.asm:265: 2a7:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
./test2.asm:269: 2b7:	39 4d 9c             	cmp    %ecx,-0x64(%ebp)
./test2.asm:272: 2c2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test2.asm:273: 2c5:	8b 7d c0             	mov    -0x40(%ebp),%edi
./test2.asm:275: 2cb:	8b 5d bc             	mov    -0x44(%ebp),%ebx
./test2.asm:277: 2d3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test2.asm:279: 2d8:	8b 75 d0             	mov    -0x30(%ebp),%esi
./test2.asm:284: 2eb:	39 75 ac             	cmp    %esi,-0x54(%ebp)
./test2.asm:286: 2f4:	8b 75 d8             	mov    -0x28(%ebp),%esi
./test2.asm:287: 2f7:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./test2.asm:289: 2fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./test2.asm:290: 300:	8b 7d dc             	mov    -0x24(%ebp),%edi
./test2.asm:292: 306:	83 7d a8 01          	cmpl   $0x1,-0x58(%ebp)
./test2.asm:302: 32a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:312: 336:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:357: 36e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test2.asm:392:  return (uchar)*p - (uchar)*q;
./test2.asm:395: 3b1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test2.asm:401:  return (uchar)*p - (uchar)*q;
./test2.asm:406: 3c8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test2.asm:409:  return (uchar)*p - (uchar)*q;
./test2.asm:476: 422:	8b 7d fc             	mov    -0x4(%ebp),%edi
./test2.asm:533: 475:	8d 75 e7             	lea    -0x19(%ebp),%esi
./test2.asm:554: 494:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./test2.asm:556: 49b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./test2.asm:575: 4ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:606:    return -1;
./test2.asm:622: 504:	8d 65 f8             	lea    -0x8(%ebp),%esp
./test2.asm:629:    return -1;
./test2.asm:650: 52a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./test2.asm:659:    n = n*10 + *s++ - '0';
./test2.asm:662: 546:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./test2.asm:665: 54d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./test2.asm:670: 555:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test2.asm:693:  while(n-- > 0)
./test2.asm:704:  while(n-- > 0)
./test2.asm:873:    x = -xx;
./test2.asm:877: 64d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./test2.asm:883:    x = -xx;
./test2.asm:892: 665:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./test2.asm:903: 682:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./test2.asm:910: 68e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test2.asm:913:    buf[i++] = '-';
./test2.asm:914: 695:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./test2.asm:916:  while(--i >= 0)
./test2.asm:918: 69c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./test2.asm:919: 69f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./test2.asm:926: 6ae:	88 45 d7             	mov    %al,-0x29(%ebp)
./test2.asm:927: 6b1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./test2.asm:932:  while(--i >= 0)
./test2.asm:939: 6c9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:979: 6fe:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./test2.asm:982: 708:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test2.asm:993: 718:	8d 45 e7             	lea    -0x19(%ebp),%eax
./test2.asm:994: 71b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test2.asm:999: 727:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test2.asm:1031: 760:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:1041: 773:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test2.asm:1042: 776:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./test2.asm:1045: 77d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test2.asm:1049: 789:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test2.asm:1051: 78e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test2.asm:1062: 7a0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test2.asm:1073: 7b9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./test2.asm:1079: 7c6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./test2.asm:1083: 7ce:	89 45 d0             	mov    %eax,-0x30(%ebp)
./test2.asm:1094: 7e6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test2.asm:1095: 7e9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./test2.asm:1100: 7f3:	88 45 e7             	mov    %al,-0x19(%ebp)
./test2.asm:1114: 80c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./test2.asm:1118: 816:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test2.asm:1125: 827:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test2.asm:1128: 82d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test2.asm:1134: 835:	88 45 e7             	mov    %al,-0x19(%ebp)
./test2.asm:1141: 841:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./test2.asm:1149: 853:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test2.asm:1150: 856:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test2.asm:1169:  bp = (Header*)ap - 1;
./test2.asm:1170:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test2.asm:1178:  bp = (Header*)ap - 1;
./test2.asm:1179: 87e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./test2.asm:1180:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test2.asm:1182:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test2.asm:1184:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test2.asm:1189:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test2.asm:1193:  if(bp + bp->s.size == p->s.ptr){
./test2.asm:1194: 896:	8b 73 fc             	mov    -0x4(%ebx),%esi
./test2.asm:1198:    bp->s.size += p->s.ptr->s.size;
./test2.asm:1199:    bp->s.ptr = p->s.ptr->s.ptr;
./test2.asm:1200: 8a0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./test2.asm:1202:    bp->s.ptr = p->s.ptr;
./test2.asm:1203:  if(p + p->s.size == bp){
./test2.asm:1208:    p->s.size += bp->s.size;
./test2.asm:1209:    p->s.ptr = bp->s.ptr;
./test2.asm:1212:    p->s.ptr = bp;
./test2.asm:1224:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test2.asm:1233:    bp->s.size += p->s.ptr->s.size;
./test2.asm:1235: 8d3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./test2.asm:1236:    bp->s.ptr = p->s.ptr->s.ptr;
./test2.asm:1239: 8da:	89 53 f8             	mov    %edx,-0x8(%ebx)
./test2.asm:1240:  if(p + p->s.size == bp){
./test2.asm:1245:    p->s.size += bp->s.size;
./test2.asm:1246: 8e7:	03 53 fc             	add    -0x4(%ebx),%edx
./test2.asm:1249:    p->s.size += bp->s.size;
./test2.asm:1251:    p->s.ptr = bp->s.ptr;
./test2.asm:1252: 8f2:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./test2.asm:1278:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./test2.asm:1282:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./test2.asm:1292:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./test2.asm:1294:    if(p->s.size >= nunits){
./test2.asm:1306:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./test2.asm:1308:    if(p->s.size >= nunits){
./test2.asm:1312:        p->s.size = nunits;
./test2.asm:1325:  if(p == (char*)-1)
./test2.asm:1329:  hp->s.size = nu;
./test2.asm:1345: 980:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:1355:      if(p->s.size == nunits)
./test2.asm:1358:        p->s.size -= nunits;
./test2.asm:1361:        p += p->s.size;
./test2.asm:1363:        p->s.size = nunits;
./test2.asm:1368: 9a5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test2.asm:1388:    if(p->s.size >= nunits){
./test2.asm:1392:        prevp->s.ptr = p->s.ptr;
./forktest.d:1:forktest.o: forktest.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./ls.c:13:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
./ls.c:17:  // Return blank-padded name.
./ls.c:21:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
./fs.d:1:fs.o: fs.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h mmu.h \
./initcode.asm:2:initcode.o:     file format elf32-i386
./init.c:1:// init: The initial user-level program
./uart.d:1:uart.o: uart.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./test3.d:1:test3.o: test3.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./ls.asm:2:_ls:     file format elf32-i386
./ls.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./ls.asm:70:  for(p=path+strlen(path); p >= path && *p != '/'; p--)
./ls.asm:80:  80:	8d 43 ff             	lea    -0x1(%ebx),%eax
./ls.asm:104:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
./ls.asm:110:  memset(buf+strlen(p), ' ', DIRSIZ-strlen(p));
./ls.asm:124:  ec:	8d 65 f8             	lea    -0x8(%ebp),%esp
./ls.asm:152: 125:	8d b5 d4 fd ff ff    	lea    -0x22c(%ebp),%esi
./ls.asm:161: 13f:	0f b7 85 d4 fd ff ff 	movzwl -0x22c(%ebp),%eax
./ls.asm:167: 152:	8b 95 e4 fd ff ff    	mov    -0x21c(%ebp),%edx
./ls.asm:169: 15b:	8b b5 dc fd ff ff    	mov    -0x224(%ebp),%esi
./ls.asm:170: 161:	89 95 b4 fd ff ff    	mov    %edx,-0x24c(%ebp)
./ls.asm:173: 16d:	8b 95 b4 fd ff ff    	mov    -0x24c(%ebp),%edx
./ls.asm:191: 195:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:209: 1be:	8d bd e8 fd ff ff    	lea    -0x218(%ebp),%edi
./ls.asm:222: 1da:	89 85 a8 fd ff ff    	mov    %eax,-0x258(%ebp)
./ls.asm:224: 1e0:	89 8d a4 fd ff ff    	mov    %ecx,-0x25c(%ebp)
./ls.asm:229: 1f3:	8d 85 c4 fd ff ff    	lea    -0x23c(%ebp),%eax
./ls.asm:238: 20e:	66 83 bd c4 fd ff ff 	cmpw   $0x0,-0x23c(%ebp)
./ls.asm:243: 21b:	8d 85 c6 fd ff ff    	lea    -0x23a(%ebp),%eax
./ls.asm:246: 224:	ff b5 a4 fd ff ff    	push   -0x25c(%ebp)
./ls.asm:249: 22f:	8b 85 a8 fd ff ff    	mov    -0x258(%ebp),%eax
./ls.asm:261: 24d:	8b 8d e4 fd ff ff    	mov    -0x21c(%ebp),%ecx
./ls.asm:262: 253:	8b 95 dc fd ff ff    	mov    -0x224(%ebp),%edx
./ls.asm:264: 25c:	0f bf 85 d4 fd ff ff 	movswl -0x22c(%ebp),%eax
./ls.asm:265: 263:	89 8d ac fd ff ff    	mov    %ecx,-0x254(%ebp)
./ls.asm:266: 269:	89 95 b0 fd ff ff    	mov    %edx,-0x250(%ebp)
./ls.asm:267: 26f:	89 85 b4 fd ff ff    	mov    %eax,-0x24c(%ebp)
./ls.asm:272: 27d:	8b 8d ac fd ff ff    	mov    -0x254(%ebp),%ecx
./ls.asm:274: 284:	8b 95 b0 fd ff ff    	mov    -0x250(%ebp),%edx
./ls.asm:276: 28b:	ff b5 b4 fd ff ff    	push   -0x24c(%ebp)
./ls.asm:295: 2c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:325: 30b:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:370: 34e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ls.asm:405:  return (uchar)*p - (uchar)*q;
./ls.asm:408: 391:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ls.asm:414:  return (uchar)*p - (uchar)*q;
./ls.asm:419: 3a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ls.asm:422:  return (uchar)*p - (uchar)*q;
./ls.asm:489: 402:	8b 7d fc             	mov    -0x4(%ebp),%edi
./ls.asm:546: 455:	8d 75 e7             	lea    -0x19(%ebp),%esi
./ls.asm:567: 474:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./ls.asm:569: 47b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./ls.asm:588: 49a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:619:    return -1;
./ls.asm:635: 4e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
./ls.asm:642:    return -1;
./ls.asm:663: 50a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./ls.asm:672:    n = n*10 + *s++ - '0';
./ls.asm:675: 526:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./ls.asm:678: 52d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./ls.asm:683: 535:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ls.asm:706:  while(n-- > 0)
./ls.asm:717:  while(n-- > 0)
./ls.asm:886:    x = -xx;
./ls.asm:890: 62d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./ls.asm:896:    x = -xx;
./ls.asm:905: 645:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./ls.asm:916: 662:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./ls.asm:923: 66e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./ls.asm:926:    buf[i++] = '-';
./ls.asm:927: 675:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./ls.asm:929:  while(--i >= 0)
./ls.asm:931: 67c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./ls.asm:932: 67f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./ls.asm:939: 68e:	88 45 d7             	mov    %al,-0x29(%ebp)
./ls.asm:940: 691:	8d 45 d7             	lea    -0x29(%ebp),%eax
./ls.asm:945:  while(--i >= 0)
./ls.asm:952: 6a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:992: 6de:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./ls.asm:995: 6e8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./ls.asm:1006: 6f8:	8d 45 e7             	lea    -0x19(%ebp),%eax
./ls.asm:1007: 6fb:	88 5d e7             	mov    %bl,-0x19(%ebp)
./ls.asm:1012: 707:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./ls.asm:1044: 740:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:1054: 753:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ls.asm:1055: 756:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./ls.asm:1058: 75d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./ls.asm:1062: 769:	88 5d e7             	mov    %bl,-0x19(%ebp)
./ls.asm:1064: 76e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./ls.asm:1075: 780:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./ls.asm:1086: 799:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./ls.asm:1092: 7a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./ls.asm:1096: 7ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
./ls.asm:1107: 7c6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ls.asm:1108: 7c9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./ls.asm:1113: 7d3:	88 45 e7             	mov    %al,-0x19(%ebp)
./ls.asm:1127: 7ec:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./ls.asm:1131: 7f6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./ls.asm:1138: 807:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./ls.asm:1141: 80d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ls.asm:1147: 815:	88 45 e7             	mov    %al,-0x19(%ebp)
./ls.asm:1154: 821:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./ls.asm:1162: 833:	88 5d e7             	mov    %bl,-0x19(%ebp)
./ls.asm:1163: 836:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ls.asm:1182:  bp = (Header*)ap - 1;
./ls.asm:1183:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./ls.asm:1191:  bp = (Header*)ap - 1;
./ls.asm:1192: 85e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./ls.asm:1193:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./ls.asm:1195:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./ls.asm:1197:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./ls.asm:1202:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./ls.asm:1206:  if(bp + bp->s.size == p->s.ptr){
./ls.asm:1207: 876:	8b 73 fc             	mov    -0x4(%ebx),%esi
./ls.asm:1211:    bp->s.size += p->s.ptr->s.size;
./ls.asm:1212:    bp->s.ptr = p->s.ptr->s.ptr;
./ls.asm:1213: 880:	89 53 f8             	mov    %edx,-0x8(%ebx)
./ls.asm:1215:    bp->s.ptr = p->s.ptr;
./ls.asm:1216:  if(p + p->s.size == bp){
./ls.asm:1221:    p->s.size += bp->s.size;
./ls.asm:1222:    p->s.ptr = bp->s.ptr;
./ls.asm:1225:    p->s.ptr = bp;
./ls.asm:1237:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./ls.asm:1246:    bp->s.size += p->s.ptr->s.size;
./ls.asm:1248: 8b3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./ls.asm:1249:    bp->s.ptr = p->s.ptr->s.ptr;
./ls.asm:1252: 8ba:	89 53 f8             	mov    %edx,-0x8(%ebx)
./ls.asm:1253:  if(p + p->s.size == bp){
./ls.asm:1258:    p->s.size += bp->s.size;
./ls.asm:1259: 8c7:	03 53 fc             	add    -0x4(%ebx),%edx
./ls.asm:1262:    p->s.size += bp->s.size;
./ls.asm:1264:    p->s.ptr = bp->s.ptr;
./ls.asm:1265: 8d2:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./ls.asm:1291:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./ls.asm:1295:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./ls.asm:1305:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./ls.asm:1307:    if(p->s.size >= nunits){
./ls.asm:1319:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./ls.asm:1321:    if(p->s.size >= nunits){
./ls.asm:1325:        p->s.size = nunits;
./ls.asm:1338:  if(p == (char*)-1)
./ls.asm:1342:  hp->s.size = nu;
./ls.asm:1358: 960:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:1368:      if(p->s.size == nunits)
./ls.asm:1371:        p->s.size -= nunits;
./ls.asm:1374:        p += p->s.size;
./ls.asm:1376:        p->s.size = nunits;
./ls.asm:1381: 985:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ls.asm:1401:    if(p->s.size >= nunits){
./ls.asm:1405:        prevp->s.ptr = p->s.ptr;
./Notes:2:./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae --disable-reset-on-triple-fault
./Notes:4:./configure --enable-smp --enable-disasm --enable-debugger --enable-all-optimizations --enable-4meg-pages --enable-global-pages --enable-pae 
./Notes:7:sector-aligned. so you can't use ld -N. and the sections may also need
./Notes:8:to be non-zero length, only really matters for tiny "kernels".
./Notes:41:perhaps have fixed-size stack, put it in the data segment?
./Notes:55:test out-of-fd cases for creating pipe.
./Notes:67:  per-fd lock *just* protects count read-modify-write
./Notes:72:in general, the table locks protect both free-ness and
./Notes:78:  per-pipe lock
./Notes:87:what does inode->busy mean?
./Notes:89:  no-one is allowed to do anything to the inode
./Notes:91:inode->count counts in-memory pointers to the struct
./Notes:92:  prevents inode[] element from being re-used
./Notes:95:blocks and inodes have ad-hoc sleep-locks
./Notes:103:test: dup() shared fd->off
./Notes:110:sh: stop stdin on ctrl-d (for cat > y)
./sysfile.d:1:sysfile.o: sysfile.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./string.c:22:  while(n-- > 0){
./string.c:24:      return *s1 - *s2;
./string.c:42:    while(n-- > 0)
./string.c:43:      *--d = *--s;
./string.c:45:    while(n-- > 0)
./string.c:62:    n--, p++, q++;
./string.c:65:  return (uchar)*p - (uchar)*q;
./string.c:74:  while(n-- > 0 && (*s++ = *t++) != 0)
./string.c:76:  while(n-- > 0)
./string.c:81:// Like strncpy but guaranteed to NUL-terminate.
./string.c:90:  while(--n > 0 && (*s++ = *t++) != 0)
./ln.asm:2:_ln:     file format elf32-i386
./ln.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./ln.asm:88:  7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ln.asm:123:  return (uchar)*p - (uchar)*q;
./ln.asm:126:  c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ln.asm:132:  return (uchar)*p - (uchar)*q;
./ln.asm:137:  d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ln.asm:140:  return (uchar)*p - (uchar)*q;
./ln.asm:207: 132:	8b 7d fc             	mov    -0x4(%ebp),%edi
./ln.asm:264: 185:	8d 75 e7             	lea    -0x19(%ebp),%esi
./ln.asm:285: 1a4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./ln.asm:287: 1ab:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./ln.asm:306: 1ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ln.asm:337:    return -1;
./ln.asm:353: 214:	8d 65 f8             	lea    -0x8(%ebp),%esp
./ln.asm:360:    return -1;
./ln.asm:381: 23a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./ln.asm:390:    n = n*10 + *s++ - '0';
./ln.asm:393: 256:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./ln.asm:396: 25d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./ln.asm:401: 265:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./ln.asm:424:  while(n-- > 0)
./ln.asm:435:  while(n-- > 0)
./ln.asm:604:    x = -xx;
./ln.asm:608: 35d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./ln.asm:614:    x = -xx;
./ln.asm:623: 375:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./ln.asm:634: 392:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./ln.asm:641: 39e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./ln.asm:644:    buf[i++] = '-';
./ln.asm:645: 3a5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./ln.asm:647:  while(--i >= 0)
./ln.asm:649: 3ac:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./ln.asm:650: 3af:	8b 75 c0             	mov    -0x40(%ebp),%esi
./ln.asm:657: 3be:	88 45 d7             	mov    %al,-0x29(%ebp)
./ln.asm:658: 3c1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./ln.asm:663:  while(--i >= 0)
./ln.asm:670: 3d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ln.asm:710: 40e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./ln.asm:713: 418:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./ln.asm:724: 428:	8d 45 e7             	lea    -0x19(%ebp),%eax
./ln.asm:725: 42b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./ln.asm:730: 437:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./ln.asm:762: 470:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ln.asm:772: 483:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ln.asm:773: 486:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./ln.asm:776: 48d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./ln.asm:780: 499:	88 5d e7             	mov    %bl,-0x19(%ebp)
./ln.asm:782: 49e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./ln.asm:793: 4b0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./ln.asm:804: 4c9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./ln.asm:810: 4d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./ln.asm:814: 4de:	89 45 d0             	mov    %eax,-0x30(%ebp)
./ln.asm:825: 4f6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ln.asm:826: 4f9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./ln.asm:831: 503:	88 45 e7             	mov    %al,-0x19(%ebp)
./ln.asm:845: 51c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./ln.asm:849: 526:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./ln.asm:856: 537:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./ln.asm:859: 53d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ln.asm:865: 545:	88 45 e7             	mov    %al,-0x19(%ebp)
./ln.asm:872: 551:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./ln.asm:880: 563:	88 5d e7             	mov    %bl,-0x19(%ebp)
./ln.asm:881: 566:	8d 55 e7             	lea    -0x19(%ebp),%edx
./ln.asm:900:  bp = (Header*)ap - 1;
./ln.asm:901:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./ln.asm:909:  bp = (Header*)ap - 1;
./ln.asm:910: 58e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./ln.asm:911:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./ln.asm:913:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./ln.asm:915:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./ln.asm:920:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./ln.asm:924:  if(bp + bp->s.size == p->s.ptr){
./ln.asm:925: 5a6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./ln.asm:929:    bp->s.size += p->s.ptr->s.size;
./ln.asm:930:    bp->s.ptr = p->s.ptr->s.ptr;
./ln.asm:931: 5b0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./ln.asm:933:    bp->s.ptr = p->s.ptr;
./ln.asm:934:  if(p + p->s.size == bp){
./ln.asm:939:    p->s.size += bp->s.size;
./ln.asm:940:    p->s.ptr = bp->s.ptr;
./ln.asm:943:    p->s.ptr = bp;
./ln.asm:955:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./ln.asm:964:    bp->s.size += p->s.ptr->s.size;
./ln.asm:966: 5e3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./ln.asm:967:    bp->s.ptr = p->s.ptr->s.ptr;
./ln.asm:970: 5ea:	89 53 f8             	mov    %edx,-0x8(%ebx)
./ln.asm:971:  if(p + p->s.size == bp){
./ln.asm:976:    p->s.size += bp->s.size;
./ln.asm:977: 5f7:	03 53 fc             	add    -0x4(%ebx),%edx
./ln.asm:980:    p->s.size += bp->s.size;
./ln.asm:982:    p->s.ptr = bp->s.ptr;
./ln.asm:983: 602:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./ln.asm:1009:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./ln.asm:1013:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./ln.asm:1023:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./ln.asm:1025:    if(p->s.size >= nunits){
./ln.asm:1037:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./ln.asm:1039:    if(p->s.size >= nunits){
./ln.asm:1043:        p->s.size = nunits;
./ln.asm:1056:  if(p == (char*)-1)
./ln.asm:1060:  hp->s.size = nu;
./ln.asm:1076: 690:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ln.asm:1086:      if(p->s.size == nunits)
./ln.asm:1089:        p->s.size -= nunits;
./ln.asm:1092:        p += p->s.size;
./ln.asm:1094:        p->s.size = nunits;
./ln.asm:1099: 6b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./ln.asm:1119:    if(p->s.size >= nunits){
./ln.asm:1123:        prevp->s.ptr = p->s.ptr;
./umalloc.d:1:umalloc.o: umalloc.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./pr.pl:5:if($ARGV[0] eq "-h"){
./pr.pl:30:	if($lines[$i] =~ /^([0-9][0-9])[0-9][0-9] /){
./bio.d:1:bio.o: bio.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./sleeplock.h:6:// Long-term locks for processes
./toc.ftr:3:The source listing is preceded by a cross-reference that lists every defined 
./grep.c:17:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
./grep.c:25:        write(1, p, q+1 - p);
./grep.c:32:      m -= p - buf;
./kernel.ld:4:OUTPUT_FORMAT("elf32-i386", "elf32-i386", "elf32-i386")
./kernel.ld:40:	/* Conventionally, Unix linkers provide pseudo-symbols
./kernel.ld:45:	 * read-only rodata section between text and data. */
./kernel.ld:62:		*(.eh_frame .note.GNU-stack)
./ulib.c:23:  return (uchar)*p - (uchar)*q;
./ulib.c:78:    return -1;
./ulib.c:91:    n = n*10 + *s++ - '0';
./ulib.c:103:  while(n-- > 0)
./cat.d:1:cat.o: cat.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./.dir-locals.el:1:((c-mode
./.dir-locals.el:2:  (indent-tabs-mode . nil)
./.dir-locals.el:3:  (c-file-style . "bsd")
./.dir-locals.el:4:  (c-basic-offset . 2)))
./mkdir.d:1:mkdir.o: mkdir.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./ioapic.c:21:#define INT_LEVEL      0x00008000  // Level-triggered (vs edge-)
./ioapic.c:37:  ioapic->reg = reg;
./ioapic.c:38:  return ioapic->data;
./ioapic.c:44:  ioapic->reg = reg;
./ioapic.c:45:  ioapic->data = data;
./ioapic.c:59:  // Mark all interrupts edge-triggered, active high, disabled,
./ioapic.c:70:  // Mark interrupt edge-triggered, active high,
./spinlock.d:1:spinlock.o: spinlock.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./forktest.c:36:  for(; n > 0; n--){
./forktest.c:43:  if(wait() != -1){
./.gdbinit.tmpl:1:set $lastcs = -1
./.gdbinit.tmpl:3:define hook-stop
./.gdbinit.tmpl:4:  # There doesn't seem to be a good way to detect if we're in 16- or
./.gdbinit.tmpl:5:  # 32-bit mode, but in 32-bit mode we always run with CS == 8 in the
./.gdbinit.tmpl:13:    if $lastcs == -1 || $lastcs == 8 || $lastcs == 35
./.gdbinit.tmpl:26:echo + symbol-file kernel\n
./.gdbinit.tmpl:27:symbol-file kernel
./file.h:12:// in-memory copy of an inode
./.goutputstream-MLRB42:47:  if(tf->trapno == T_SYSCALL){
./.goutputstream-MLRB42:48:    if(myproc()->killed)
./.goutputstream-MLRB42:50:    myproc()->tf = tf;
./.goutputstream-MLRB42:52:    if(myproc()->killed)
./.goutputstream-MLRB42:57:  switch(tf->trapno){
./.goutputstream-MLRB42:69:     // if(myproc() && myproc()->state == SUSPENDED) {
./.goutputstream-MLRB42:93:            cpuid(), tf->cs, tf->eip);
./.goutputstream-MLRB42:99:    if(myproc() == 0 || (tf->cs&3) == 0){
./.goutputstream-MLRB42:102:              tf->trapno, cpuid(), tf->eip, rcr2());
./.goutputstream-MLRB42:107:            "eip 0x%x addr 0x%x--kill proc\n",
./.goutputstream-MLRB42:108:            myproc()->pid, myproc()->name, tf->trapno,
./.goutputstream-MLRB42:109:            tf->err, cpuid(), tf->eip, rcr2());
./.goutputstream-MLRB42:110:    myproc()->killed = 1;
./.goutputstream-MLRB42:113:  //---------------------------------------------------------------------------------------------------------------------->
./.goutputstream-MLRB42:115:    if(myproc() && myproc()->pending_signals) {
./.goutputstream-MLRB42:116:        if(myproc()->pending_signals & (1 << (SIGCUSTOM - 1))) {
./.goutputstream-MLRB42:117:            if(myproc()->sighandler) {
./.goutputstream-MLRB42:119:                uint old_eip = tf->eip;
./.goutputstream-MLRB42:120:                uint *new_esp = (uint*)(tf->esp - 4);
./.goutputstream-MLRB42:121:                if(copyout(myproc()->pgdir, (uint)new_esp, (char*)&old_eip, 4) < 0) {
./.goutputstream-MLRB42:122:                    myproc()->killed = 1;
./.goutputstream-MLRB42:124:                    tf->esp = (uint)new_esp;
./.goutputstream-MLRB42:125:                    tf->eip = (uint)myproc()->sighandler;
./.goutputstream-MLRB42:127:                myproc()->pending_signals &= ~(1 << (SIGCUSTOM - 1));
./.goutputstream-MLRB42:132:   //--------------------------------------------------------------------------------------------------------------------->
./.goutputstream-MLRB42:137:		if(p->pid == 2)
./.goutputstream-MLRB42:142:	if(myproc() && myproc()->pending_suspend) {
./.goutputstream-MLRB42:144:		myproc()->state = SUSPENDED;
./.goutputstream-MLRB42:145:		myproc()->pending_suspend = 0;
./.goutputstream-MLRB42:148:		cprintf("pid : %d I am suspended \n",myproc()->pid);
./.goutputstream-MLRB42:152:	//--------------------------------------------------------------------------------------------------------------------->
./.goutputstream-MLRB42:169:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER){
./.goutputstream-MLRB42:172:		cprintf("pid : %d , p->killed : %d , state : %s \n",newp->pid,newp->killed,states[p->state]);
./.goutputstream-MLRB42:173:	  cprintf("pid : %d I am going to be killed\n",myproc()->pid);
./.goutputstream-MLRB42:179:  if(myproc() && myproc()->state == RUNNING &&
./.goutputstream-MLRB42:180:     tf->trapno == T_IRQ0+IRQ_TIMER)
./.goutputstream-MLRB42:184:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
./log.c:19:// the count of in-progress FS system calls and returns.
./log.c:23:// The log is a physical re-do log containing disk blocks.
./log.c:24:// The on-disk log format:
./log.c:32:// Contents of the header block, used for both the on-disk header block
./log.c:77:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
./log.c:84:// Read the log header from disk into the in-memory log header
./log.c:89:  struct logheader *lh = (struct logheader *) (buf->data);
./log.c:91:  log.lh.n = lh->n;
./log.c:93:    log.lh.block[i] = lh->block[i];
./log.c:98:// Write in-memory log header to disk.
./log.c:105:  struct logheader *hb = (struct logheader *) (buf->data);
./log.c:107:  hb->n = log.lh.n;
./log.c:109:    hb->block[i] = log.lh.block[i];
./log.c:151:  log.outstanding -= 1;
./log.c:185:    memmove(to->data, from->data, BSIZE);
./log.c:197:    write_head();    // Write header to disk -- the real commit
./log.c:204:// Caller has modified b->data and is done with the buffer.
./log.c:210://   modify bp->data[]
./log.c:218:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
./log.c:224:  if (b->blockno >= 2 && b->blockno < 2 + NSWAPBLOCKS) {
./log.c:230:    if (log.lh.block[i] == b->blockno)   // log absorbtion
./log.c:233:  log.lh.block[i] = b->blockno;
./log.c:236:  b->flags |= B_DIRTY; // prevent eviction
./gdbutil:1:# -*- gdb-script -*-
./gdbutil:3:# Utility functions to pretty-print x86 segment/interrupt descriptors.
./gdbutil:7:# IA32 2007, Volume 3A, Table 3-2
./gdbutil:76:# IA32 2007, Volume 3A, Table 3-1
./gdbutil:111:# xv6-specific
./gdbutil:219:  # IA32 2007, Voume 3A, Figure 5-2
./gdbutil:232:  # IA32 20007, Volume 3A, Figure 3-8 and Figure 4-1
./gdbutil:247:        printf "16-bit (0)"
./gdbutil:249:        printf "32-bit (1)"
./bootmain.c:4:// bootasm.S has put the processor into protected 32-bit mode.
./bootmain.c:31:  if(elf->magic != ELF_MAGIC)
./bootmain.c:35:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
./bootmain.c:36:  eph = ph + elf->phnum;
./bootmain.c:38:    pa = (uchar*)ph->paddr;
./bootmain.c:39:    readseg(pa, ph->filesz, ph->off);
./bootmain.c:40:    if(ph->memsz > ph->filesz)
./bootmain.c:41:      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
./bootmain.c:46:  entry = (void(*)(void))(elf->entry);
./bootmain.c:69:  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
./bootmain.c:86:  pa -= offset % SECTSIZE;
./bootmain.c:92:  // We'd write more to memory than asked, but it doesn't matter --
./asm.h:9:// The 0xC0 means the limit is in 4096-byte units
./asm.h:10:// and (for executable segments) 32-bit mode.
./asm.h:17:#define STA_W     0x2       // Writeable (non-executable segments)
./syscall.c:22:  if(addr >= curproc->sz || addr+4 > curproc->sz)
./syscall.c:23:    return -1;
./syscall.c:28:// Fetch the nul-terminated string at addr from the current process.
./syscall.c:29:// Doesn't actually copy the string - just sets *pp to point at it.
./syscall.c:37:  if(addr >= curproc->sz)
./syscall.c:38:    return -1;
./syscall.c:40:  ep = (char*)curproc->sz;
./syscall.c:43:      return s - *pp;
./syscall.c:45:  return -1;
./syscall.c:48:// Fetch the nth 32-bit system call argument.
./syscall.c:52:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./syscall.c:55:// Fetch the nth word-sized system call argument as a pointer
./syscall.c:65:    return -1;
./syscall.c:66:  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
./syscall.c:67:    return -1;
./syscall.c:72:// Fetch the nth word-sized system call argument as a string pointer.
./syscall.c:73:// Check that the pointer is valid and the string is nul-terminated.
./syscall.c:81:    return -1;
./syscall.c:139:  num = curproc->tf->eax; // eax contain the system call number that need to be called 
./syscall.c:141:    curproc->tf->eax = syscalls[num](); //syscalls[num]() is a kernal function that will use above syscalls[]->int 
./syscall.c:144:            curproc->pid, curproc->name, num);
./syscall.c:145:    curproc->tf->eax = -1;
./usertests.d:1:usertests.o: usertests.c /usr/i686-linux-gnu/include/stdc-predef.h \
./picirq.d:1:picirq.o: picirq.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./wc.asm:2:_wc:     file format elf32-i386
./wc.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./wc.asm:27:  1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./wc.asm:55:  4c:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
./wc.asm:111:  af:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
./wc.asm:112:  b6:	89 55 dc             	mov    %edx,-0x24(%ebp)
./wc.asm:125:  de:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
./wc.asm:133:  ed:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
./wc.asm:156: 11b:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
./wc.asm:161: 127:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
./wc.asm:164: 130:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
./wc.asm:165: 133:	01 4d dc             	add    %ecx,-0x24(%ebp)
./wc.asm:170: 140:	8b 55 dc             	mov    -0x24(%ebp),%edx
./wc.asm:176: 14c:	ff 75 e0             	push   -0x20(%ebp)
./wc.asm:183: 15f:	8d 65 f4             	lea    -0xc(%ebp),%esp
./wc.asm:229: 19e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./wc.asm:264:  return (uchar)*p - (uchar)*q;
./wc.asm:267: 1e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./wc.asm:273:  return (uchar)*p - (uchar)*q;
./wc.asm:278: 1f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./wc.asm:281:  return (uchar)*p - (uchar)*q;
./wc.asm:348: 252:	8b 7d fc             	mov    -0x4(%ebp),%edi
./wc.asm:405: 2a5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./wc.asm:426: 2c4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./wc.asm:428: 2cb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./wc.asm:447: 2ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
./wc.asm:478:    return -1;
./wc.asm:494: 334:	8d 65 f8             	lea    -0x8(%ebp),%esp
./wc.asm:501:    return -1;
./wc.asm:522: 35a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./wc.asm:531:    n = n*10 + *s++ - '0';
./wc.asm:534: 376:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./wc.asm:537: 37d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./wc.asm:542: 385:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./wc.asm:565:  while(n-- > 0)
./wc.asm:576:  while(n-- > 0)
./wc.asm:745:    x = -xx;
./wc.asm:749: 47d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./wc.asm:755:    x = -xx;
./wc.asm:764: 495:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./wc.asm:775: 4b2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./wc.asm:782: 4be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./wc.asm:785:    buf[i++] = '-';
./wc.asm:786: 4c5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./wc.asm:788:  while(--i >= 0)
./wc.asm:790: 4cc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./wc.asm:791: 4cf:	8b 75 c0             	mov    -0x40(%ebp),%esi
./wc.asm:798: 4de:	88 45 d7             	mov    %al,-0x29(%ebp)
./wc.asm:799: 4e1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./wc.asm:804:  while(--i >= 0)
./wc.asm:811: 4f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./wc.asm:851: 52e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./wc.asm:854: 538:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./wc.asm:865: 548:	8d 45 e7             	lea    -0x19(%ebp),%eax
./wc.asm:866: 54b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./wc.asm:871: 557:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./wc.asm:903: 590:	8d 65 f4             	lea    -0xc(%ebp),%esp
./wc.asm:913: 5a3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./wc.asm:914: 5a6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./wc.asm:917: 5ad:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./wc.asm:921: 5b9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./wc.asm:923: 5be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./wc.asm:934: 5d0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./wc.asm:945: 5e9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./wc.asm:951: 5f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./wc.asm:955: 5fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
./wc.asm:966: 616:	8d 55 e7             	lea    -0x19(%ebp),%edx
./wc.asm:967: 619:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./wc.asm:972: 623:	88 45 e7             	mov    %al,-0x19(%ebp)
./wc.asm:986: 63c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./wc.asm:990: 646:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./wc.asm:997: 657:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./wc.asm:1000: 65d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./wc.asm:1006: 665:	88 45 e7             	mov    %al,-0x19(%ebp)
./wc.asm:1013: 671:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./wc.asm:1021: 683:	88 5d e7             	mov    %bl,-0x19(%ebp)
./wc.asm:1022: 686:	8d 55 e7             	lea    -0x19(%ebp),%edx
./wc.asm:1041:  bp = (Header*)ap - 1;
./wc.asm:1042:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./wc.asm:1050:  bp = (Header*)ap - 1;
./wc.asm:1051: 6ae:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./wc.asm:1052:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./wc.asm:1054:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./wc.asm:1056:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./wc.asm:1061:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./wc.asm:1065:  if(bp + bp->s.size == p->s.ptr){
./wc.asm:1066: 6c6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./wc.asm:1070:    bp->s.size += p->s.ptr->s.size;
./wc.asm:1071:    bp->s.ptr = p->s.ptr->s.ptr;
./wc.asm:1072: 6d0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./wc.asm:1074:    bp->s.ptr = p->s.ptr;
./wc.asm:1075:  if(p + p->s.size == bp){
./wc.asm:1080:    p->s.size += bp->s.size;
./wc.asm:1081:    p->s.ptr = bp->s.ptr;
./wc.asm:1084:    p->s.ptr = bp;
./wc.asm:1096:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./wc.asm:1105:    bp->s.size += p->s.ptr->s.size;
./wc.asm:1107: 703:	89 73 fc             	mov    %esi,-0x4(%ebx)
./wc.asm:1108:    bp->s.ptr = p->s.ptr->s.ptr;
./wc.asm:1111: 70a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./wc.asm:1112:  if(p + p->s.size == bp){
./wc.asm:1117:    p->s.size += bp->s.size;
./wc.asm:1118: 717:	03 53 fc             	add    -0x4(%ebx),%edx
./wc.asm:1121:    p->s.size += bp->s.size;
./wc.asm:1123:    p->s.ptr = bp->s.ptr;
./wc.asm:1124: 722:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./wc.asm:1150:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./wc.asm:1154:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./wc.asm:1164:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./wc.asm:1166:    if(p->s.size >= nunits){
./wc.asm:1178:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./wc.asm:1180:    if(p->s.size >= nunits){
./wc.asm:1184:        p->s.size = nunits;
./wc.asm:1197:  if(p == (char*)-1)
./wc.asm:1201:  hp->s.size = nu;
./wc.asm:1217: 7b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./wc.asm:1227:      if(p->s.size == nunits)
./wc.asm:1230:        p->s.size -= nunits;
./wc.asm:1233:        p += p->s.size;
./wc.asm:1235:        p->s.size = nunits;
./wc.asm:1240: 7d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./wc.asm:1260:    if(p->s.size >= nunits){
./wc.asm:1264:        prevp->s.ptr = p->s.ptr;
./wc.d:1:wc.o: wc.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./sleeplock.d:1:sleeplock.o: sleeplock.c /usr/i686-linux-gnu/include/stdc-predef.h \
./swtch.S:7:# Switch stacks to new and pop previously-saved registers.
./swtch.S:14:  # Save old callee-saved registers
./swtch.S:24:  # Load new callee-saved registers
./test2.d:1:test2.o: test2.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./proc.h:4:// Per-CPU state
./proc.h:41:// Per-process state
./proc.h:51:  void *chan;                  // If non-zero, sleeping on chan
./proc.h:52:  int killed;                  // If non-zero, have been killed
./proc.h:70://   fixed-size stack
./kernel.asm:2:kernel:     file format elf32-i386
./kernel.asm:44:  # the assembler produces a PC-relative instruction
./kernel.asm:93:    b->next = bcache.head.next;
./kernel.asm:95:    b->prev = &bcache.head;
./kernel.asm:96:    initsleeplock(&b->lock, "buffer");
./kernel.asm:99:    b->prev = &bcache.head;
./kernel.asm:101:    initsleeplock(&b->lock, "buffer");
./kernel.asm:105:    bcache.head.next->prev = b;
./kernel.asm:110:    bcache.head.next->prev = b;
./kernel.asm:120:801000be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:145:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
./kernel.asm:155:    if(b->dev == dev && b->blockno == blockno){
./kernel.asm:160:      b->refcnt++;
./kernel.asm:165:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
./kernel.asm:173:    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
./kernel.asm:179:      b->dev = dev;
./kernel.asm:181:      b->blockno = blockno;
./kernel.asm:183:      b->flags = 0;
./kernel.asm:185:      b->refcnt = 1;
./kernel.asm:191:      acquiresleep(&b->lock);
./kernel.asm:200:  if((b->flags & B_VALID) == 0) {
./kernel.asm:207:8010017a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:221:80100194:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:245:  if(!holdingsleep(&b->lock))
./kernel.asm:253:  b->flags |= B_DIRTY;
./kernel.asm:258:801001d0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:282:  if(!holdingsleep(&b->lock))
./kernel.asm:292:  releasesleep(&b->lock);
./kernel.asm:300:  b->refcnt--;
./kernel.asm:302:  if (b->refcnt == 0) {
./kernel.asm:304:  b->refcnt--;
./kernel.asm:307:  if (b->refcnt == 0) {
./kernel.asm:311:    b->next->prev = b->prev;
./kernel.asm:315:    b->prev->next = b->next;
./kernel.asm:318:    b->next = bcache.head.next;
./kernel.asm:320:    b->prev = &bcache.head;
./kernel.asm:322:    b->next = bcache.head.next;
./kernel.asm:324:    bcache.head.next->prev = b;
./kernel.asm:334:80100263:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:385:      if(myproc()->killed){
./kernel.asm:388:        return -1;
./kernel.asm:400:      if(myproc()->killed){
./kernel.asm:413:        return -1;
./kernel.asm:419:  return target - n;
./kernel.asm:421:80100307:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:422:        return -1;
./kernel.asm:436:80100326:	0f be 8a a0 fe 10 80 	movsbl -0x7fef0160(%edx),%ecx
./kernel.asm:442:    --n;
./kernel.asm:445:80100338:	88 4e ff             	mov    %cl,-0x1(%esi)
./kernel.asm:457:  return target - n;
./kernel.asm:461:8010035f:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:462:  return target - n;
./kernel.asm:473:        input.r--;
./kernel.asm:498:80100393:	8d 5d d0             	lea    -0x30(%ebp),%ebx
./kernel.asm:499:80100396:	8d 75 f8             	lea    -0x8(%ebp),%esi
./kernel.asm:587:    pos += 80 - pos%80;
./kernel.asm:603:8010047f:	8d b4 36 00 80 0b 80 	lea    -0x7ff48000(%esi,%esi,1),%esi
./kernel.asm:605:80100486:	88 45 e7             	mov    %al,-0x19(%ebp)
./kernel.asm:620:801004ab:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./kernel.asm:627:801004ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:638:801004d1:	66 89 9c 00 00 80 0b 	mov    %bx,-0x7ff48000(%eax,%eax,1)
./kernel.asm:670:    if(pos > 0) --pos;
./kernel.asm:679:    pos -= 80;
./kernel.asm:680:80100543:	8d 5e b0             	lea    -0x50(%esi),%ebx
./kernel.asm:681:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
./kernel.asm:682:80100546:	8d b4 36 60 7f 0b 80 	lea    -0x7ff480a0(%esi,%esi,1),%esi
./kernel.asm:690:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
./kernel.asm:700:8010057b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./kernel.asm:706:80100590:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
./kernel.asm:770:80100612:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:794:80100634:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
./kernel.asm:805:8010064b:	0f b6 92 10 84 10 80 	movzbl -0x7fef7bf0(%edx),%edx
./kernel.asm:806:80100652:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./kernel.asm:813:8010065e:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
./kernel.asm:816:    buf[i++] = '-';
./kernel.asm:817:80100665:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./kernel.asm:818:  while(--i >= 0)
./kernel.asm:820:8010066c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./kernel.asm:834:  while(--i >= 0)
./kernel.asm:835:8010068d:	8d 47 ff             	lea    -0x1(%edi),%eax
./kernel.asm:840:    x = -xx;
./kernel.asm:843:8010069a:	c7 45 d4 01 00 00 00 	movl   $0x1,-0x2c(%ebp)
./kernel.asm:844:    x = -xx;
./kernel.asm:881:801006dc:	89 7d e4             	mov    %edi,-0x1c(%ebp)
./kernel.asm:905:80100715:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:908:8010071f:	8b 7d e0             	mov    -0x20(%ebp),%edi
./kernel.asm:914:8010072d:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:919:80100738:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:952:80100791:	89 4d e0             	mov    %ecx,-0x20(%ebp)
./kernel.asm:955:8010079e:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./kernel.asm:966:801007ba:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:969:801007c4:	8b 7d e0             	mov    -0x20(%ebp),%edi
./kernel.asm:1003:8010081a:	89 5d e0             	mov    %ebx,-0x20(%ebp)
./kernel.asm:1037:8010086a:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./kernel.asm:1079:801008cb:	ff 24 85 b8 83 10 80 	jmp    *-0x7fef7c48(,%eax,4)
./kernel.asm:1086:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
./kernel.asm:1091:801008f1:	80 ba a0 fe 10 80 0a 	cmpb   $0xa,-0x7fef0160(%edx)
./kernel.asm:1095:        input.e--;
./kernel.asm:1104:      if(c != 0 && input.e-input.r < INPUT_BUF){
./kernel.asm:1123:80100942:	c6 83 a0 fe 10 80 0a 	movb   $0xa,-0x7fef0160(%ebx)
./kernel.asm:1141:      cprintf("Ctrl - P is detected by xv6\n");
./kernel.asm:1145:      cprintf("Ctrl - P is detected by xv6\n");
./kernel.asm:1159:801009a8:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1180:        input.e--;
./kernel.asm:1191:		cprintf("Ctrl - G is detected by xv6\n");
./kernel.asm:1201:		cprintf("Ctrl - F is detected by xv6\n");
./kernel.asm:1211:		cprintf("Ctrl - C is detected by xv6\n");
./kernel.asm:1221:		cprintf("Ctrl - B is detected by xv6\n");
./kernel.asm:1235:      if(c != 0 && input.e-input.r < INPUT_BUF){
./kernel.asm:1247:80100ac2:	88 83 a0 fe 10 80    	mov    %al,-0x7fef0160(%ebx)
./kernel.asm:1251:80100acc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:1254:80100ad4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:1272:80100b18:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1348:80100b91:	89 85 ec fe ff ff    	mov    %eax,-0x114(%ebp)
./kernel.asm:1362:    return -1;
./kernel.asm:1373:80100bbd:	8d 85 24 ff ff ff    	lea    -0xdc(%ebp),%eax
./kernel.asm:1384:80100bda:	81 bd 24 ff ff ff 7f 	cmpl   $0x464c457f,-0xdc(%ebp)
./kernel.asm:1391:80100bef:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%ebp)
./kernel.asm:1399:  curproc->rss = 0;
./kernel.asm:1400:80100bfd:	8b 85 ec fe ff ff    	mov    -0x114(%ebp),%eax
./kernel.asm:1403:80100c03:	66 83 bd 50 ff ff ff 	cmpw   $0x0,-0xb0(%ebp)
./kernel.asm:1405:80100c0b:	8b b5 40 ff ff ff    	mov    -0xc0(%ebp),%esi
./kernel.asm:1406:  curproc->rss = 0;
./kernel.asm:1412:80100c21:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
./kernel.asm:1421:80100c38:	83 bd 04 ff ff ff 01 	cmpl   $0x1,-0xfc(%ebp)
./kernel.asm:1425:80100c41:	8b 85 18 ff ff ff    	mov    -0xe8(%ebp),%eax
./kernel.asm:1426:80100c47:	3b 85 14 ff ff ff    	cmp    -0xec(%ebp),%eax
./kernel.asm:1430:80100c53:	03 85 0c ff ff ff    	add    -0xf4(%ebp),%eax
./kernel.asm:1434:80100c5f:	ff b5 ec fe ff ff    	push   -0x114(%ebp)
./kernel.asm:1436:80100c66:	ff b5 f0 fe ff ff    	push   -0x110(%ebp)
./kernel.asm:1437:80100c6c:	ff b5 f4 fe ff ff    	push   -0x10c(%ebp)
./kernel.asm:1440:80100c7a:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
./kernel.asm:1445:80100c84:	8b 85 0c ff ff ff    	mov    -0xf4(%ebp),%eax
./kernel.asm:1451:80100c94:	ff b5 14 ff ff ff    	push   -0xec(%ebp)
./kernel.asm:1452:80100c9a:	ff b5 08 ff ff ff    	push   -0xf8(%ebp)
./kernel.asm:1455:80100ca2:	ff b5 f4 fe ff ff    	push   -0x10c(%ebp)
./kernel.asm:1461:80100cb4:	0f b7 85 50 ff ff ff 	movzwl -0xb0(%ebp),%eax
./kernel.asm:1467:80100cc5:	8d 85 04 ff ff ff    	lea    -0xfc(%ebp),%eax
./kernel.asm:1483:80100ce4:	ff b5 ec fe ff ff    	push   -0x114(%ebp)
./kernel.asm:1484:80100cea:	ff b5 f4 fe ff ff    	push   -0x10c(%ebp)
./kernel.asm:1495:    return -1;
./kernel.asm:1498:  return -1;
./kernel.asm:1500:80100d0e:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1510:80100d20:	8b b5 f0 fe ff ff    	mov    -0x110(%ebp),%esi
./kernel.asm:1522:80100d46:	ff b5 ec fe ff ff    	push   -0x114(%ebp)
./kernel.asm:1525:80100d4e:	8b b5 f4 fe ff ff    	mov    -0x10c(%ebp),%esi
./kernel.asm:1532:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
./kernel.asm:1534:80100d6a:	8d 80 00 e0 ff ff    	lea    -0x2000(%eax),%eax
./kernel.asm:1537:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
./kernel.asm:1542:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
./kernel.asm:1550:80100d8b:	89 bd f0 fe ff ff    	mov    %edi,-0x110(%ebp)
./kernel.asm:1558:80100da3:	89 9c b5 64 ff ff ff 	mov    %ebx,-0x9c(%ebp,%esi,4)
./kernel.asm:1559:80100daa:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
./kernel.asm:1568:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
./kernel.asm:1575:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
./kernel.asm:1580:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
./kernel.asm:1587:80100de0:	ff b5 f4 fe ff ff    	push   -0x10c(%ebp)
./kernel.asm:1594:80100df5:	ff b5 ec fe ff ff    	push   -0x114(%ebp)
./kernel.asm:1595:80100dfb:	ff b5 f4 fe ff ff    	push   -0x10c(%ebp)
./kernel.asm:1599:  ustack[2] = sp - (argc+1)*4;  // argv pointer
./kernel.asm:1602:80100e15:	8b bd f0 fe ff ff    	mov    -0x110(%ebp),%edi
./kernel.asm:1603:80100e1b:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%ebp)
./kernel.asm:1605:  sp -= (3+argc+1) * 4;
./kernel.asm:1608:80100e27:	c7 84 85 58 ff ff ff 	movl   $0x0,-0xa8(%ebp,%eax,4)
./kernel.asm:1611:80100e32:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
./kernel.asm:1613:80100e38:	c7 85 58 ff ff ff ff 	movl   $0xffffffff,-0xa8(%ebp)
./kernel.asm:1616:80100e42:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%ebp)
./kernel.asm:1617:  ustack[2] = sp - (argc+1)*4;  // argv pointer
./kernel.asm:1619:  sp -= (3+argc+1) * 4;
./kernel.asm:1621:  ustack[2] = sp - (argc+1)*4;  // argv pointer
./kernel.asm:1623:80100e4e:	89 85 60 ff ff ff    	mov    %eax,-0xa0(%ebp)
./kernel.asm:1628:80100e57:	ff b5 f4 fe ff ff    	push   -0x10c(%ebp)
./kernel.asm:1652:  safestrcpy(curproc->name, last, sizeof(curproc->name));
./kernel.asm:1656:80100e95:	8b b5 ec fe ff ff    	mov    -0x114(%ebp),%esi
./kernel.asm:1660:  curproc->pgdir = pgdir;
./kernel.asm:1661:80100ea4:	8b 8d f4 fe ff ff    	mov    -0x10c(%ebp),%ecx
./kernel.asm:1662:  oldpgdir = curproc->pgdir;
./kernel.asm:1665:  curproc->sz = sz;
./kernel.asm:1667:  curproc->tf->eip = elf.entry;  // main
./kernel.asm:1669:  curproc->pgdir = pgdir;
./kernel.asm:1671:  curproc->tf->eip = elf.entry;  // main
./kernel.asm:1673:80100eb9:	8b 95 3c ff ff ff    	mov    -0xc4(%ebp),%edx
./kernel.asm:1675:  curproc->tf->esp = sp;
./kernel.asm:1699:80100efe:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
./kernel.asm:1701:80100f08:	8d 8d 58 ff ff ff    	lea    -0xa8(%ebp),%ecx
./kernel.asm:1709:    return -1;
./kernel.asm:1761:    if(f->ref == 0){
./kernel.asm:1765:      f->ref = 1;
./kernel.asm:1768:      f->ref = 1;
./kernel.asm:1783:80100f9b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:1798:80100fb4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:1817:  if(f->ref < 1)
./kernel.asm:1823:  f->ref++;
./kernel.asm:1827:  f->ref++;
./kernel.asm:1835:80100ff3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:1864:  if(f->ref < 1)
./kernel.asm:1870:  if(--f->ref > 0){
./kernel.asm:1879:  f->ref = 0;
./kernel.asm:1880:  f->type = FD_NONE;
./kernel.asm:1885:  f->type = FD_NONE;
./kernel.asm:1889:8010104e:	88 45 e7             	mov    %al,-0x19(%ebp)
./kernel.asm:1891:80101054:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:1909:8010106e:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1921:80101087:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1933:801010a0:	ff 75 e0             	push   -0x20(%ebp)
./kernel.asm:1938:801010ab:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1949:801010c0:	0f be 5d e7          	movsbl -0x19(%ebp),%ebx
./kernel.asm:1956:801010d1:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:1981:  if(f->type == FD_INODE){
./kernel.asm:1984:    ilock(f->ip);
./kernel.asm:1988:    stati(f->ip, st);
./kernel.asm:1994:    iunlock(f->ip);
./kernel.asm:2000:  return -1;
./kernel.asm:2002:80101120:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:2010:80101130:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:2011:  return -1;
./kernel.asm:2035:  if(f->readable == 0)
./kernel.asm:2038:    return -1;
./kernel.asm:2039:  if(f->type == FD_PIPE)
./kernel.asm:2043:    return piperead(f->pipe, addr, n);
./kernel.asm:2044:  if(f->type == FD_INODE){
./kernel.asm:2047:    ilock(f->ip);
./kernel.asm:2051:    if((r = readi(f->ip, addr, f->off, n)) > 0)
./kernel.asm:2061:      f->off += r;
./kernel.asm:2063:    iunlock(f->ip);
./kernel.asm:2072:80101196:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2079:    return piperead(f->pipe, addr, n);
./kernel.asm:2083:801011a6:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2088:    return piperead(f->pipe, addr, n);
./kernel.asm:2091:    return -1;
./kernel.asm:2115:801011df:	89 45 dc             	mov    %eax,-0x24(%ebp)
./kernel.asm:2119:  if(f->writable == 0)
./kernel.asm:2122:801011e9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:2123:  if(f->writable == 0)
./kernel.asm:2125:    return -1;
./kernel.asm:2126:  if(f->type == FD_PIPE)
./kernel.asm:2130:    return pipewrite(f->pipe, addr, n);
./kernel.asm:2131:  if(f->type == FD_INODE){
./kernel.asm:2134:    // and 2 blocks of slop for non-aligned writes.
./kernel.asm:2137:    int max = ((MAXOPBLOCKS-1-1-2) / 2) * 512;
./kernel.asm:2140:80101206:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:2151:      ilock(f->ip);
./kernel.asm:2152:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
./kernel.asm:2153:        f->off += r;
./kernel.asm:2155:      iunlock(f->ip);
./kernel.asm:2157:        f->off += r;
./kernel.asm:2158:8010121e:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:2159:      iunlock(f->ip);
./kernel.asm:2168:8010122e:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:2176:8010123a:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
./kernel.asm:2178:      int n1 = n - i;
./kernel.asm:2179:8010123f:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:2182:      int n1 = n - i;
./kernel.asm:2189:      ilock(f->ip);
./kernel.asm:2193:      if ((r = writei(f->ip, addr + i, f->off, n1)) > 0)
./kernel.asm:2196:80101262:	8b 45 dc             	mov    -0x24(%ebp),%eax
./kernel.asm:2204:80101277:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:2205:      iunlock(f->ip);
./kernel.asm:2212:8010128a:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:2222:    return i == n ? n : -1;
./kernel.asm:2223:801012a8:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
./kernel.asm:2229:801012b2:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2236:    return pipewrite(f->pipe, addr, n);
./kernel.asm:2240:801012c2:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2245:    return pipewrite(f->pipe, addr, n);
./kernel.asm:2275:801012ef:	89 45 dc             	mov    %eax,-0x24(%ebp)
./kernel.asm:2287:8010130d:	ff 75 dc             	push   -0x24(%ebp)
./kernel.asm:2290:80101318:	89 7d d8             	mov    %edi,-0x28(%ebp)
./kernel.asm:2291:8010131b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:2294:80101323:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:2301:      if((bp->data[bi/8] & m) == 0){  // Is block free?
./kernel.asm:2302:80101337:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:2306:      if((bp->data[bi/8] & m) == 0){  // Is block free?
./kernel.asm:2318:8010135c:	8b 55 e0             	mov    -0x20(%ebp),%edx
./kernel.asm:2327:80101363:	8b 7d d8             	mov    -0x28(%ebp),%edi
./kernel.asm:2329:80101369:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:2344:        bp->data[bi/8] |= m;  // Mark block in use.
./kernel.asm:2345:80101398:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:2348:        bp->data[bi/8] |= m;  // Mark block in use.
./kernel.asm:2361:801013b5:	ff 75 dc             	push   -0x24(%ebp)
./kernel.asm:2363:  memset(bp->data, 0, BSIZE);
./kernel.asm:2367:  memset(bp->data, 0, BSIZE);
./kernel.asm:2380:801013e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2391:// and return the in-memory copy. Does not lock
./kernel.asm:2414:80101402:	89 55 e4             	mov    %edx,-0x1c(%ebp)
./kernel.asm:2419:8010140f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:2426:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
./kernel.asm:2433:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
./kernel.asm:2437:      ip->ref++;
./kernel.asm:2441:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
./kernel.asm:2460:  ip->dev = dev;
./kernel.asm:2461:  ip->inum = inum;
./kernel.asm:2462:  ip->ref = 1;
./kernel.asm:2463:  ip->valid = 0;
./kernel.asm:2466:  ip->dev = dev;
./kernel.asm:2468:  ip->inum = inum;
./kernel.asm:2470:  ip->ref = 1;
./kernel.asm:2472:  ip->valid = 0;
./kernel.asm:2481:8010147f:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2489:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
./kernel.asm:2492:      ip->ref++;
./kernel.asm:2498:      ip->ref++;
./kernel.asm:2506:801014ad:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2517:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
./kernel.asm:2552:  if((bp->data[bi/8] & m) == 0)
./kernel.asm:2560:  if((bp->data[bi/8] & m) == 0)
./kernel.asm:2564:  if((bp->data[bi/8] & m) == 0)
./kernel.asm:2568:  bp->data[bi/8] &= ~m;
./kernel.asm:2572:  bp->data[bi/8] &= ~m;
./kernel.asm:2583:8010154d:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:2616:    if((addr = ip->addrs[bn]) == 0)
./kernel.asm:2617:      ip->addrs[bn] = addr = balloc(ip->dev);
./kernel.asm:2620:  bn -= NDIRECT;
./kernel.asm:2621:80101584:	8d 5a f4             	lea    -0xc(%edx),%ebx
./kernel.asm:2627:    if((addr = ip->addrs[NDIRECT]) == 0)
./kernel.asm:2631:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
./kernel.asm:2632:    bp = bread(ip->dev, addr);
./kernel.asm:2637:    a = (uint*)bp->data;
./kernel.asm:2641:    bp = bread(ip->dev, addr);
./kernel.asm:2647:      a[bn] = addr = balloc(ip->dev);
./kernel.asm:2660:801015c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2668:801015d0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:2669:      a[bn] = addr = balloc(ip->dev);
./kernel.asm:2673:801015da:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:2675:      a[bn] = addr = balloc(ip->dev);
./kernel.asm:2681:801015ea:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:2685:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
./kernel.asm:2693:    if((addr = ip->addrs[bn]) == 0)
./kernel.asm:2698:      ip->addrs[bn] = addr = balloc(ip->dev);
./kernel.asm:2704:80101628:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2729:  memmove(sb, bp->data, sizeof(*sb));
./kernel.asm:2733:  memmove(sb, bp->data, sizeof(*sb));
./kernel.asm:2743:8010166c:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:2784:  memmove(sb, bp->data, sizeof(*sb));
./kernel.asm:2788:  memmove(sb, bp->data, sizeof(*sb));
./kernel.asm:2808:8010171d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:2829:80101746:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:2856:    if(dip->type == 0){  // a free inode
./kernel.asm:2860:    dip = (struct dinode*)bp->data + inum%IPB;
./kernel.asm:2865:    if(dip->type == 0){  // a free inode
./kernel.asm:2873:801017ab:	89 4d e0             	mov    %ecx,-0x20(%ebp)
./kernel.asm:2875:      dip->type = type;
./kernel.asm:2876:801017b3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
./kernel.asm:2877:801017b7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./kernel.asm:2888:801017d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:2914:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./kernel.asm:2916:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
./kernel.asm:2918:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./kernel.asm:2923:8010180b:	ff 73 a4             	push   -0x5c(%ebx)
./kernel.asm:2925:  dip->type = ip->type;
./kernel.asm:2926:80101813:	0f b7 53 f4          	movzwl -0xc(%ebx),%edx
./kernel.asm:2927:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
./kernel.asm:2929:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./kernel.asm:2931:  dip = (struct dinode*)bp->data + ip->inum%IPB;
./kernel.asm:2932:8010181c:	8b 43 a8             	mov    -0x58(%ebx),%eax
./kernel.asm:2936:  dip->type = ip->type;
./kernel.asm:2938:  dip->major = ip->major;
./kernel.asm:2939:8010182c:	0f b7 53 f6          	movzwl -0xa(%ebx),%edx
./kernel.asm:2940:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
./kernel.asm:2942:  dip->major = ip->major;
./kernel.asm:2943:80101833:	66 89 50 f6          	mov    %dx,-0xa(%eax)
./kernel.asm:2944:  dip->minor = ip->minor;
./kernel.asm:2945:80101837:	0f b7 53 f8          	movzwl -0x8(%ebx),%edx
./kernel.asm:2946:8010183b:	66 89 50 f8          	mov    %dx,-0x8(%eax)
./kernel.asm:2947:  dip->nlink = ip->nlink;
./kernel.asm:2948:8010183f:	0f b7 53 fa          	movzwl -0x6(%ebx),%edx
./kernel.asm:2949:80101843:	66 89 50 fa          	mov    %dx,-0x6(%eax)
./kernel.asm:2950:  dip->size = ip->size;
./kernel.asm:2951:80101847:	8b 53 fc             	mov    -0x4(%ebx),%edx
./kernel.asm:2952:8010184a:	89 50 fc             	mov    %edx,-0x4(%eax)
./kernel.asm:2953:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
./kernel.asm:2965:80101864:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:2983:  ip->ref++;
./kernel.asm:2990:80101896:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:3002:  if(ip == 0 || ip->ref < 1)
./kernel.asm:3008:  acquiresleep(&ip->lock);
./kernel.asm:3013:  if(ip->valid == 0){
./kernel.asm:3019:801018d1:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:3026:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./kernel.asm:3034:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
./kernel.asm:3036:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./kernel.asm:3038:    dip = (struct dinode*)bp->data + ip->inum%IPB;
./kernel.asm:3043:    ip->type = dip->type;
./kernel.asm:3045:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
./kernel.asm:3047:    ip->type = dip->type;
./kernel.asm:3049:    ip->major = dip->major;
./kernel.asm:3050:80101913:	0f b7 50 f6          	movzwl -0xa(%eax),%edx
./kernel.asm:3052:    ip->minor = dip->minor;
./kernel.asm:3053:8010191b:	0f b7 50 f8          	movzwl -0x8(%eax),%edx
./kernel.asm:3055:    ip->nlink = dip->nlink;
./kernel.asm:3056:80101923:	0f b7 50 fa          	movzwl -0x6(%eax),%edx
./kernel.asm:3058:    ip->size = dip->size;
./kernel.asm:3059:8010192b:	8b 50 fc             	mov    -0x4(%eax),%edx
./kernel.asm:3061:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
./kernel.asm:3070:    if(ip->type == 0)
./kernel.asm:3073:    ip->valid = 1;
./kernel.asm:3075:    if(ip->type == 0)
./kernel.asm:3096:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
./kernel.asm:3109:  releasesleep(&ip->lock);
./kernel.asm:3112:801019a9:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:3116:  releasesleep(&ip->lock);
./kernel.asm:3135:  acquiresleep(&ip->lock);
./kernel.asm:3139:  if(ip->valid && ip->nlink == 0){
./kernel.asm:3146:  releasesleep(&ip->lock);
./kernel.asm:3153:  ip->ref--;
./kernel.asm:3159:80101a19:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3171:    int r = ip->ref;
./kernel.asm:3181:80101a52:	89 7d e4             	mov    %edi,-0x1c(%ebp)
./kernel.asm:3196:    if(ip->addrs[i]){
./kernel.asm:3200:      bfree(ip->dev, ip->addrs[i]);
./kernel.asm:3203:      ip->addrs[i] = 0;
./kernel.asm:3210:  if(ip->addrs[NDIRECT]){
./kernel.asm:3212:80101a82:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:3216:    bfree(ip->dev, ip->addrs[NDIRECT]);
./kernel.asm:3217:    ip->addrs[NDIRECT] = 0;
./kernel.asm:3220:  ip->size = 0;
./kernel.asm:3223:  ip->size = 0;
./kernel.asm:3228:      ip->type = 0;
./kernel.asm:3234:      ip->valid = 0;
./kernel.asm:3238:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
./kernel.asm:3245:80101aca:	89 7d e4             	mov    %edi,-0x1c(%ebp)
./kernel.asm:3247:80101ad3:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:3259:        bfree(ip->dev, a[j]);
./kernel.asm:3264:80101af6:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:3266:80101afc:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:3269:    bfree(ip->dev, ip->addrs[NDIRECT]);
./kernel.asm:3273:    ip->addrs[NDIRECT] = 0;
./kernel.asm:3289:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
./kernel.asm:3302:  releasesleep(&ip->lock);
./kernel.asm:3310:80101b65:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:3325:// Caller must hold ip->lock.
./kernel.asm:3333:  st->dev = ip->dev;
./kernel.asm:3336:  st->ino = ip->inum;
./kernel.asm:3339:  st->type = ip->type;
./kernel.asm:3342:  st->nlink = ip->nlink;
./kernel.asm:3345:  st->size = ip->size;
./kernel.asm:3356:// Caller must hold ip->lock.
./kernel.asm:3372:  if(ip->type == T_DEV){
./kernel.asm:3375:80101bc7:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:3376:80101bca:	89 75 d8             	mov    %esi,-0x28(%ebp)
./kernel.asm:3378:  if(ip->type == T_DEV){
./kernel.asm:3380:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
./kernel.asm:3381:      return -1;
./kernel.asm:3382:    return devsw[ip->major].read(ip, dst, n);
./kernel.asm:3385:  if(off > ip->size || off + n < off)
./kernel.asm:3386:80101bd6:	8b 75 d8             	mov    -0x28(%ebp),%esi
./kernel.asm:3394:80101bed:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
./kernel.asm:3396:    return -1;
./kernel.asm:3397:  if(off + n > ip->size)
./kernel.asm:3398:    n = ip->size - off;
./kernel.asm:3407:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./kernel.asm:3408:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3409:80101c03:	8b 75 e4             	mov    -0x1c(%ebp),%esi
./kernel.asm:3410:80101c06:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:3412:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./kernel.asm:3413:80101c10:	8b 5d d8             	mov    -0x28(%ebp),%ebx
./kernel.asm:3422:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3423:80101c2a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
./kernel.asm:3425:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./kernel.asm:3427:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3432:    memmove(dst, bp->data + off%BSIZE, m);
./kernel.asm:3434:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3437:    memmove(dst, bp->data + off%BSIZE, m);
./kernel.asm:3443:    memmove(dst, bp->data + off%BSIZE, m);
./kernel.asm:3444:80101c50:	89 55 dc             	mov    %edx,-0x24(%ebp)
./kernel.asm:3446:80101c54:	ff 75 e0             	push   -0x20(%ebp)
./kernel.asm:3449:80101c5c:	8b 55 dc             	mov    -0x24(%ebp),%edx
./kernel.asm:3453:80101c67:	01 5d e0             	add    %ebx,-0x20(%ebp)
./kernel.asm:3454:80101c6a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
./kernel.asm:3462:80101c76:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3469:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
./kernel.asm:3473:80101c8a:	8b 14 d5 20 09 11 80 	mov    -0x7feef6e0(,%edx,8),%edx
./kernel.asm:3476:    return devsw[ip->major].read(ip, dst, n);
./kernel.asm:3479:80101c98:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3484:    return devsw[ip->major].read(ip, dst, n);
./kernel.asm:3486:      return -1;
./kernel.asm:3495:// Caller must hold ip->lock.
./kernel.asm:3511:  if(ip->type == T_DEV){
./kernel.asm:3514:80101cc7:	89 7d dc             	mov    %edi,-0x24(%ebp)
./kernel.asm:3515:80101cca:	89 75 e0             	mov    %esi,-0x20(%ebp)
./kernel.asm:3517:  if(ip->type == T_DEV){
./kernel.asm:3519:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
./kernel.asm:3520:      return -1;
./kernel.asm:3521:    return devsw[ip->major].write(ip, src, n);
./kernel.asm:3524:  if(off > ip->size || off + n < off)
./kernel.asm:3527:    return -1;
./kernel.asm:3529:80101cdf:	8b 75 e0             	mov    -0x20(%ebp),%esi
./kernel.asm:3535:    return -1;
./kernel.asm:3540:80101d00:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
./kernel.asm:3541:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./kernel.asm:3542:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3543:80101d07:	89 45 d8             	mov    %eax,-0x28(%ebp)
./kernel.asm:3545:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./kernel.asm:3546:80101d10:	8b 75 d8             	mov    -0x28(%ebp),%esi
./kernel.asm:3555:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3556:80101d2a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:3557:80101d2d:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./kernel.asm:3559:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./kernel.asm:3561:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3566:    memmove(bp->data + off%BSIZE, src, m);
./kernel.asm:3568:    m = min(n - tot, BSIZE - off%BSIZE);
./kernel.asm:3571:    memmove(bp->data + off%BSIZE, src, m);
./kernel.asm:3576:    memmove(bp->data + off%BSIZE, src, m);
./kernel.asm:3577:80101d51:	ff 75 dc             	push   -0x24(%ebp)
./kernel.asm:3587:80101d6a:	01 5d e4             	add    %ebx,-0x1c(%ebp)
./kernel.asm:3588:80101d6d:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:3590:80101d73:	01 5d dc             	add    %ebx,-0x24(%ebp)
./kernel.asm:3591:80101d76:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./kernel.asm:3596:  if(n > 0 && off > ip->size){
./kernel.asm:3597:80101d7d:	8b 45 d8             	mov    -0x28(%ebp),%eax
./kernel.asm:3600:    ip->size = off;
./kernel.asm:3604:80101d85:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:3606:80101d88:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3612:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
./kernel.asm:3616:80101d9a:	8b 04 c5 24 09 11 80 	mov    -0x7feef6dc(,%eax,8),%eax
./kernel.asm:3619:    return devsw[ip->major].write(ip, src, n);
./kernel.asm:3622:80101da8:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3627:    return devsw[ip->major].write(ip, src, n);
./kernel.asm:3632:    ip->size = off;
./kernel.asm:3639:      return -1;
./kernel.asm:3682:  if(dp->type != T_DIR)
./kernel.asm:3687:  for(off = 0; off < dp->size; off += sizeof(de)){
./kernel.asm:3690:80101e0c:	8d 75 d8             	lea    -0x28(%ebp),%esi
./kernel.asm:3705:80101e2a:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
./kernel.asm:3709:80101e34:	8d 45 da             	lea    -0x26(%ebp),%eax
./kernel.asm:3719:  for(off = 0; off < dp->size; off += sizeof(de)){
./kernel.asm:3723:      return iget(dp->dev, inum);
./kernel.asm:3729:80101e51:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3747:80101e6c:	0f b7 55 d8          	movzwl -0x28(%ebp),%edx
./kernel.asm:3748:      return iget(dp->dev, inum);
./kernel.asm:3752:80101e77:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3787:80101eae:	89 55 dc             	mov    %edx,-0x24(%ebp)
./kernel.asm:3788:80101eb1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
./kernel.asm:3793:    ip = idup(myproc()->cwd);
./kernel.asm:3797:    ip = idup(myproc()->cwd);
./kernel.asm:3802:  ip->ref++;
./kernel.asm:3835:  len = path - s;
./kernel.asm:3846:80101f34:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:3864:    if(ip->type != T_DIR){
./kernel.asm:3872:80101f67:	8b 45 dc             	mov    -0x24(%ebp),%eax
./kernel.asm:3884:80101f7c:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:3891:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
./kernel.asm:3895:80101f99:	89 4d e0             	mov    %ecx,-0x20(%ebp)
./kernel.asm:3903:  releasesleep(&ip->lock);
./kernel.asm:3904:80101fb7:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./kernel.asm:3923:80101fd8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:3927:80101fe1:	89 4d e0             	mov    %ecx,-0x20(%ebp)
./kernel.asm:3933:80101fe8:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:3936:80101ff0:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./kernel.asm:3943:80102000:	8b 45 dc             	mov    -0x24(%ebp),%eax
./kernel.asm:3951:8010200b:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:3959:80102015:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
./kernel.asm:3963:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
./kernel.asm:3974:  releasesleep(&ip->lock);
./kernel.asm:3987:8010204e:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:4000:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
./kernel.asm:4011:  releasesleep(&ip->lock);
./kernel.asm:4018:80102094:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:4058:  for(off = 0; off < dp->size; off += sizeof(de)){
./kernel.asm:4060:801020e1:	8d 75 d8             	lea    -0x28(%ebp),%esi
./kernel.asm:4064:801020ea:	8d 75 d8             	lea    -0x28(%ebp),%esi
./kernel.asm:4080:8010210a:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
./kernel.asm:4084:80102114:	8d 45 da             	lea    -0x26(%ebp),%eax
./kernel.asm:4091:80102125:	66 89 45 d8          	mov    %ax,-0x28(%ebp)
./kernel.asm:4104:8010213d:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:4114:    return -1;
./kernel.asm:4144:8010218b:	8d 4d ea             	lea    -0x16(%ebp),%ecx
./kernel.asm:4194:  if(b->blockno >= FSSIZE)
./kernel.asm:4235:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
./kernel.asm:4242:  if(b->flags & B_DIRTY){
./kernel.asm:4249:    outsl(0x1f0, b->data, BSIZE/4);
./kernel.asm:4254:8010224a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:4266:    outsl(0x1f0, b->data, BSIZE/4);
./kernel.asm:4272:80102270:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:4299:  ioapicenable(IRQ_IDE, ncpu - 1);
./kernel.asm:4380:  idequeue = b->qnext;
./kernel.asm:4385:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
./kernel.asm:4403:    insl(0x1f0, b->data, BSIZE/4);
./kernel.asm:4412:  b->flags |= B_VALID;
./kernel.asm:4414:  b->flags &= ~B_DIRTY;
./kernel.asm:4418:  b->flags &= ~B_DIRTY;
./kernel.asm:4440:801023c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:4463:  if(!holdingsleep(&b->lock))
./kernel.asm:4471:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
./kernel.asm:4477:  if(b->dev != 0 && !havedisk1)
./kernel.asm:4486:  acquire(&idelock);  //DOC:acquire-lock
./kernel.asm:4492:  b->qnext = 0;
./kernel.asm:4493:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
./kernel.asm:4495:  b->qnext = 0;
./kernel.asm:4497:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
./kernel.asm:4517:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
./kernel.asm:4527:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
./kernel.asm:4539:80102472:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:4549:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
./kernel.asm:4567:  ioapic->data = data;
./kernel.asm:4582:  ioapic->reg = reg;
./kernel.asm:4585:  return ioapic->data;
./kernel.asm:4588:  ioapic->reg = reg;
./kernel.asm:4590:  return ioapic->data;
./kernel.asm:4600:  return ioapic->data;
./kernel.asm:4611:  ioapic->reg = reg;
./kernel.asm:4618:  ioapic->reg = reg;
./kernel.asm:4621:  ioapic->data = data;
./kernel.asm:4624:  // Mark all interrupts edge-triggered, active high, disabled,
./kernel.asm:4629:  ioapic->data = data;
./kernel.asm:4631:  ioapic->reg = reg;
./kernel.asm:4635:  ioapic->reg = reg;
./kernel.asm:4637:  ioapic->data = data;
./kernel.asm:4647:80102558:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:4660:  ioapic->reg = reg;
./kernel.asm:4665:  // Mark interrupt edge-triggered, active high,
./kernel.asm:4671:  ioapic->reg = reg;
./kernel.asm:4673:  ioapic->data = data;
./kernel.asm:4677:  ioapic->data = data;
./kernel.asm:4681:  ioapic->reg = reg;
./kernel.asm:4683:  ioapic->data = data;
./kernel.asm:4687:  ioapic->data = data;
./kernel.asm:4719:801025c2:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
./kernel.asm:4739:  r->next = kmem.freelist;
./kernel.asm:4756:    kmem.free_pages--;
./kernel.asm:4760:80102613:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:4806:8010268b:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
./kernel.asm:4817:801026a4:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:4859:80102703:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
./kernel.asm:4874:8010272b:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:4910:8010277b:	8d 83 00 f0 ff ff    	lea    -0x1000(%ebx),%eax
./kernel.asm:4937:    r = r->next;
./kernel.asm:4949:801027da:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:4981:    kmem.freelist = r->next;
./kernel.asm:4985:    kmem.freelist = r->next;
./kernel.asm:4995:    kmem.free_pages--;
./kernel.asm:4999:    kmem.free_pages--;
./kernel.asm:5008:  // Still no memory available - panic
./kernel.asm:5014:8010283d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:5065:    kmem.freelist = r->next;
./kernel.asm:5107:    return -1;
./kernel.asm:5142:8010294b:	0f b6 91 00 88 10 80 	movzbl -0x7fef7800(%ecx),%edx
./kernel.asm:5144:80102952:	0f b6 81 00 87 10 80 	movzbl -0x7fef7900(%ecx),%eax
./kernel.asm:5158:8010296b:	8b 04 85 e0 86 10 80 	mov    -0x7fef7920(,%eax,4),%eax
./kernel.asm:5163:80102978:	8d 50 9f             	lea    -0x61(%eax),%edx
./kernel.asm:5166:      c += 'A' - 'a';
./kernel.asm:5169:      c += 'a' - 'A';
./kernel.asm:5173:80102983:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:5185:8010299b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:5193:801029a8:	0f b6 81 00 88 10 80 	movzbl -0x7fef7800(%ecx),%eax
./kernel.asm:5204:801029c8:	8d 48 bf             	lea    -0x41(%eax),%ecx
./kernel.asm:5205:      c += 'a' - 'A';
./kernel.asm:5208:801029ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:5210:      c += 'a' - 'A';
./kernel.asm:5216:    return -1;
./kernel.asm:5327:  // Send an Init Level De-Assert to synchronise arbitration ID's.
./kernel.asm:5493:80102bda:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:5501:// qemu seems to use 24-hour GWT and the values are BCD encoded
./kernel.asm:5526:80102c02:	88 45 b3             	mov    %al,-0x4d(%ebp)
./kernel.asm:5535:80102c15:	88 45 b7             	mov    %al,-0x49(%ebp)
./kernel.asm:5543:80102c23:	88 45 b6             	mov    %al,-0x4a(%ebp)
./kernel.asm:5551:80102c31:	88 45 b5             	mov    %al,-0x4b(%ebp)
./kernel.asm:5559:80102c3f:	88 45 b4             	mov    %al,-0x4c(%ebp)
./kernel.asm:5591:80102c6c:	0f b6 45 b7          	movzbl -0x49(%ebp),%eax
./kernel.asm:5593:80102c72:	89 5d cc             	mov    %ebx,-0x34(%ebp)
./kernel.asm:5597:80102c7a:	89 45 b8             	mov    %eax,-0x48(%ebp)
./kernel.asm:5598:80102c7d:	0f b6 45 b6          	movzbl -0x4a(%ebp),%eax
./kernel.asm:5599:80102c81:	89 75 c8             	mov    %esi,-0x38(%ebp)
./kernel.asm:5600:80102c84:	89 45 bc             	mov    %eax,-0x44(%ebp)
./kernel.asm:5601:80102c87:	0f b6 45 b5          	movzbl -0x4b(%ebp),%eax
./kernel.asm:5602:80102c8b:	89 45 c0             	mov    %eax,-0x40(%ebp)
./kernel.asm:5603:80102c8e:	0f b6 45 b4          	movzbl -0x4c(%ebp),%eax
./kernel.asm:5604:80102c92:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./kernel.asm:5613:80102ca0:	89 45 d0             	mov    %eax,-0x30(%ebp)
./kernel.asm:5622:80102cb1:	89 45 d4             	mov    %eax,-0x2c(%ebp)
./kernel.asm:5631:80102cc2:	89 45 d8             	mov    %eax,-0x28(%ebp)
./kernel.asm:5640:80102cd3:	89 45 dc             	mov    %eax,-0x24(%ebp)
./kernel.asm:5649:80102ce4:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:5661:80102cf6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:5663:80102cf9:	8d 45 d0             	lea    -0x30(%ebp),%eax
./kernel.asm:5666:80102cff:	8d 45 b8             	lea    -0x48(%ebp),%eax
./kernel.asm:5677:80102d13:	0f b6 75 b3          	movzbl -0x4d(%ebp),%esi
./kernel.asm:5684:80102d20:	8b 45 b8             	mov    -0x48(%ebp),%eax
./kernel.asm:5690:80102d31:	89 45 b8             	mov    %eax,-0x48(%ebp)
./kernel.asm:5692:80102d34:	8b 45 bc             	mov    -0x44(%ebp),%eax
./kernel.asm:5698:80102d45:	89 45 bc             	mov    %eax,-0x44(%ebp)
./kernel.asm:5700:80102d48:	8b 45 c0             	mov    -0x40(%ebp),%eax
./kernel.asm:5706:80102d59:	89 45 c0             	mov    %eax,-0x40(%ebp)
./kernel.asm:5708:80102d5c:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./kernel.asm:5714:80102d6d:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./kernel.asm:5716:80102d70:	8b 45 c8             	mov    -0x38(%ebp),%eax
./kernel.asm:5722:80102d81:	89 45 c8             	mov    %eax,-0x38(%ebp)
./kernel.asm:5724:80102d84:	8b 45 cc             	mov    -0x34(%ebp),%eax
./kernel.asm:5730:80102d95:	89 45 cc             	mov    %eax,-0x34(%ebp)
./kernel.asm:5735:80102d98:	8b 45 b8             	mov    -0x48(%ebp),%eax
./kernel.asm:5737:80102d9d:	8b 45 bc             	mov    -0x44(%ebp),%eax
./kernel.asm:5739:80102da3:	8b 45 c0             	mov    -0x40(%ebp),%eax
./kernel.asm:5741:80102da9:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./kernel.asm:5743:80102daf:	8b 45 c8             	mov    -0x38(%ebp),%eax
./kernel.asm:5745:80102db5:	8b 45 cc             	mov    -0x34(%ebp),%eax
./kernel.asm:5747:  r->year += 2000;
./kernel.asm:5750:80102dc2:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:5793:80102e0d:	ff 34 bd 0c 27 11 80 	push   -0x7feed8f4(,%edi,4)
./kernel.asm:5799:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
./kernel.asm:5803:    memmove(dbuf->data, lbuf->data, BSIZE);  // copy block to dst
./kernel.asm:5825:80102e5c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:5836:// Write in-memory log header to disk.
./kernel.asm:5850:  struct logheader *hb = (struct logheader *) (buf->data);
./kernel.asm:5852:  hb->n = log.lh.n;
./kernel.asm:5857:  hb->n = log.lh.n;
./kernel.asm:5865:    hb->block[i] = log.lh.block[i];
./kernel.asm:5866:80102ea0:	8b 0c 95 0c 27 11 80 	mov    -0x7feed8f4(,%edx,4),%ecx
./kernel.asm:5881:80102ec3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:5900:80102eea:	8d 45 dc             	lea    -0x24(%ebp),%eax
./kernel.asm:5906:80102ef5:	8b 45 ec             	mov    -0x14(%ebp),%eax
./kernel.asm:5912:80102eff:	8b 55 e8             	mov    -0x18(%ebp),%edx
./kernel.asm:5924:  log.lh.n = lh->n;
./kernel.asm:5934:    log.lh.block[i] = lh->block[i];
./kernel.asm:5936:80102f34:	89 0c 95 0c 27 11 80 	mov    %ecx,-0x7feed8f4(,%edx,4)
./kernel.asm:5958:80102f5f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:6042:  log.outstanding -= 1;
./kernel.asm:6047:  log.outstanding -= 1;
./kernel.asm:6048:80103001:	8d 58 ff             	lea    -0x1(%eax),%ebx
./kernel.asm:6095:80103070:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:6115:8010309d:	ff 34 9d 0c 27 11 80 	push   -0x7feed8f4(,%ebx,4)
./kernel.asm:6121:    memmove(to->data, from->data, BSIZE);
./kernel.asm:6125:    memmove(to->data, from->data, BSIZE);
./kernel.asm:6146:    write_head();    // Write header to disk -- the real commit
./kernel.asm:6166:8010312c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:6181://   modify bp->data[]
./kernel.asm:6193:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
./kernel.asm:6197:  if (log.lh.n >= LOGSIZE || log.lh.n >= log.size - 1)
./kernel.asm:6212:  if (b->blockno >= 2 && b->blockno < 2 + NSWAPBLOCKS) {
./kernel.asm:6217:  log.lh.block[i] = b->blockno;
./kernel.asm:6220:  b->flags |= B_DIRTY; // prevent eviction
./kernel.asm:6223:80103193:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:6232:    if (log.lh.block[i] == b->blockno)   // log absorbtion
./kernel.asm:6245:    if (log.lh.block[i] == b->blockno)   // log absorbtion
./kernel.asm:6246:801031cf:	39 0c 85 0c 27 11 80 	cmp    %ecx,-0x7feed8f4(,%eax,4)
./kernel.asm:6248:  log.lh.block[i] = b->blockno;
./kernel.asm:6249:801031d8:	89 0c 85 0c 27 11 80 	mov    %ecx,-0x7feed8f4(,%eax,4)
./kernel.asm:6253:  b->flags |= B_DIRTY; // prevent eviction
./kernel.asm:6256:801031e6:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:6266:  log.lh.block[i] = b->blockno;
./kernel.asm:6267:80103200:	89 0c 95 0c 27 11 80 	mov    %ecx,-0x7feed8f4(,%edx,4)
./kernel.asm:6305:  xchg(&(mycpu()->started), 1); // tell startothers() we're up
./kernel.asm:6312:  // The + in "+m" denotes a read-modify-write operand.
./kernel.asm:6341:80103297:	ff 71 fc             	push   -0x4(%ecx)
./kernel.asm:6416:    *(void**)(code-4) = stack + KSTACKSIZE;
./kernel.asm:6417:    *(void(**)(void))(code-8) = mpenter;
./kernel.asm:6418:    *(int**)(code-12) = (void *) V2P(entrypgdir);
./kernel.asm:6420:    lapicstartap(c->apicid, V2P(code));
./kernel.asm:6422:    *(void(**)(void))(code-8) = mpenter;
./kernel.asm:6425:    *(int**)(code-12) = (void *) V2P(entrypgdir);
./kernel.asm:6428:    *(void**)(code-4) = stack + KSTACKSIZE;
./kernel.asm:6431:    lapicstartap(c->apicid, V2P(code));
./kernel.asm:6438:    while(c->started == 0)
./kernel.asm:6480:801033d5:	8d b0 00 00 00 80    	lea    -0x80000000(%eax),%esi
./kernel.asm:6525:80103428:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:6533:80103438:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:6573:    if((mp = mpsearch1(p-1024, 1024)))
./kernel.asm:6581:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
./kernel.asm:6587:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
./kernel.asm:6588:801034ae:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
./kernel.asm:6589:801034b4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:6598:  if(conf->version != 1 && conf->version != 4)
./kernel.asm:6599:801034cf:	0f b6 83 06 00 00 80 	movzbl -0x7ffffffa(%ebx),%eax
./kernel.asm:6604:  if(sum((uchar*)conf, conf->length) != 0)
./kernel.asm:6605:801034e2:	0f b7 8b 04 00 00 80 	movzwl -0x7ffffffc(%ebx),%ecx
./kernel.asm:6610:801034f2:	89 5d dc             	mov    %ebx,-0x24(%ebp)
./kernel.asm:6614:801034fc:	89 7d e0             	mov    %edi,-0x20(%ebp)
./kernel.asm:6618:80103508:	0f b6 98 00 00 00 80 	movzbl -0x80000000(%eax),%ebx
./kernel.asm:6626:  if(sum((uchar*)conf, conf->length) != 0)
./kernel.asm:6627:80103518:	8b 5d dc             	mov    -0x24(%ebp),%ebx
./kernel.asm:6635:  if(conf->length <= 0 || conf->length > 1024) // Validate conf->length
./kernel.asm:6641:  lapic = (uint*)conf->lapicaddr;
./kernel.asm:6642:80103531:	8b 83 24 00 00 80    	mov    -0x7fffffdc(%ebx),%eax
./kernel.asm:6643:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
./kernel.asm:6644:80103537:	8b 7d e0             	mov    -0x20(%ebp),%edi
./kernel.asm:6646:  lapic = (uint*)conf->lapicaddr;
./kernel.asm:6648:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
./kernel.asm:6649:80103545:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:6654:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
./kernel.asm:6671:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
./kernel.asm:6684:  if(mp->imcrp){
./kernel.asm:6703:80103590:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:6716:      ioapicid = ioapic->apicno;
./kernel.asm:6720:      ioapicid = ioapic->apicno;
./kernel.asm:6729:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
./kernel.asm:6731:801035d1:	89 55 e4             	mov    %edx,-0x1c(%ebp)
./kernel.asm:6733:801035d8:	88 91 c0 27 11 80    	mov    %dl,-0x7feed840(%ecx)
./kernel.asm:6735:801035de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:6853:  p->readopen = 1;
./kernel.asm:6856:  p->writeopen = 1;
./kernel.asm:6857:  p->nwrite = 0;
./kernel.asm:6858:  p->nread = 0;
./kernel.asm:6859:  initlock(&p->lock, "pipe");
./kernel.asm:6861:  p->writeopen = 1;
./kernel.asm:6864:  p->nwrite = 0;
./kernel.asm:6867:  p->nread = 0;
./kernel.asm:6870:  initlock(&p->lock, "pipe");
./kernel.asm:6874:  (*f0)->type = FD_PIPE;
./kernel.asm:6876:  (*f0)->pipe = p;
./kernel.asm:6877:  (*f1)->type = FD_PIPE;
./kernel.asm:6878:  (*f1)->readable = 0;
./kernel.asm:6879:  (*f1)->writable = 1;
./kernel.asm:6880:  (*f1)->pipe = p;
./kernel.asm:6883:  (*f0)->type = FD_PIPE;
./kernel.asm:6885:  (*f0)->readable = 1;
./kernel.asm:6888:  (*f0)->writable = 0;
./kernel.asm:6891:  (*f0)->pipe = p;
./kernel.asm:6894:  (*f1)->type = FD_PIPE;
./kernel.asm:6897:  (*f1)->readable = 0;
./kernel.asm:6900:  (*f1)->writable = 1;
./kernel.asm:6903:  (*f1)->pipe = p;
./kernel.asm:6912:  return -1;
./kernel.asm:6914:80103755:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:6938:  return -1;
./kernel.asm:6958:  acquire(&p->lock);
./kernel.asm:6966:    p->writeopen = 0;
./kernel.asm:6967:    wakeup(&p->nread);
./kernel.asm:6970:    p->writeopen = 0;
./kernel.asm:6973:    wakeup(&p->nread);
./kernel.asm:6978:    p->readopen = 0;
./kernel.asm:6979:    wakeup(&p->nwrite);
./kernel.asm:6981:  if(p->readopen == 0 && p->writeopen == 0){
./kernel.asm:6988:    release(&p->lock);
./kernel.asm:6991:    release(&p->lock);
./kernel.asm:6994:801037de:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:6998:    release(&p->lock);
./kernel.asm:7001:    release(&p->lock);
./kernel.asm:7009:801037ff:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:7016:    wakeup(&p->nwrite);
./kernel.asm:7019:    p->readopen = 0;
./kernel.asm:7022:    wakeup(&p->nwrite);
./kernel.asm:7045:  acquire(&p->lock);
./kernel.asm:7052:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
./kernel.asm:7056:8010385c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:7058:80103862:	89 75 e0             	mov    %esi,-0x20(%ebp)
./kernel.asm:7059:      if(p->readopen == 0 || myproc()->killed){
./kernel.asm:7060:        release(&p->lock);
./kernel.asm:7061:        return -1;
./kernel.asm:7063:      wakeup(&p->nread);
./kernel.asm:7065:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
./kernel.asm:7067:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
./kernel.asm:7069:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
./kernel.asm:7071:8010387d:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
./kernel.asm:7073:80103886:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
./kernel.asm:7076:      if(p->readopen == 0 || myproc()->killed){
./kernel.asm:7081:      wakeup(&p->nread);
./kernel.asm:7085:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
./kernel.asm:7091:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
./kernel.asm:7098:      if(p->readopen == 0 || myproc()->killed){
./kernel.asm:7102:        release(&p->lock);
./kernel.asm:7106:        return -1;
./kernel.asm:7109:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
./kernel.asm:7111:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
./kernel.asm:7112:  release(&p->lock);
./kernel.asm:7115:801038e1:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:7122:801038f0:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
./kernel.asm:7123:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
./kernel.asm:7128:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
./kernel.asm:7130:80103905:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:7131:80103908:	0f b6 41 ff          	movzbl -0x1(%ecx),%eax
./kernel.asm:7134:80103910:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:7138:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
./kernel.asm:7143:  release(&p->lock);
./kernel.asm:7150:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
./kernel.asm:7151:8010393c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:7172:  acquire(&p->lock);
./kernel.asm:7176:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
./kernel.asm:7183:    if(myproc()->killed){
./kernel.asm:7188:      release(&p->lock);
./kernel.asm:7189:      return -1;
./kernel.asm:7191:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
./kernel.asm:7196:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
./kernel.asm:7205:  for(i = 0; i < n; i++){  //DOC: piperead-copy
./kernel.asm:7211:    if(p->nread == p->nwrite)
./kernel.asm:7213:    addr[i] = p->data[p->nread++ % PIPESIZE];
./kernel.asm:7219:  for(i = 0; i < n; i++){  //DOC: piperead-copy
./kernel.asm:7224:    if(p->nread == p->nwrite)
./kernel.asm:7228:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
./kernel.asm:7233:  release(&p->lock);
./kernel.asm:7239:80103a06:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:7246:      release(&p->lock);
./kernel.asm:7248:      return -1;
./kernel.asm:7250:      release(&p->lock);
./kernel.asm:7253:      return -1;
./kernel.asm:7256:80103a21:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:7296:    if(p->state == UNUSED)
./kernel.asm:7304:  p->state = EMBRYO;
./kernel.asm:7305:  p->pid = nextpid++;
./kernel.asm:7307:  p->ctrl_i_pending = 0;
./kernel.asm:7311:  p->state = EMBRYO;
./kernel.asm:7313:  p->ctrl_i_pending = 0;
./kernel.asm:7316:  p->pid = nextpid++;
./kernel.asm:7321:  p->pid = nextpid++;
./kernel.asm:7327:  if((p->kstack = kalloc()) == 0){
./kernel.asm:7335:  sp = p->kstack + KSTACKSIZE;
./kernel.asm:7338:  sp -= sizeof *p->tf;
./kernel.asm:7340:  sp -= 4;
./kernel.asm:7343:  sp -= sizeof *p->context;
./kernel.asm:7344:  p->context = (struct context*)sp;
./kernel.asm:7345:  memset(p->context, 0, sizeof *p->context);
./kernel.asm:7347:  sp -= sizeof *p->context;
./kernel.asm:7349:  sp -= sizeof *p->tf;
./kernel.asm:7353:  p->context = (struct context*)sp;
./kernel.asm:7355:  memset(p->context, 0, sizeof *p->context);
./kernel.asm:7360:  p->context->eip = (uint)forkret;
./kernel.asm:7365:  p->context->eip = (uint)forkret;
./kernel.asm:7369:80103adb:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:7383:80103af4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:7386:    p->state = UNUSED;
./kernel.asm:7484:80103bad:	0f b6 99 c0 27 11 80 	movzbl -0x7feed840(%ecx),%ebx
./kernel.asm:7488:80103bb8:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:7490:80103bbb:	8d 81 c0 27 11 80    	lea    -0x7feed840(%ecx),%eax
./kernel.asm:7511:  return mycpu()-cpus;
./kernel.asm:7515:  return mycpu()-cpus;
./kernel.asm:7533:  p = c->proc;
./kernel.asm:7539:80103c1e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:7557:  if((p->pgdir = setupkvm()) == 0)
./kernel.asm:7562:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
./kernel.asm:7568:  memset(p->tf, 0, sizeof(*p->tf));
./kernel.asm:7570:  p->sz = PGSIZE;
./kernel.asm:7572:  memset(p->tf, 0, sizeof(*p->tf));
./kernel.asm:7577:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
./kernel.asm:7580:  safestrcpy(p->name, "initcode", sizeof(p->name));
./kernel.asm:7582:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
./kernel.asm:7584:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
./kernel.asm:7586:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
./kernel.asm:7589:  p->tf->es = p->tf->ds;
./kernel.asm:7593:  p->tf->ss = p->tf->ds;
./kernel.asm:7597:  p->tf->eflags = FL_IF;
./kernel.asm:7600:  p->tf->esp = PGSIZE;
./kernel.asm:7603:  p->tf->eip = 0;  // beginning of initcode.S
./kernel.asm:7606:  safestrcpy(p->name, "initcode", sizeof(p->name));
./kernel.asm:7612:  p->cwd = namei("/");
./kernel.asm:7619:  p->state = RUNNABLE;
./kernel.asm:7625:80103d08:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:7646:  p = c->proc;
./kernel.asm:7650:  sz = curproc->sz;
./kernel.asm:7659:  curproc->sz = sz;
./kernel.asm:7668:80103d55:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:7674:    if((sz = allocuvm(curproc->pgdir, sz, sz + n,curproc)) == 0)
./kernel.asm:7684:      return -1;
./kernel.asm:7688:    if((sz = deallocuvm(curproc->pgdir, sz, sz + n,curproc)) == 0)
./kernel.asm:7715:  p = c->proc;
./kernel.asm:7721:80103dc3:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:7724:  np->rss = 0; // Initialize child RSS to 0
./kernel.asm:7727:  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz , np)) == 0){
./kernel.asm:7738:  np->sz = curproc->sz;
./kernel.asm:7740:80103df8:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
./kernel.asm:7742:  *np->tf = *curproc->tf;
./kernel.asm:7744:  np->parent = curproc;
./kernel.asm:7747:  *np->tf = *curproc->tf;
./kernel.asm:7753:  np->tf->eax = 0;
./kernel.asm:7758:    if(curproc->ofile[i])
./kernel.asm:7762:      np->ofile[i] = filedup(curproc->ofile[i]);
./kernel.asm:7766:80103e31:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:7773:  np->cwd = idup(curproc->cwd);
./kernel.asm:7776:  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
./kernel.asm:7778:  np->cwd = idup(curproc->cwd);
./kernel.asm:7780:80103e51:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:7781:  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
./kernel.asm:7783:  np->cwd = idup(curproc->cwd);
./kernel.asm:7785:  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
./kernel.asm:7791:  pid = np->pid;
./kernel.asm:7796:  np->state = RUNNABLE;
./kernel.asm:7804:80103e8b:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:7811:    kfree(np->kstack);
./kernel.asm:7812:80103e95:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
./kernel.asm:7816:    np->kstack = 0;
./kernel.asm:7818:    return -1;
./kernel.asm:7820:    np->state = UNUSED;
./kernel.asm:7822:    return -1;
./kernel.asm:7837:  c->proc = 0;
./kernel.asm:7842:  c->proc = 0;
./kernel.asm:7858:      if(p->state != RUNNABLE)
./kernel.asm:7863:      c->proc = p;
./kernel.asm:7868:      swtch(&(c->scheduler), p->context);
./kernel.asm:7873:      p->state = RUNNING;
./kernel.asm:7875:      swtch(&(c->scheduler), p->context);
./kernel.asm:7879:      c->proc = 0;
./kernel.asm:7906:  p = c->proc;
./kernel.asm:7917:  if(mycpu()->ncli != 1)
./kernel.asm:7921:  if(p->state == RUNNING)
./kernel.asm:7930:  intena = mycpu()->intena;
./kernel.asm:7932:  swtch(&p->context, mycpu()->scheduler);
./kernel.asm:7934:  intena = mycpu()->intena;
./kernel.asm:7936:  swtch(&p->context, mycpu()->scheduler);
./kernel.asm:7942:  mycpu()->intena = intena;
./kernel.asm:7946:  mycpu()->intena = intena;
./kernel.asm:7949:80103fd6:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:7991:    if(curproc->ofile[fd]){
./kernel.asm:7995:      fileclose(curproc->ofile[fd]);
./kernel.asm:7999:      curproc->ofile[fd] = 0;
./kernel.asm:8008:  iput(curproc->cwd);
./kernel.asm:8014:  if(curproc->pgdir) {
./kernel.asm:8016:  curproc->cwd = 0;
./kernel.asm:8018:  if(curproc->pgdir) {
./kernel.asm:8022:    deallocuvm(curproc->pgdir, 0, curproc->sz, curproc);
./kernel.asm:8028:    for(a = 0; a < curproc->sz; a += PGSIZE) {
./kernel.asm:8038:      pte_t *pte = walkpgdir(curproc->pgdir, (void*)a, 0);
./kernel.asm:8046:      pte_t *pte = walkpgdir(curproc->pgdir, (void*)a, 0);
./kernel.asm:8058:    for(a = 0; a < curproc->sz; a += PGSIZE) {
./kernel.asm:8066:    for(a = 0; a < curproc->sz; a += PGSIZE) {
./kernel.asm:8069:    curproc->rss = 0;
./kernel.asm:8076:  wakeup1(curproc->parent);
./kernel.asm:8091:    if(p->state == SLEEPING && p->chan == chan)
./kernel.asm:8096:      p->state = RUNNABLE;
./kernel.asm:8102:      p->parent = initproc;
./kernel.asm:8111:    if(p->parent == curproc){
./kernel.asm:8114:      if(p->state == ZOMBIE)
./kernel.asm:8116:      p->parent = initproc;
./kernel.asm:8118:      if(p->state == ZOMBIE)
./kernel.asm:8127:    if(p->state == SLEEPING && p->chan == chan)
./kernel.asm:8132:      p->state = RUNNABLE;
./kernel.asm:8135:  curproc->state = ZOMBIE;
./kernel.asm:8159:  p = c->proc;
./kernel.asm:8177:      if(p->parent != curproc)
./kernel.asm:8180:      if(p->state == ZOMBIE){
./kernel.asm:8190:    if(!havekids || curproc->killed){
./kernel.asm:8200:  p = c->proc;
./kernel.asm:8207:  p->chan = chan;
./kernel.asm:8209:  p->state = SLEEPING;
./kernel.asm:8213:  p->chan = 0;
./kernel.asm:8218:        kfree(p->kstack);
./kernel.asm:8220:        pid = p->pid;
./kernel.asm:8222:        kfree(p->kstack);
./kernel.asm:8225:        p->kstack = 0;
./kernel.asm:8227:        freevm(p->pgdir,p);
./kernel.asm:8233:        p->pid = 0;
./kernel.asm:8235:        p->parent = 0;
./kernel.asm:8237:        p->name[0] = 0;
./kernel.asm:8239:        p->killed = 0;
./kernel.asm:8241:        p->state = UNUSED;
./kernel.asm:8249:801042bf:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:8257:      return -1;
./kernel.asm:8262:      return -1;
./kernel.asm:8284:  p = c->proc;
./kernel.asm:8288:  if(myproc()->state == SUSPENDED){
./kernel.asm:8296:  p = c->proc;
./kernel.asm:8300:	  myproc()->state = RUNNABLE;
./kernel.asm:8309:8010434d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8331:  p = c->proc;
./kernel.asm:8351:  p->chan = chan;
./kernel.asm:8353:  p->state = SLEEPING;
./kernel.asm:8357:  p->chan = 0;
./kernel.asm:8366:801043d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:8374:  p->chan = chan;
./kernel.asm:8376:  p->state = SLEEPING;
./kernel.asm:8380:  p->chan = 0;
./kernel.asm:8383:801043fe:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:8421:    if(p->state == SLEEPING && p->chan == chan)
./kernel.asm:8426:      p->state = RUNNABLE;
./kernel.asm:8436:80104471:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8467:    if(p->pid == pid){
./kernel.asm:8470:      p->killed = 1;
./kernel.asm:8472:      if(p->state == SLEEPING)
./kernel.asm:8474:      p->killed = 1;
./kernel.asm:8476:      if(p->state == SLEEPING)
./kernel.asm:8478:        p->state = RUNNABLE;
./kernel.asm:8488:  return -1;
./kernel.asm:8490:801044d2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8503:801044ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8504:  return -1;
./kernel.asm:8523:80104505:	8d 75 e8             	lea    -0x18(%ebp),%esi
./kernel.asm:8529:    if(p->state == SLEEPING){
./kernel.asm:8530:      getcallerpcs((uint*)p->context->ebp+2, pc);
./kernel.asm:8543:    if(p->state == UNUSED)
./kernel.asm:8544:8010453a:	8b 43 a0             	mov    -0x60(%ebx),%eax
./kernel.asm:8549:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
./kernel.asm:8552:8010454b:	8b 14 85 18 89 10 80 	mov    -0x7fef76e8(,%eax,4),%edx
./kernel.asm:8557:    cprintf("%d %s %s", p->pid, state, p->name);
./kernel.asm:8560:8010455e:	ff 73 a4             	push   -0x5c(%ebx)
./kernel.asm:8563:    if(p->state == SLEEPING){
./kernel.asm:8565:8010456e:	83 7b a0 02          	cmpl   $0x2,-0x60(%ebx)
./kernel.asm:8567:      getcallerpcs((uint*)p->context->ebp+2, pc);
./kernel.asm:8569:80104577:	8d 45 c0             	lea    -0x40(%ebp),%eax
./kernel.asm:8570:8010457a:	8d 7d c0             	lea    -0x40(%ebp),%edi
./kernel.asm:8572:8010457e:	8b 43 b0             	mov    -0x50(%ebx),%eax
./kernel.asm:8598:801045b8:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:8625:        if(p->pid == 2)
./kernel.asm:8637:801045f0:	ff 24 95 00 89 10 80 	jmp    *-0x7fef7700(,%edx,4)
./kernel.asm:8642:                if(p->pid > 2 && p->state != UNUSED) {
./kernel.asm:8648:                    p->killed = 1;
./kernel.asm:8650:					p->state = RUNNABLE;
./kernel.asm:8662:80104627:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8668:                if(p->pid > 2 && p->state != UNUSED) {
./kernel.asm:8674:                    p->pending_signals |= (1 << (SIGCUSTOM - 1));  // SIGCUSTOM = 4 defined in signal.h  // Mark 4th bit from LSB as 1
./kernel.asm:8681:80104658:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8687:                if(p->state == SUSPENDED) {
./kernel.asm:8690:                    p->state = RUNNABLE;
./kernel.asm:8692:                    p->pending_suspend = 0;
./kernel.asm:8700:8010468b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8703:					p->parent = initproc;    // Reparent to init
./kernel.asm:8708:                if(p->pid > 2 && p->state != UNUSED) {
./kernel.asm:8714:					p->pending_suspend = 1;  // Mark for deferred suspension
./kernel.asm:8717:					p->parent = initproc;    // Reparent to init
./kernel.asm:8735:    if(p->state == SLEEPING && p->chan == chan)
./kernel.asm:8740:      p->state = RUNNABLE;
./kernel.asm:8749:80104711:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8765:				if(p->pid >= 1 && (p->state == SLEEPING || p->state == RUNNING || p->state == RUNNABLE)) {
./kernel.asm:8773:				  int num_pages = (p->sz + PGSIZE - 1) / PGSIZE;
./kernel.asm:8775:				  cprintf("%d %d\n", p->pid, num_pages);
./kernel.asm:8777:				  int num_pages = (p->sz + PGSIZE - 1) / PGSIZE;
./kernel.asm:8780:				  cprintf("%d %d\n", p->pid, num_pages);
./kernel.asm:8793:80104783:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8812:  initlock(&lk->lk, "sleep lock");
./kernel.asm:8817:  lk->name = name;
./kernel.asm:8819:  lk->locked = 0;
./kernel.asm:8821:  lk->pid = 0;
./kernel.asm:8824:  lk->pid = 0;
./kernel.asm:8826:  lk->name = name;
./kernel.asm:8829:801047be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:8846:  acquire(&lk->lk);
./kernel.asm:8851:  while (lk->locked) {
./kernel.asm:8857:    sleep(lk, &lk->lk);
./kernel.asm:8862:  while (lk->locked) {
./kernel.asm:8868:  lk->locked = 1;
./kernel.asm:8870:  lk->pid = myproc()->pid;
./kernel.asm:8874:  release(&lk->lk);
./kernel.asm:8877:80104817:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:8881:  release(&lk->lk);
./kernel.asm:8897:  acquire(&lk->lk);
./kernel.asm:8902:  lk->locked = 0;
./kernel.asm:8904:  lk->pid = 0;
./kernel.asm:8909:  release(&lk->lk);
./kernel.asm:8913:8010485f:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:8917:  release(&lk->lk);
./kernel.asm:8936:  acquire(&lk->lk);
./kernel.asm:8940:  r = lk->locked && (lk->pid == myproc()->pid);
./kernel.asm:8945:  release(&lk->lk);
./kernel.asm:8951:80104899:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:8959:  r = lk->locked && (lk->pid == myproc()->pid);
./kernel.asm:8980:  lk->name = name;
./kernel.asm:8982:  lk->locked = 0;
./kernel.asm:8984:  lk->name = name;
./kernel.asm:8986:  lk->cpu = 0;
./kernel.asm:9008:  ebp = (uint*)v - 2;
./kernel.asm:9009:801048ea:	8d 50 f8             	lea    -0x8(%eax),%edx
./kernel.asm:9019:80104900:	8d 9a 00 00 00 80    	lea    -0x80000000(%edx),%ebx
./kernel.asm:9037:8010491e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9059:80104951:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
./kernel.asm:9085:  if(mycpu()->ncli == 0)
./kernel.asm:9090:    mycpu()->intena = eflags & FL_IF;
./kernel.asm:9091:  mycpu()->ncli += 1;
./kernel.asm:9095:80104985:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9099:    mycpu()->intena = eflags & FL_IF;
./kernel.asm:9122:    panic("popcli - interruptible");
./kernel.asm:9123:  if(--mycpu()->ncli < 0)
./kernel.asm:9128:  if(mycpu()->ncli == 0 && mycpu()->intena)
./kernel.asm:9138:  if(mycpu()->ncli == 0 && mycpu()->intena)
./kernel.asm:9148:    panic("popcli - interruptible");
./kernel.asm:9168:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9180:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9187:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9206:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9217:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9224:  lk->pcs[0] = 0;
./kernel.asm:9226:  lk->cpu = 0;
./kernel.asm:9230:  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
./kernel.asm:9233:80104aa2:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:9253:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9263:  while(xchg(&lk->locked, 1) != 0)
./kernel.asm:9271:  lk->cpu = mycpu();
./kernel.asm:9274:  getcallerpcs(&lk, lk->pcs);
./kernel.asm:9278:  lk->cpu = mycpu();
./kernel.asm:9281:80104b01:	8d 85 00 00 00 80    	lea    -0x80000000(%ebp),%eax
./kernel.asm:9284:  ebp = (uint*)v - 2;
./kernel.asm:9289:80104b18:	8d 98 00 00 00 80    	lea    -0x80000000(%eax),%ebx
./kernel.asm:9303:80104b37:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9325:80104b69:	c7 40 fc 00 00 00 00 	movl   $0x0,-0x4(%eax)
./kernel.asm:9333:  r = lock->locked && lock->cpu == mycpu();
./kernel.asm:9382:80104bd4:	8b 7d fc             	mov    -0x4(%ebp),%edi
./kernel.asm:9392:80104be8:	8b 7d fc             	mov    -0x4(%ebp),%edi
./kernel.asm:9414:  while(n-- > 0){
./kernel.asm:9423:      return *s1 - *s2;
./kernel.asm:9427:  while(n-- > 0){
./kernel.asm:9435:      return *s1 - *s2;
./kernel.asm:9483:    while(n-- > 0)
./kernel.asm:9487:      *--d = *--s;
./kernel.asm:9490:    while(n-- > 0)
./kernel.asm:9494:    while(n-- > 0)
./kernel.asm:9505:    while(n-- > 0)
./kernel.asm:9513:    while(n-- > 0)
./kernel.asm:9557:    n--, p++, q++;
./kernel.asm:9568:  return (uchar)*p - (uchar)*q;
./kernel.asm:9572:80104ce4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9574:  return (uchar)*p - (uchar)*q;
./kernel.asm:9579:80104cf0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9604:  while(n-- > 0 && (*s++ = *t++) != 0)
./kernel.asm:9610:80104d1a:	0f b6 4f ff          	movzbl -0x1(%edi),%ecx
./kernel.asm:9611:80104d1e:	88 48 ff             	mov    %cl,-0x1(%eax)
./kernel.asm:9619:  while(n-- > 0)
./kernel.asm:9630:  while(n-- > 0)
./kernel.asm:9639:80104d4d:	c6 40 ff 00          	movb   $0x0,-0x1(%eax)
./kernel.asm:9640:  while(n-- > 0)
./kernel.asm:9655:// Like strncpy but guaranteed to NUL-terminate.
./kernel.asm:9672:80104d72:	8d 5c 10 ff          	lea    -0x1(%eax,%edx,1),%ebx
./kernel.asm:9677:  while(--n > 0 && (*s++ = *t++) != 0)
./kernel.asm:9681:80104d89:	88 4a ff             	mov    %cl,-0x1(%edx)
./kernel.asm:9726:# Switch stacks to new and pop previously-saved registers.
./kernel.asm:9735:  # Save old callee-saved registers
./kernel.asm:9751:  # Load new callee-saved registers
./kernel.asm:9778:  if(addr >= curproc->sz || addr+4 > curproc->sz)
./kernel.asm:9785:    return -1;
./kernel.asm:9793:80104df5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9797:    return -1;
./kernel.asm:9805:// Fetch the nul-terminated string at addr from the current process.
./kernel.asm:9806:// Doesn't actually copy the string - just sets *pp to point at it.
./kernel.asm:9820:  if(addr >= curproc->sz)
./kernel.asm:9823:    return -1;
./kernel.asm:9827:  ep = (char*)curproc->sz;
./kernel.asm:9841:      return s - *pp;
./kernel.asm:9844:  return -1;
./kernel.asm:9846:80104e46:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9850:80104e50:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:9851:    return -1;
./kernel.asm:9860:// Fetch the nth 32-bit system call argument.
./kernel.asm:9868:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9876:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9878:  if(addr >= curproc->sz || addr+4 > curproc->sz)
./kernel.asm:9897:    return -1;
./kernel.asm:9899:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9906:// Fetch the nth word-sized system call argument as a pointer
./kernel.asm:9922:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9930:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9932:  if(addr >= curproc->sz || addr+4 > curproc->sz)
./kernel.asm:9941:    return -1;
./kernel.asm:9942:  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
./kernel.asm:9946:  if(size < 0 || (uint)i >= curproc->sz || (uint)i+size > curproc->sz)
./kernel.asm:9956:    return -1;
./kernel.asm:9970:    return -1;
./kernel.asm:9978:// Check that the pointer is valid and the string is nul-terminated.
./kernel.asm:9988:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9996:  return fetchint((myproc()->tf->esp) + 4 + 4*n, ip);
./kernel.asm:9998:  if(addr >= curproc->sz || addr+4 > curproc->sz)
./kernel.asm:10009:  if(addr >= curproc->sz)
./kernel.asm:10015:  ep = (char*)curproc->sz;
./kernel.asm:10031:      return s - *pp;
./kernel.asm:10035:    return -1;
./kernel.asm:10044:    return -1;
./kernel.asm:10070:  num = curproc->tf->eax; // eax contain the system call number that need to be called 
./kernel.asm:10074:80104fb4:	8d 50 ff             	lea    -0x1(%eax),%edx
./kernel.asm:10077:80104fbc:	8b 14 85 40 89 10 80 	mov    -0x7fef76c0(,%eax,4),%edx
./kernel.asm:10080:    curproc->tf->eax = syscalls[num](); //syscalls[num]() is a kernal function that will use above syscalls[]->int 
./kernel.asm:10087:            curproc->pid, curproc->name, num);
./kernel.asm:10088:    curproc->tf->eax = -1;
./kernel.asm:10091:80104fd1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:10099:            curproc->pid, curproc->name, num);
./kernel.asm:10106:    curproc->tf->eax = -1;
./kernel.asm:10111:80104fff:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:10122:  return -1;
./kernel.asm:10136:80105015:	8d 7d da             	lea    -0x26(%ebp),%edi
./kernel.asm:10140:8010501c:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./kernel.asm:10142:80105022:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./kernel.asm:10143:80105025:	89 4d cc             	mov    %ecx,-0x34(%ebp)
./kernel.asm:10175:    if(type == T_FILE && ip->type == T_FILE)
./kernel.asm:10177:8010506a:	66 83 7d d4 02       	cmpw   $0x2,-0x2c(%ebp)
./kernel.asm:10187:80105078:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:10202:80105094:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:10212:  if((ip = ialloc(dp->dev, type)) == 0)
./kernel.asm:10213:801050a0:	0f bf 45 d4          	movswl -0x2c(%ebp),%eax
./kernel.asm:10226:  ip->major = major;
./kernel.asm:10227:801050c5:	0f b7 45 d0          	movzwl -0x30(%ebp),%eax
./kernel.asm:10229:  ip->minor = minor;
./kernel.asm:10230:801050cd:	0f b7 45 cc          	movzwl -0x34(%ebp),%eax
./kernel.asm:10232:  ip->nlink = 1;
./kernel.asm:10240:801050e9:	66 83 7d d4 01       	cmpw   $0x1,-0x2c(%ebp)
./kernel.asm:10242:  if(dirlink(dp, name, ip->inum) < 0)
./kernel.asm:10258:80105110:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:10268:    dp->nlink++;  // for ".."
./kernel.asm:10273:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
./kernel.asm:10313:80105195:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:10323:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
./kernel.asm:10324:801051aa:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
./kernel.asm:10327:801051b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:10338:    if(curproc->ofile[fd] == 0){
./kernel.asm:10347:801051e0:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:10348:    return -1;
./kernel.asm:10359:      curproc->ofile[fd] = f;
./kernel.asm:10367:80105200:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:10382:80105215:	8d 5d f4             	lea    -0xc(%ebp),%ebx
./kernel.asm:10392:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
./kernel.asm:10393:8010522a:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
./kernel.asm:10396:80105235:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:10402:80105243:	8d 45 f0             	lea    -0x10(%ebp),%eax
./kernel.asm:10410:80105258:	ff 75 f0             	push   -0x10(%ebp)
./kernel.asm:10419:8010526d:	ff 75 f0             	push   -0x10(%ebp)
./kernel.asm:10420:80105270:	ff 75 f4             	push   -0xc(%ebp)
./kernel.asm:10425:8010527c:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:10431:    return -1;
./kernel.asm:10443:80105295:	8d 5d f4             	lea    -0xc(%ebp),%ebx
./kernel.asm:10453:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
./kernel.asm:10454:801052aa:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
./kernel.asm:10457:801052b5:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:10463:801052c3:	8d 45 f0             	lea    -0x10(%ebp),%eax
./kernel.asm:10471:801052d8:	ff 75 f0             	push   -0x10(%ebp)
./kernel.asm:10480:801052ed:	ff 75 f0             	push   -0x10(%ebp)
./kernel.asm:10481:801052f0:	ff 75 f4             	push   -0xc(%ebp)
./kernel.asm:10486:801052fc:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:10492:    return -1;
./kernel.asm:10504:80105315:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:10514:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
./kernel.asm:10515:8010532a:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
./kernel.asm:10518:80105335:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:10523:  myproc()->ofile[fd] = 0;
./kernel.asm:10527:  myproc()->ofile[fd] = 0;
./kernel.asm:10537:8010535e:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:10543:    return -1;
./kernel.asm:10555:80105375:	8d 5d f4             	lea    -0xc(%ebp),%ebx
./kernel.asm:10565:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
./kernel.asm:10566:8010538a:	83 7d f4 0f          	cmpl   $0xf,-0xc(%ebp)
./kernel.asm:10569:80105395:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:10584:801053b7:	ff 75 f4             	push   -0xc(%ebp)
./kernel.asm:10589:801053c3:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:10595:    return -1;
./kernel.asm:10609:801053e5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
./kernel.asm:10621:80105402:	8d 45 d0             	lea    -0x30(%ebp),%eax
./kernel.asm:10632:80105420:	ff 75 d4             	push   -0x2c(%ebp)
./kernel.asm:10642:  if(ip->type == T_DIR){
./kernel.asm:10648:  ip->nlink++;
./kernel.asm:10651:80105454:	8d 7d da             	lea    -0x26(%ebp),%edi
./kernel.asm:10662:80105468:	ff 75 d0             	push   -0x30(%ebp)
./kernel.asm:10672:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
./kernel.asm:10698:801054ba:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:10715:  ip->nlink--;
./kernel.asm:10725:  return -1;
./kernel.asm:10727:    return -1;
./kernel.asm:10736:    return -1;
./kernel.asm:10741:    return -1;
./kernel.asm:10752:80105525:	8d 45 c0             	lea    -0x40(%ebp),%eax
./kernel.asm:10766:80105544:	8d 5d ca             	lea    -0x36(%ebp),%ebx
./kernel.asm:10769:8010554b:	ff 75 c0             	push   -0x40(%ebp)
./kernel.asm:10772:80105556:	89 45 b4             	mov    %eax,-0x4c(%ebp)
./kernel.asm:10776:80105561:	8b 7d b4             	mov    -0x4c(%ebp),%edi
./kernel.asm:10798:801055a1:	8d 45 c4             	lea    -0x3c(%ebp),%eax
./kernel.asm:10811:  if(ip->nlink < 1)
./kernel.asm:10815:  if(ip->type == T_DIR && !isdirempty(ip)){
./kernel.asm:10817:801055d5:	8d 7d d8             	lea    -0x28(%ebp),%edi
./kernel.asm:10827:801055e9:	ff 75 c4             	push   -0x3c(%ebp)
./kernel.asm:10829:801055ed:	ff 75 b4             	push   -0x4c(%ebp)
./kernel.asm:10834:  if(ip->type == T_DIR){
./kernel.asm:10839:8010560f:	ff 75 b4             	push   -0x4c(%ebp)
./kernel.asm:10841:  ip->nlink--;
./kernel.asm:10855:80105636:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:10862:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
./kernel.asm:10881:8010566a:	66 83 7d d8 00       	cmpw   $0x0,-0x28(%ebp)
./kernel.asm:10892:80105683:	ff 75 b4             	push   -0x4c(%ebp)
./kernel.asm:10896:  return -1;
./kernel.asm:10898:    return -1;
./kernel.asm:10902:    dp->nlink--;
./kernel.asm:10903:801056a0:	8b 45 b4             	mov    -0x4c(%ebp),%eax
./kernel.asm:10906:    dp->nlink--;
./kernel.asm:10915:    return -1;
./kernel.asm:10948:801056f5:	8d 45 e0             	lea    -0x20(%ebp),%eax
./kernel.asm:10960:80105712:	8d 45 e4             	lea    -0x1c(%ebp),%eax
./kernel.asm:10967:    return -1;
./kernel.asm:10973:80105729:	f6 45 e5 02          	testb  $0x2,-0x1b(%ebp)
./kernel.asm:10977:      return -1;
./kernel.asm:10982:80105732:	ff 75 e0             	push   -0x20(%ebp)
./kernel.asm:10989:      return -1;
./kernel.asm:10995:    if(ip->type == T_DIR && omode != O_RDONLY){
./kernel.asm:11000:      return -1;
./kernel.asm:11013:    if(curproc->ofile[fd] == 0){
./kernel.asm:11033:    return -1;
./kernel.asm:11035:    return -1;
./kernel.asm:11044:801057b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:11055:      return -1;
./kernel.asm:11061:      curproc->ofile[fd] = f;
./kernel.asm:11069:  f->type = FD_INODE;
./kernel.asm:11071:  f->ip = ip;
./kernel.asm:11072:  f->off = 0;
./kernel.asm:11073:  f->readable = !(omode & O_WRONLY);
./kernel.asm:11074:801057e8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:11075:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
./kernel.asm:11077:  f->ip = ip;
./kernel.asm:11079:  f->readable = !(omode & O_WRONLY);
./kernel.asm:11081:  f->off = 0;
./kernel.asm:11083:  f->readable = !(omode & O_WRONLY);
./kernel.asm:11086:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
./kernel.asm:11088:  f->readable = !(omode & O_WRONLY);
./kernel.asm:11090:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
./kernel.asm:11094:80105809:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:11102:    if(ip->type == T_DIR && omode != O_RDONLY){
./kernel.asm:11103:80105818:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
./kernel.asm:11125:8010583e:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11133:80105853:	8b 45 f4             	mov    -0xc(%ebp),%eax
./kernel.asm:11142:    return -1;
./kernel.asm:11158:    return -1;
./kernel.asm:11181:8010589e:	8d 45 ec             	lea    -0x14(%ebp),%eax
./kernel.asm:11190:801058b3:	8d 45 f0             	lea    -0x10(%ebp),%eax
./kernel.asm:11200:801058c8:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11209:801058da:	0f bf 45 f4          	movswl -0xc(%ebp),%eax
./kernel.asm:11211:801058e1:	0f bf 4d f0          	movswl -0x10(%ebp),%ecx
./kernel.asm:11214:801058eb:	8b 45 ec             	mov    -0x14(%ebp),%eax
./kernel.asm:11221:    return -1;
./kernel.asm:11238:    return -1;
./kernel.asm:11265:80105937:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11273:8010594c:	ff 75 f4             	push   -0xc(%ebp)
./kernel.asm:11280:    return -1;
./kernel.asm:11286:  if(ip->type != T_DIR){
./kernel.asm:11292:    return -1;
./kernel.asm:11298:  iput(curproc->cwd);
./kernel.asm:11304:  curproc->cwd = ip;
./kernel.asm:11310:8010598f:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:11324:    return -1;
./kernel.asm:11326:    return -1;
./kernel.asm:11333:    return -1;
./kernel.asm:11353:801059d5:	8d 85 5c ff ff ff    	lea    -0xa4(%ebp),%eax
./kernel.asm:11365:801059f8:	8d 85 60 ff ff ff    	lea    -0xa0(%ebp),%eax
./kernel.asm:11372:    return -1;
./kernel.asm:11376:80105a10:	8d b5 68 ff ff ff    	lea    -0x98(%ebp),%esi
./kernel.asm:11388:      return -1;
./kernel.asm:11391:80105a33:	8d 85 64 ff ff ff    	lea    -0x9c(%ebp),%eax
./kernel.asm:11394:80105a41:	8b 85 60 ff ff ff    	mov    -0xa0(%ebp),%eax
./kernel.asm:11401:      return -1;
./kernel.asm:11403:80105a56:	8b 85 64 ff ff ff    	mov    -0x9c(%ebp),%eax
./kernel.asm:11423:      return -1;
./kernel.asm:11427:80105a7c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:11428:    return -1;
./kernel.asm:11438:80105a90:	c7 84 9d 68 ff ff ff 	movl   $0x0,-0x98(%ebp,%ebx,4)
./kernel.asm:11443:80105a9f:	ff b5 5c ff ff ff    	push   -0xa4(%ebp)
./kernel.asm:11447:80105aad:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:11471:80105ac5:	8d 45 dc             	lea    -0x24(%ebp),%eax
./kernel.asm:11483:    return -1;
./kernel.asm:11486:80105ae4:	8d 45 e4             	lea    -0x1c(%ebp),%eax
./kernel.asm:11488:80105ae8:	8d 45 e0             	lea    -0x20(%ebp),%eax
./kernel.asm:11494:    return -1;
./kernel.asm:11495:  fd0 = -1;
./kernel.asm:11497:80105af8:	8b 7d e0             	mov    -0x20(%ebp),%edi
./kernel.asm:11502:    if(curproc->ofile[fd] == 0){
./kernel.asm:11511:    if(curproc->ofile[fd] == 0){
./kernel.asm:11515:      curproc->ofile[fd] = f;
./kernel.asm:11519:80105b27:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./kernel.asm:11525:    if(curproc->ofile[fd] == 0){
./kernel.asm:11534:      myproc()->ofile[fd0] = 0;
./kernel.asm:11540:80105b58:	ff 75 e0             	push   -0x20(%ebp)
./kernel.asm:11544:80105b61:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:11546:    return -1;
./kernel.asm:11548:    return -1;
./kernel.asm:11552:      curproc->ofile[fd] = f;
./kernel.asm:11556:80105b7c:	8b 45 dc             	mov    -0x24(%ebp),%eax
./kernel.asm:11559:80105b81:	8b 45 dc             	mov    -0x24(%ebp),%eax
./kernel.asm:11564:80105b89:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:11632:80105bd6:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11639:    return -1;
./kernel.asm:11642:80105beb:	ff 75 f4             	push   -0xc(%ebp)
./kernel.asm:11651:    return -1;
./kernel.asm:11667:  return myproc()->pid;
./kernel.asm:11686:80105c24:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11696:    return -1;
./kernel.asm:11697:  addr = myproc()->sz;
./kernel.asm:11701:  addr = myproc()->sz;
./kernel.asm:11704:80105c43:	ff 75 f4             	push   -0xc(%ebp)
./kernel.asm:11709:    return -1;
./kernel.asm:11713:80105c54:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:11717:    return -1;
./kernel.asm:11736:80105c74:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11746:    return -1;
./kernel.asm:11752:  while(ticks - ticks0 < n){
./kernel.asm:11753:80105c96:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:11756:  while(ticks - ticks0 < n){
./kernel.asm:11763:    if(myproc()->killed){
./kernel.asm:11765:      return -1;
./kernel.asm:11772:  while(ticks - ticks0 < n){
./kernel.asm:11776:80105ccc:	3b 45 f4             	cmp    -0xc(%ebp),%eax
./kernel.asm:11778:    if(myproc()->killed){
./kernel.asm:11787:      return -1;
./kernel.asm:11793:80105ced:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:11794:    return -1;
./kernel.asm:11807:80105d0d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:11842:80105d45:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:11849://------------------------------------------------------------------------------------------------------------->
./kernel.asm:11858:80105d56:	8d 45 f4             	lea    -0xc(%ebp),%eax
./kernel.asm:11866:        return -1;
./kernel.asm:11867:    myproc()->sighandler = handler;
./kernel.asm:11869:80105d6f:	8b 55 f4             	mov    -0xc(%ebp),%edx
./kernel.asm:11878:        return -1;
./kernel.asm:11957:80105dc0:	8b 14 85 08 b0 10 80 	mov    -0x7fef4ff8(,%eax,4),%edx
./kernel.asm:11958:80105dc7:	c7 04 c5 e2 54 11 80 	movl   $0x8e000008,-0x7feeab1e(,%eax,8)
./kernel.asm:11960:80105dd2:	66 89 14 c5 e0 54 11 	mov    %dx,-0x7feeab20(,%eax,8)
./kernel.asm:11963:80105ddd:	66 89 14 c5 e6 54 11 	mov    %dx,-0x7feeab1a(,%eax,8)
./kernel.asm:12000:  pd[0] = size-1;
./kernel.asm:12004:80105e3b:	66 89 45 fa          	mov    %ax,-0x6(%ebp)
./kernel.asm:12007:80105e44:	66 89 45 fc          	mov    %ax,-0x4(%ebp)
./kernel.asm:12010:80105e4b:	66 89 45 fe          	mov    %ax,-0x2(%ebp)
./kernel.asm:12012:80105e4f:	8d 45 fa             	lea    -0x6(%ebp),%eax
./kernel.asm:12035:  if(tf->trapno == T_SYSCALL){
./kernel.asm:12039:    if(myproc()->killed)
./kernel.asm:12044:  switch(tf->trapno){
./kernel.asm:12048:80105e84:	ff 24 85 9c 89 10 80 	jmp    *-0x7fef7664(,%eax,4)
./kernel.asm:12063:  //---------------------------------------------------------------------------------------------------------------------->
./kernel.asm:12066:if(myproc() && myproc()->pending_signals) {
./kernel.asm:12075:	//--------------------------------------------------- Control + I ------------------------------------------------------->
./kernel.asm:12085:		if(p->pid == 2)
./kernel.asm:12092:	if(myproc() && myproc()->pending_suspend) {
./kernel.asm:12105:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER){
./kernel.asm:12122:  if(myproc() && myproc()->state == RUNNING &&
./kernel.asm:12129:     tf->trapno == T_IRQ0+IRQ_TIMER)
./kernel.asm:12133:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
./kernel.asm:12147:80105f4e:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:12156:    if(myproc() == 0 || (tf->cs&3) == 0){
./kernel.asm:12170:80105f7d:	89 4d d8             	mov    %ecx,-0x28(%ebp)
./kernel.asm:12174:80105f88:	89 45 dc             	mov    %eax,-0x24(%ebp)
./kernel.asm:12176:80105f8e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:12177:            "eip 0x%x addr 0x%x--kill proc\n",myproc()->pid, myproc()->name, tf->trapno,tf->err, cpuid(), tf->eip, rcr2());
./kernel.asm:12179:80105f96:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:12182:80105f9e:	8b 4d d8             	mov    -0x28(%ebp),%ecx
./kernel.asm:12185:80105fa3:	8b 55 dc             	mov    -0x24(%ebp),%edx
./kernel.asm:12187:80105fa7:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:12189:            "eip 0x%x addr 0x%x--kill proc\n",myproc()->pid, myproc()->name, tf->trapno,tf->err, cpuid(), tf->eip, rcr2());
./kernel.asm:12190:80105fab:	8b 75 e0             	mov    -0x20(%ebp),%esi
./kernel.asm:12197:    myproc()->killed = 1;
./kernel.asm:12201:if(myproc() && myproc()->pending_signals) {
./kernel.asm:12206:  if(myproc() && myproc()->state == RUNNING &&
./kernel.asm:12213:  if(myproc()->pending_signals & (1 << (SIGCUSTOM - 1))) {
./kernel.asm:12217:    if(myproc()->sighandler) {
./kernel.asm:12222:    uint handler_addr = (uint)myproc()->sighandler;
./kernel.asm:12225:                if ((tf->cs & 3) == DPL_USER) {
./kernel.asm:12230:                    tf->eip = handler_addr;
./kernel.asm:12232:                    myproc()->pending_signals &= ~(1 << (SIGCUSTOM - 1));
./kernel.asm:12241:		myproc()->state = SUSPENDED;
./kernel.asm:12244:		myproc()->pending_suspend = 0;
./kernel.asm:12257:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER){
./kernel.asm:12262:    if(myproc()->killed)
./kernel.asm:12267:    myproc()->tf = tf;
./kernel.asm:12272:    if(myproc()->killed)
./kernel.asm:12278:801060cb:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:12298:if(myproc() && myproc()->pending_signals) {
./kernel.asm:12307:if(myproc() && myproc()->pending_signals) {
./kernel.asm:12316:if(myproc() && myproc()->pending_signals) {
./kernel.asm:12328:    if(va >= curproc->sz || !curproc->pgdir)
./kernel.asm:12334:    pte_t *pte = walkpgdir(curproc->pgdir, (void*)va, 0);
./kernel.asm:12347:      handle_pgfault(curproc->pgdir, va);
./kernel.asm:12354:      curproc->killed = 1;
./kernel.asm:12409:    return -1;
./kernel.asm:12415:    return -1;
./kernel.asm:12420:    return -1;
./kernel.asm:12486:801062c9:	c6 45 e7 78          	movb   $0x78,-0x19(%ebp)
./kernel.asm:12513:80106306:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./kernel.asm:12518:80106312:	88 45 e7             	mov    %al,-0x19(%ebp)
./kernel.asm:12522:80106319:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:12568:8010637a:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:12594:# generated by vectors.pl - do not edit
./kernel.asm:15149:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
./kernel.asm:15171:80106e39:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:15176:80106e47:	89 4d dc             	mov    %ecx,-0x24(%ebp)
./kernel.asm:15181:      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
./kernel.asm:15193:      if(p->rss > 0)  // Prevent underflow
./kernel.asm:15197:        p->rss--;
./kernel.asm:15204:80106e73:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:15219:80106e92:	8d 84 08 00 00 00 80 	lea    -0x80000000(%eax,%ecx,1),%eax
./kernel.asm:15238:80106ec1:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:15245:80106ed0:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:15252:80106ee8:	8b 55 dc             	mov    -0x24(%ebp),%edx
./kernel.asm:15257:80106eeb:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15284:80106f21:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:15285:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
./kernel.asm:15286:80106f24:	8d 44 0a ff          	lea    -0x1(%edx,%ecx,1),%eax
./kernel.asm:15288:80106f2d:	89 45 dc             	mov    %eax,-0x24(%ebp)
./kernel.asm:15291:80106f35:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:15301:80106f50:	8d 84 10 00 00 00 80 	lea    -0x80000000(%eax,%edx,1),%eax
./kernel.asm:15313:80106f6c:	8b 45 dc             	mov    -0x24(%ebp),%eax
./kernel.asm:15319:80106f79:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:15321:80106f7c:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./kernel.asm:15339:80106fa4:	89 45 d8             	mov    %eax,-0x28(%ebp)
./kernel.asm:15342:80106fac:	8b 55 d8             	mov    -0x28(%ebp),%edx
./kernel.asm:15346:80106fb2:	8d 82 00 00 00 80    	lea    -0x80000000(%edx),%eax
./kernel.asm:15357:80106fd0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15358:      return -1;
./kernel.asm:15367:80106fe0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15391:  pd[0] = size-1;
./kernel.asm:15393:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
./kernel.asm:15395:80107016:	66 89 55 f2          	mov    %dx,-0xe(%ebp)
./kernel.asm:15396:8010701a:	c7 80 38 28 11 80 ff 	movl   $0xffff,-0x7feed7c8(%eax)
./kernel.asm:15398:80107024:	c7 80 3c 28 11 80 00 	movl   $0xcf9a00,-0x7feed7c4(%eax)
./kernel.asm:15400:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
./kernel.asm:15401:8010702e:	c7 80 40 28 11 80 ff 	movl   $0xffff,-0x7feed7c0(%eax)
./kernel.asm:15403:80107038:	c7 80 44 28 11 80 00 	movl   $0xcf9200,-0x7feed7bc(%eax)
./kernel.asm:15405:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
./kernel.asm:15406:80107042:	c7 80 48 28 11 80 ff 	movl   $0xffff,-0x7feed7b8(%eax)
./kernel.asm:15408:8010704c:	c7 80 4c 28 11 80 00 	movl   $0xcffa00,-0x7feed7b4(%eax)
./kernel.asm:15410:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
./kernel.asm:15411:80107056:	c7 80 50 28 11 80 ff 	movl   $0xffff,-0x7feed7b0(%eax)
./kernel.asm:15413:80107060:	c7 80 54 28 11 80 00 	movl   $0xcff200,-0x7feed7ac(%eax)
./kernel.asm:15415:  lgdt(c->gdt, sizeof(c->gdt));
./kernel.asm:15418:8010706f:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
./kernel.asm:15421:80107076:	66 89 45 f6          	mov    %ax,-0xa(%ebp)
./kernel.asm:15423:8010707a:	8d 45 f2             	lea    -0xe(%ebp),%eax
./kernel.asm:15456:801070bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15483:801070f2:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
./kernel.asm:15490:80107108:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15530:  if(p->kstack == 0)
./kernel.asm:15534:  if(p->pgdir == 0)
./kernel.asm:15540:  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
./kernel.asm:15547:80107175:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:15549:8010717d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
./kernel.asm:15554:  mycpu()->ts.iomb = (ushort) 0xFFFF;
./kernel.asm:15556:  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
./kernel.asm:15564:  mycpu()->ts.ss0 = SEG_KDATA << 3;
./kernel.asm:15566:  mycpu()->gdt[SEG_TSS].s = 0;
./kernel.asm:15569:  mycpu()->ts.ss0 = SEG_KDATA << 3;
./kernel.asm:15572:  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
./kernel.asm:15577:  mycpu()->ts.iomb = (ushort) 0xFFFF;
./kernel.asm:15583:  lcr3(V2P(p->pgdir));  // switch to process's address space
./kernel.asm:15589:80107203:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15623:80107252:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:15640:80107275:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
./kernel.asm:15646:80107286:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:15654:8010729a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15711:80107316:	8d 8c 01 00 00 00 80 	lea    -0x80000000(%ecx,%eax,1),%ecx
./kernel.asm:15715:    if(sz - i < PGSIZE)
./kernel.asm:15742:8010735c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15754:80107370:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15755:      return -1;
./kernel.asm:15795:801073c8:	89 55 e4             	mov    %edx,-0x1c(%ebp)
./kernel.asm:15806:801073e1:	8d 83 00 00 00 80    	lea    -0x80000000(%ebx),%eax
./kernel.asm:15820:      p->rss++;
./kernel.asm:15851:80107454:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15862:80107463:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15896:801074b0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:15898:801074b3:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:15921:801074d7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:15924:801074e0:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kernel.asm:15994:80107555:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16028:                (uint)k->phys_start, k->perm) < 0) {
./kernel.asm:16030:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
./kernel.asm:16047:801075c2:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:16062:801075de:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kernel.asm:16126:8010764e:	8d 84 02 00 00 00 80 	lea    -0x80000000(%edx,%eax,1),%eax
./kernel.asm:16157:8010766e:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:16191:801076c0:	8d 84 10 00 00 00 80 	lea    -0x80000000(%eax,%edx,1),%eax
./kernel.asm:16204:801076dc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:16222:80107706:	8d 86 00 00 00 80    	lea    -0x80000000(%esi),%eax
./kernel.asm:16224:8010770d:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:16228:80107718:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:16237:    //acquire(&np->lock);
./kernel.asm:16238:    np->rss++;
./kernel.asm:16242:    np->rss++;
./kernel.asm:16253:80107740:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:16254:80107743:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16270:80107762:	ff 75 e0             	push   -0x20(%ebp)
./kernel.asm:16275:8010776d:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
./kernel.asm:16277:80107774:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:16278:80107777:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16323:801077b9:	8b 94 82 00 00 00 80 	mov    -0x80000000(%edx,%eax,4),%edx
./kernel.asm:16363:80107806:	8d 8b 00 00 00 80    	lea    -0x80000000(%ebx),%ecx
./kernel.asm:16369:      return -1;
./kernel.asm:16370:    n = PGSIZE - (va - va0);
./kernel.asm:16378:    memmove(pa0 + (va - va0), buf, n);
./kernel.asm:16387:    len -= n;
./kernel.asm:16421:80107874:	8b 9c 99 00 00 00 80 	mov    -0x80000000(%ecx,%ebx,4),%ebx
./kernel.asm:16430:80107888:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16431:      return -1;
./kernel.asm:16440:80107898:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16475:801078c0:	c7 04 c5 04 5d 11 80 	movl   $0x1,-0x7feea2fc(,%eax,8)
./kernel.asm:16478:801078cb:	c7 04 c5 00 5d 11 80 	movl   $0x0,-0x7feea300(,%eax,8)
./kernel.asm:16509:80107912:	8b 14 c5 04 5d 11 80 	mov    -0x7feea2fc(,%eax,8),%edx
./kernel.asm:16515:8010791e:	c7 04 c5 04 5d 11 80 	movl   $0x0,-0x7feea2fc(,%eax,8)
./kernel.asm:16524:  return -1;
./kernel.asm:16528:8010792f:	89 14 c5 00 5d 11 80 	mov    %edx,-0x7feea300(,%eax,8)
./kernel.asm:16531:  return -1;
./kernel.asm:16549:80107950:	c7 04 c5 04 5d 11 80 	movl   $0x1,-0x7feea2fc(,%eax,8)
./kernel.asm:16552:8010795b:	c7 04 c5 00 5d 11 80 	movl   $0x0,-0x7feea300(,%eax,8)
./kernel.asm:16581:80107998:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:16591:    memmove(b->data, (char*)page + i*BSIZE, BSIZE);
./kernel.asm:16595:    memmove(b->data, (char*)page + i*BSIZE, BSIZE);
./kernel.asm:16601:    memmove(b->data, (char*)page + i*BSIZE, BSIZE);
./kernel.asm:16611:801079d8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:16617:801079e2:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16641:80107a08:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:16651:    memmove((char*)page + i*BSIZE, b->data, BSIZE);
./kernel.asm:16655:    memmove((char*)page + i*BSIZE, b->data, BSIZE);
./kernel.asm:16662:    memmove((char*)page + i*BSIZE, b->data, BSIZE);
./kernel.asm:16668:80107a40:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./kernel.asm:16674:80107a4a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16709:  int max_rss = -1;
./kernel.asm:16726:      max_rss = p->rss;
./kernel.asm:16734:    if(p->state != UNUSED && p->rss > max_rss) {
./kernel.asm:16741:    } else if(p->state != UNUSED && p->rss == max_rss) {
./kernel.asm:16743:      if(victim && p->pid < victim->pid) {
./kernel.asm:16773:80107adf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./kernel.asm:16790:80107b0a:	ff 75 e4             	push   -0x1c(%ebp)
./kernel.asm:16823:80107b4b:	8b 34 d5 04 5d 11 80 	mov    -0x7feea2fc(,%edx,8),%esi
./kernel.asm:16834:80107b58:	89 0c d5 00 5d 11 80 	mov    %ecx,-0x7feea300(,%edx,8)
./kernel.asm:16836:80107b5f:	c7 04 d5 04 5d 11 80 	movl   $0x0,-0x7feea2fc(,%edx,8)
./kernel.asm:16842:80107b72:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
./kernel.asm:16847:80107b7e:	89 45 e0             	mov    %eax,-0x20(%ebp)
./kernel.asm:16853:80107b88:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./kernel.asm:16854:80107b8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
./kernel.asm:16864:  // victim->sz -= PGSIZE;
./kernel.asm:16866:  victim->rss--;
./kernel.asm:16871:80107ba5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:16882:80107bb8:	c7 45 e4 00 f2 ff ff 	movl   $0xfffff200,-0x1c(%ebp)
./kernel.asm:16884:  return -1;
./kernel.asm:16901:// Handle page fault (swapped-in)
./kernel.asm:16952:80107c3e:	0b 1c fd 00 5d 11 80 	or     -0x7feea300(,%edi,8),%ebx
./kernel.asm:16965:80107c5b:	c7 04 fd 04 5d 11 80 	movl   $0x1,-0x7feea2fc(,%edi,8)
./kernel.asm:16968:80107c66:	c7 04 fd 00 5d 11 80 	movl   $0x0,-0x7feea300(,%edi,8)
./kernel.asm:16976:  // curproc->sz += PGSIZE;  // Add page size when swapping in
./kernel.asm:16977:  curproc->rss++;
./kernel.asm:16980:80107c7d:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kernel.asm:17050:    Th -= (Th * beta) / 100;
./kernel.asm:17081:80107d62:	8d 65 f4             	lea    -0xc(%ebp),%esp
./TRICKS:5:---
./TRICKS:21:at that point, cp->tf is set to point to a trap frame
./TRICKS:28:---
./TRICKS:47:---
./TRICKS:53:	if(c->ncli++ == 0)
./TRICKS:54:		c->intena = eflags & FL_IF;
./TRICKS:56:Consider a bottom-level pushcli.  
./TRICKS:74:	c->intena = 1;
./TRICKS:77:---
./TRICKS:79:The x86's processor-ordering memory model 
./TRICKS:97:  - all reads in B see the effects of writes in A.
./TRICKS:98:  - all reads in A do *not* see the effects of writes in B.
./TRICKS:101:to memory before the write of lk->locked = 0 in 
./TRICKS:103:will observe CPU0's write of lk->locked = 0 only
./TRICKS:116:---
./TRICKS:118:The code in fork needs to read np->pid before
./TRICKS:119:setting np->state to RUNNABLE.  The following
./TRICKS:126:	  np->state = RUNNABLE;
./TRICKS:127:	  return np->pid; // oops
./TRICKS:130:After setting np->state to RUNNABLE, some other CPU
./TRICKS:134:"return np->pid". Even saving a copy of np->pid before
./TRICKS:135:setting np->state isn't safe, since the compiler is
./TRICKS:136:allowed to re-order statements.
./TRICKS:138:The real code saves a copy of np->pid, then acquires a lock
./TRICKS:139:around the write to np->state. The acquire() prevents the
./TRICKS:140:compiler from re-ordering.
./vectors.pl:1:#!/usr/bin/perl -w
./vectors.pl:9:print "# generated by vectors.pl - do not edit\n"; #It is just a comment
./sysproc.d:1:sysproc.o: sysproc.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./bio.c:50:    b->next = bcache.head.next;
./bio.c:51:    b->prev = &bcache.head;
./bio.c:52:    initsleeplock(&b->lock, "buffer");
./bio.c:53:    bcache.head.next->prev = b;
./bio.c:69:  for(b = bcache.head.next; b != &bcache.head; b = b->next){
./bio.c:70:    if(b->dev == dev && b->blockno == blockno){
./bio.c:71:      b->refcnt++;
./bio.c:73:      acquiresleep(&b->lock);
./bio.c:81:  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
./bio.c:82:    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
./bio.c:83:      b->dev = dev;
./bio.c:84:      b->blockno = blockno;
./bio.c:85:      b->flags = 0;
./bio.c:86:      b->refcnt = 1;
./bio.c:88:      acquiresleep(&b->lock);
./bio.c:102:  if((b->flags & B_VALID) == 0) {
./bio.c:112:  if(!holdingsleep(&b->lock))
./bio.c:114:  b->flags |= B_DIRTY;
./bio.c:123:  if(!holdingsleep(&b->lock))
./bio.c:126:  releasesleep(&b->lock);
./bio.c:129:  b->refcnt--;
./bio.c:130:  if (b->refcnt == 0) {
./bio.c:132:    b->next->prev = b->prev;
./bio.c:133:    b->prev->next = b->next;
./bio.c:134:    b->next = bcache.head.next;
./bio.c:135:    b->prev = &bcache.head;
./bio.c:136:    bcache.head.next->prev = b;
./BUGS:5:	can't always runcmd in child -- breaks cd.
./BUGS:6:	maybe should hard-code PATH=/ ?
./lapic.d:1:lapic.o: lapic.c /usr/i686-linux-gnu/include/stdc-predef.h param.h \
./kbd.d:1:kbd.o: kbd.c /usr/i686-linux-gnu/include/stdc-predef.h types.h x86.h \
./vectors.S:1:# generated by vectors.pl - do not edit
./vm.d:1:vm.o: vm.c /usr/i686-linux-gnu/include/stdc-predef.h param.h types.h \
./spinlock.c:15:  lk->name = name;
./spinlock.c:16:  lk->locked = 0;
./spinlock.c:17:  lk->cpu = 0;
./spinlock.c:32:  while(xchg(&lk->locked, 1) != 0)
./spinlock.c:41:  lk->cpu = mycpu();
./spinlock.c:42:  getcallerpcs(&lk, lk->pcs);
./spinlock.c:52:  lk->pcs[0] = 0;
./spinlock.c:53:  lk->cpu = 0;
./spinlock.c:58:  // Both the C compiler and the hardware may re-order loads and
./spinlock.c:62:  // Release the lock, equivalent to lk->locked = 0.
./spinlock.c:65:  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
./spinlock.c:77:  ebp = (uint*)v - 2;
./spinlock.c:94:  r = lock->locked && lock->cpu == mycpu();
./spinlock.c:111:  if(mycpu()->ncli == 0)
./spinlock.c:112:    mycpu()->intena = eflags & FL_IF;
./spinlock.c:113:  mycpu()->ncli += 1;
./spinlock.c:120:    panic("popcli - interruptible");
./spinlock.c:121:  if(--mycpu()->ncli < 0)
./spinlock.c:123:  if(mycpu()->ncli == 0 && mycpu()->intena)
./pipe.d:1:pipe.o: pipe.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./memlayout.h:12:#define V2P(a) (((uint) (a)) - KERNBASE)
./memlayout.h:15:#define V2P_WO(x) ((x) - KERNBASE)    // same as V2P, but without casts
./trap.c:24:// ----------------------------------------------------------------->
./trap.c:51:  if(tf->trapno == T_SYSCALL){
./trap.c:52:    if(myproc()->killed)
./trap.c:54:    myproc()->tf = tf;
./trap.c:56:    if(myproc()->killed)
./trap.c:61:  switch(tf->trapno){
./trap.c:89:            cpuid(), tf->cs, tf->eip);
./trap.c:97:    if(va >= curproc->sz || !curproc->pgdir)
./trap.c:100:    pte_t *pte = walkpgdir(curproc->pgdir, (void*)va, 0);
./trap.c:102:      handle_pgfault(curproc->pgdir, va);
./trap.c:105:      curproc->killed = 1;
./trap.c:111:    if(myproc() == 0 || (tf->cs&3) == 0){
./trap.c:114:              tf->trapno, cpuid(), tf->eip, rcr2());
./trap.c:118:    //------------------ I am commenting the below part ( origional ) for no exit in control + G part ----------------------------------->
./trap.c:124:            "eip 0x%x addr 0x%x--kill proc\n",myproc()->pid, myproc()->name, tf->trapno,tf->err, cpuid(), tf->eip, rcr2());
./trap.c:125:    myproc()->killed = 1;
./trap.c:128:  //------------------ I am commenting the above part ( origional ) for no exit in control + G part -------------------------------------->
./trap.c:131:  //---------------------------------------------------------------------------------------------------------------------->
./trap.c:134:if(myproc() && myproc()->pending_signals) {
./trap.c:135:  if(myproc()->pending_signals & (1 << (SIGCUSTOM - 1))) {
./trap.c:136:    if(myproc()->sighandler) {
./trap.c:137:    uint handler_addr = (uint)myproc()->sighandler;
./trap.c:140:                if ((tf->cs & 3) == DPL_USER) {
./trap.c:144:                    tf->eip = handler_addr;
./trap.c:147:                    myproc()->pending_signals &= ~(1 << (SIGCUSTOM - 1));
./trap.c:153:   //--------------------------------------------------- Control + I ------------------------------------------------------->
./trap.c:164:		if(p->pid >= 1 && (p->state == SLEEPING || p->state == RUNNING || p->state == RUNNABLE)) {
./trap.c:165:		  int num_pages = (p->sz + PGSIZE - 1) / PGSIZE;
./trap.c:166:		  cprintf("%d %d\n", p->pid, num_pages);
./trap.c:172:	//--------------------------------------------------- Control + I ------------------------------------------------------->
./trap.c:177:		if(p->pid == 2)
./trap.c:182:	if(myproc() && myproc()->pending_suspend) {
./trap.c:184:		myproc()->state = SUSPENDED;
./trap.c:185:		myproc()->pending_suspend = 0;
./trap.c:188:		// cprintf("pid : %d I am suspended \n",myproc()->pid);
./trap.c:192:	//--------------------------------------------------------------------------------------------------------------------->
./trap.c:209:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER){
./trap.c:215:  if(myproc() && myproc()->state == RUNNING &&
./trap.c:216:     tf->trapno == T_IRQ0+IRQ_TIMER)
./trap.c:220:  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
./mkfs.c:99:  // nblocks = FSSIZE - nmeta;
./mkfs.c:100:  nblocks = FSSIZE - nmeta - NSWAPBLOCKS;  // Subtract swap blocks
./mkfs.c:118:    nblocks = FSSIZE - nmeta - NSWAPBLOCKS;
./mkfs.c:119:    nbitmap = (nblocks + (BSIZE*8 - 1)) / (BSIZE*8); // ceil(nblocks/(BSIZE*8))
./mkfs.c:263:  // Old : Assumes the entire bitmap fits into a single block---------------------->
./mkfs.c:277:  // New : Handles multiple bitmap blocks (nbitmap > 1) -------------------------------------->
./mkfs.c:287:      used--;
./mkfs.c:322:      if(indirect[fbn - NDIRECT] == 0){
./mkfs.c:323:        indirect[fbn - NDIRECT] = xint(freeblock++);
./mkfs.c:326:      x = xint(indirect[fbn-NDIRECT]);
./mkfs.c:328:    n1 = min(n, (fbn + 1) * BSIZE - off);
./mkfs.c:330:    bcopy(p, buf + off - (fbn * BSIZE), n1);
./mkfs.c:332:    n -= n1;
./exec.d:1:exec.o: exec.c /usr/i686-linux-gnu/include/stdc-predef.h types.h param.h \
./test1.asm:2:_test1:     file format elf32-i386
./test1.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./test1.asm:36:  return fib(n - 1) + fib(n - 2);
./test1.asm:85:  94:	8d 78 ff             	lea    -0x1(%eax),%edi
./test1.asm:93:  ac:	89 5d b0             	mov    %ebx,-0x50(%ebp)
./test1.asm:94:  af:	39 7d b0             	cmp    %edi,-0x50(%ebp)
./test1.asm:101:  c8:	8d 4e ff             	lea    -0x1(%esi),%ecx
./test1.asm:102:  cb:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./test1.asm:104:  d0:	89 4d a8             	mov    %ecx,-0x58(%ebp)
./test1.asm:107:  d8:	89 5d e0             	mov    %ebx,-0x20(%ebp)
./test1.asm:109:  dd:	89 7d dc             	mov    %edi,-0x24(%ebp)
./test1.asm:111:  e2:	89 4d ac             	mov    %ecx,-0x54(%ebp)
./test1.asm:112:  e5:	89 75 d8             	mov    %esi,-0x28(%ebp)
./test1.asm:113:  e8:	39 75 ac             	cmp    %esi,-0x54(%ebp)
./test1.asm:116:  f4:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test1.asm:118:  f9:	89 75 d0             	mov    %esi,-0x30(%ebp)
./test1.asm:123: 109:	8d 47 ff             	lea    -0x1(%edi),%eax
./test1.asm:125: 10e:	89 5d cc             	mov    %ebx,-0x34(%ebp)
./test1.asm:127: 113:	89 45 a0             	mov    %eax,-0x60(%ebp)
./test1.asm:130: 11b:	89 7d c8             	mov    %edi,-0x38(%ebp)
./test1.asm:131: 11e:	89 4d a4             	mov    %ecx,-0x5c(%ebp)
./test1.asm:135: 127:	39 75 a4             	cmp    %esi,-0x5c(%ebp)
./test1.asm:144: 144:	8d 53 ff             	lea    -0x1(%ebx),%edx
./test1.asm:146: 149:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./test1.asm:147: 14c:	89 55 98             	mov    %edx,-0x68(%ebp)
./test1.asm:149: 152:	89 5d bc             	mov    %ebx,-0x44(%ebp)
./test1.asm:152: 159:	89 4d 9c             	mov    %ecx,-0x64(%ebp)
./test1.asm:154: 15e:	89 7d c0             	mov    %edi,-0x40(%ebp)
./test1.asm:156: 163:	39 4d 9c             	cmp    %ecx,-0x64(%ebp)
./test1.asm:160: 171:	89 55 b8             	mov    %edx,-0x48(%ebp)
./test1.asm:162: 176:	89 4d b4             	mov    %ecx,-0x4c(%ebp)
./test1.asm:169:  return fib(n - 1) + fib(n - 2);
./test1.asm:171: 189:	89 4d 90             	mov    %ecx,-0x70(%ebp)
./test1.asm:172: 18c:	89 55 94             	mov    %edx,-0x6c(%ebp)
./test1.asm:176:  return fib(n - 1) + fib(n - 2);
./test1.asm:180: 19b:	8b 55 94             	mov    -0x6c(%ebp),%edx
./test1.asm:181: 19e:	8b 4d 90             	mov    -0x70(%ebp),%ecx
./test1.asm:186: 1ac:	8d 43 fe             	lea    -0x2(%ebx),%eax
./test1.asm:194: 1c3:	8b 55 b8             	mov    -0x48(%ebp),%edx
./test1.asm:195: 1c6:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
./test1.asm:201: 1d7:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test1.asm:202: 1da:	8b 7d c0             	mov    -0x40(%ebp),%edi
./test1.asm:203: 1dd:	8b 5d bc             	mov    -0x44(%ebp),%ebx
./test1.asm:205: 1e3:	83 7d 98 01          	cmpl   $0x1,-0x68(%ebp)
./test1.asm:214: 204:	8b 5d cc             	mov    -0x34(%ebp),%ebx
./test1.asm:215: 207:	8b 7d c8             	mov    -0x38(%ebp),%edi
./test1.asm:217: 20d:	83 7d a0 01          	cmpl   $0x1,-0x60(%ebp)
./test1.asm:220: 21b:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test1.asm:221: 21e:	8b 75 d0             	mov    -0x30(%ebp),%esi
./test1.asm:226: 230:	8b 75 d8             	mov    -0x28(%ebp),%esi
./test1.asm:227: 233:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./test1.asm:228: 236:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./test1.asm:229: 239:	8b 7d dc             	mov    -0x24(%ebp),%edi
./test1.asm:231: 23f:	83 7d a8 01          	cmpl   $0x1,-0x58(%ebp)
./test1.asm:239: 25c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:256: 280:	39 75 a4             	cmp    %esi,-0x5c(%ebp)
./test1.asm:259: 28b:	8b 5d cc             	mov    -0x34(%ebp),%ebx
./test1.asm:260: 28e:	8b 7d c8             	mov    -0x38(%ebp),%edi
./test1.asm:266: 2a4:	8b 55 b8             	mov    -0x48(%ebp),%edx
./test1.asm:267: 2a7:	8b 4d b4             	mov    -0x4c(%ebp),%ecx
./test1.asm:271: 2b7:	39 4d 9c             	cmp    %ecx,-0x64(%ebp)
./test1.asm:274: 2c2:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test1.asm:275: 2c5:	8b 7d c0             	mov    -0x40(%ebp),%edi
./test1.asm:277: 2cb:	8b 5d bc             	mov    -0x44(%ebp),%ebx
./test1.asm:279: 2d3:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test1.asm:281: 2d8:	8b 75 d0             	mov    -0x30(%ebp),%esi
./test1.asm:286: 2eb:	39 75 ac             	cmp    %esi,-0x54(%ebp)
./test1.asm:288: 2f4:	8b 75 d8             	mov    -0x28(%ebp),%esi
./test1.asm:289: 2f7:	8b 5d e0             	mov    -0x20(%ebp),%ebx
./test1.asm:291: 2fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./test1.asm:292: 300:	8b 7d dc             	mov    -0x24(%ebp),%edi
./test1.asm:294: 306:	83 7d a8 01          	cmpl   $0x1,-0x58(%ebp)
./test1.asm:304: 32a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:314: 336:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:374: 38e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test1.asm:409:  return (uchar)*p - (uchar)*q;
./test1.asm:412: 3d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test1.asm:418:  return (uchar)*p - (uchar)*q;
./test1.asm:423: 3e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test1.asm:426:  return (uchar)*p - (uchar)*q;
./test1.asm:493: 442:	8b 7d fc             	mov    -0x4(%ebp),%edi
./test1.asm:550: 495:	8d 75 e7             	lea    -0x19(%ebp),%esi
./test1.asm:571: 4b4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./test1.asm:573: 4bb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./test1.asm:592: 4da:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:623:    return -1;
./test1.asm:639: 524:	8d 65 f8             	lea    -0x8(%ebp),%esp
./test1.asm:646:    return -1;
./test1.asm:667: 54a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./test1.asm:676:    n = n*10 + *s++ - '0';
./test1.asm:679: 566:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./test1.asm:682: 56d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./test1.asm:687: 575:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test1.asm:710:  while(n-- > 0)
./test1.asm:721:  while(n-- > 0)
./test1.asm:890:    x = -xx;
./test1.asm:894: 66d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./test1.asm:900:    x = -xx;
./test1.asm:909: 685:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./test1.asm:920: 6a2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./test1.asm:927: 6ae:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test1.asm:930:    buf[i++] = '-';
./test1.asm:931: 6b5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./test1.asm:933:  while(--i >= 0)
./test1.asm:935: 6bc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./test1.asm:936: 6bf:	8b 75 c0             	mov    -0x40(%ebp),%esi
./test1.asm:943: 6ce:	88 45 d7             	mov    %al,-0x29(%ebp)
./test1.asm:944: 6d1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./test1.asm:949:  while(--i >= 0)
./test1.asm:956: 6e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:996: 71e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./test1.asm:999: 728:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test1.asm:1010: 738:	8d 45 e7             	lea    -0x19(%ebp),%eax
./test1.asm:1011: 73b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test1.asm:1016: 747:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test1.asm:1048: 780:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:1058: 793:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test1.asm:1059: 796:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./test1.asm:1062: 79d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test1.asm:1066: 7a9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test1.asm:1068: 7ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test1.asm:1079: 7c0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test1.asm:1090: 7d9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./test1.asm:1096: 7e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./test1.asm:1100: 7ee:	89 45 d0             	mov    %eax,-0x30(%ebp)
./test1.asm:1111: 806:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test1.asm:1112: 809:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./test1.asm:1117: 813:	88 45 e7             	mov    %al,-0x19(%ebp)
./test1.asm:1131: 82c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./test1.asm:1135: 836:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test1.asm:1142: 847:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test1.asm:1145: 84d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test1.asm:1151: 855:	88 45 e7             	mov    %al,-0x19(%ebp)
./test1.asm:1158: 861:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./test1.asm:1166: 873:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test1.asm:1167: 876:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test1.asm:1186:  bp = (Header*)ap - 1;
./test1.asm:1187:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test1.asm:1195:  bp = (Header*)ap - 1;
./test1.asm:1196: 89e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./test1.asm:1197:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test1.asm:1199:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test1.asm:1201:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test1.asm:1206:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test1.asm:1210:  if(bp + bp->s.size == p->s.ptr){
./test1.asm:1211: 8b6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./test1.asm:1215:    bp->s.size += p->s.ptr->s.size;
./test1.asm:1216:    bp->s.ptr = p->s.ptr->s.ptr;
./test1.asm:1217: 8c0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./test1.asm:1219:    bp->s.ptr = p->s.ptr;
./test1.asm:1220:  if(p + p->s.size == bp){
./test1.asm:1225:    p->s.size += bp->s.size;
./test1.asm:1226:    p->s.ptr = bp->s.ptr;
./test1.asm:1229:    p->s.ptr = bp;
./test1.asm:1241:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test1.asm:1250:    bp->s.size += p->s.ptr->s.size;
./test1.asm:1252: 8f3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./test1.asm:1253:    bp->s.ptr = p->s.ptr->s.ptr;
./test1.asm:1256: 8fa:	89 53 f8             	mov    %edx,-0x8(%ebx)
./test1.asm:1257:  if(p + p->s.size == bp){
./test1.asm:1262:    p->s.size += bp->s.size;
./test1.asm:1263: 907:	03 53 fc             	add    -0x4(%ebx),%edx
./test1.asm:1266:    p->s.size += bp->s.size;
./test1.asm:1268:    p->s.ptr = bp->s.ptr;
./test1.asm:1269: 912:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./test1.asm:1295:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./test1.asm:1299:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./test1.asm:1309:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./test1.asm:1311:    if(p->s.size >= nunits){
./test1.asm:1323:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./test1.asm:1325:    if(p->s.size >= nunits){
./test1.asm:1329:        p->s.size = nunits;
./test1.asm:1342:  if(p == (char*)-1)
./test1.asm:1346:  hp->s.size = nu;
./test1.asm:1362: 9a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:1372:      if(p->s.size == nunits)
./test1.asm:1375:        p->s.size -= nunits;
./test1.asm:1378:        p += p->s.size;
./test1.asm:1380:        p->s.size = nunits;
./test1.asm:1385: 9c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test1.asm:1405:    if(p->s.size >= nunits){
./test1.asm:1409:        prevp->s.ptr = p->s.ptr;
./ln.d:1:ln.o: ln.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./buf.h:4:#include "sleeplock.h"  // <-- ADD THIS
./mp.d:1:mp.o: mp.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h mmu.h \
./test1.d:1:test1.o: test1.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./fs.c:3://   + Log: crash recovery for multi-step updates.
./fs.c:8:// This file contains the low-level file system manipulation
./fs.c:9:// routines.  The (higher-level) system call implementations
./fs.c:37:  memmove(sb, bp->data, sizeof(*sb));
./fs.c:48:  memset(bp->data, 0, BSIZE);
./fs.c:67:      if((bp->data[bi/8] & m) == 0){  // Is block free?
./fs.c:68:        bp->data[bi/8] |= m;  // Mark block in use.
./fs.c:90:  if((bp->data[bi/8] & m) == 0)
./fs.c:92:  bp->data[bi/8] &= ~m;
./fs.c:108:// The kernel keeps a cache of in-use inodes in memory
./fs.c:111:// inodes include book-keeping information that is
./fs.c:112:// not stored on disk: ip->ref and ip->valid.
./fs.c:114:// An inode and its in-memory representation go through a
./fs.c:119://   is non-zero. ialloc() allocates, and iput() frees if
./fs.c:123://   is free if ip->ref is zero. Otherwise ip->ref tracks
./fs.c:124://   the number of in-memory pointers to the entry (open
./fs.c:130://   cache entry is only correct when ip->valid is 1.
./fs.c:132://   the disk and sets ip->valid, while iput() clears
./fs.c:133://   ip->valid if ip->ref has fallen to zero.
./fs.c:142://   ... examine and modify ip->xxx ...
./fs.c:147:// get a long-term reference to an inode (as for an open file)
./fs.c:150:// pathname lookup. iget() increments ip->ref so that the inode
./fs.c:155:// multi-step atomic operations.
./fs.c:157:// The icache.lock spin-lock protects the allocation of icache
./fs.c:158:// entries. Since ip->ref indicates whether an entry is free,
./fs.c:159:// and ip->dev and ip->inum indicate which i-node an entry
./fs.c:162:// An ip->lock sleep-lock protects all ip-> fields other than ref,
./fs.c:163:// dev, and inum.  One must hold ip->lock in order to
./fs.c:164:// read or write that inode's ip->valid, ip->size, ip->type, &c.
./fs.c:203:    dip = (struct dinode*)bp->data + inum%IPB;
./fs.c:204:    if(dip->type == 0){  // a free inode
./fs.c:206:      dip->type = type;
./fs.c:216:// Copy a modified in-memory inode to disk.
./fs.c:217:// Must be called after every change to an ip->xxx field
./fs.c:218:// that lives on disk, since i-node cache is write-through.
./fs.c:219:// Caller must hold ip->lock.
./fs.c:226:  bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./fs.c:227:  dip = (struct dinode*)bp->data + ip->inum%IPB;
./fs.c:228:  dip->type = ip->type;
./fs.c:229:  dip->major = ip->major;
./fs.c:230:  dip->minor = ip->minor;
./fs.c:231:  dip->nlink = ip->nlink;
./fs.c:232:  dip->size = ip->size;
./fs.c:233:  memmove(dip->addrs, ip->addrs, sizeof(ip->addrs));
./fs.c:239:// and return the in-memory copy. Does not lock
./fs.c:251:    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
./fs.c:252:      ip->ref++;
./fs.c:256:    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
./fs.c:265:  ip->dev = dev;
./fs.c:266:  ip->inum = inum;
./fs.c:267:  ip->ref = 1;
./fs.c:268:  ip->valid = 0;
./fs.c:280:  ip->ref++;
./fs.c:293:  if(ip == 0 || ip->ref < 1)
./fs.c:296:  acquiresleep(&ip->lock);
./fs.c:298:  if(ip->valid == 0){
./fs.c:299:    bp = bread(ip->dev, IBLOCK(ip->inum, sb));
./fs.c:300:    dip = (struct dinode*)bp->data + ip->inum%IPB;
./fs.c:301:    ip->type = dip->type;
./fs.c:302:    ip->major = dip->major;
./fs.c:303:    ip->minor = dip->minor;
./fs.c:304:    ip->nlink = dip->nlink;
./fs.c:305:    ip->size = dip->size;
./fs.c:306:    memmove(ip->addrs, dip->addrs, sizeof(ip->addrs));
./fs.c:308:    ip->valid = 1;
./fs.c:309:    if(ip->type == 0)
./fs.c:318:  if(ip == 0 || !holdingsleep(&ip->lock) || ip->ref < 1)
./fs.c:321:  releasesleep(&ip->lock);
./fs.c:324:// Drop a reference to an in-memory inode.
./fs.c:334:  acquiresleep(&ip->lock);
./fs.c:335:  if(ip->valid && ip->nlink == 0){
./fs.c:337:    int r = ip->ref;
./fs.c:342:      ip->type = 0;
./fs.c:344:      ip->valid = 0;
./fs.c:347:  releasesleep(&ip->lock);
./fs.c:350:  ip->ref--;
./fs.c:367:// are listed in ip->addrs[].  The next NINDIRECT blocks are
./fs.c:368:// listed in block ip->addrs[NDIRECT].
./fs.c:379:    if((addr = ip->addrs[bn]) == 0)
./fs.c:380:      ip->addrs[bn] = addr = balloc(ip->dev);
./fs.c:383:  bn -= NDIRECT;
./fs.c:387:    if((addr = ip->addrs[NDIRECT]) == 0)
./fs.c:388:      ip->addrs[NDIRECT] = addr = balloc(ip->dev);
./fs.c:389:    bp = bread(ip->dev, addr);
./fs.c:390:    a = (uint*)bp->data;
./fs.c:392:      a[bn] = addr = balloc(ip->dev);
./fs.c:405:// and has no in-memory reference to it (is
./fs.c:415:    if(ip->addrs[i]){
./fs.c:416:      bfree(ip->dev, ip->addrs[i]);
./fs.c:417:      ip->addrs[i] = 0;
./fs.c:421:  if(ip->addrs[NDIRECT]){
./fs.c:422:    bp = bread(ip->dev, ip->addrs[NDIRECT]);
./fs.c:423:    a = (uint*)bp->data;
./fs.c:426:        bfree(ip->dev, a[j]);
./fs.c:429:    bfree(ip->dev, ip->addrs[NDIRECT]);
./fs.c:430:    ip->addrs[NDIRECT] = 0;
./fs.c:433:  ip->size = 0;
./fs.c:438:// Caller must hold ip->lock.
./fs.c:442:  st->dev = ip->dev;
./fs.c:443:  st->ino = ip->inum;
./fs.c:444:  st->type = ip->type;
./fs.c:445:  st->nlink = ip->nlink;
./fs.c:446:  st->size = ip->size;
./fs.c:451:// Caller must hold ip->lock.
./fs.c:458:  if(ip->type == T_DEV){
./fs.c:459:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
./fs.c:460:      return -1;
./fs.c:461:    return devsw[ip->major].read(ip, dst, n);
./fs.c:464:  if(off > ip->size || off + n < off)
./fs.c:465:    return -1;
./fs.c:466:  if(off + n > ip->size)
./fs.c:467:    n = ip->size - off;
./fs.c:470:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./fs.c:471:    m = min(n - tot, BSIZE - off%BSIZE);
./fs.c:472:    memmove(dst, bp->data + off%BSIZE, m);
./fs.c:480:// Caller must hold ip->lock.
./fs.c:487:  if(ip->type == T_DEV){
./fs.c:488:    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
./fs.c:489:      return -1;
./fs.c:490:    return devsw[ip->major].write(ip, src, n);
./fs.c:493:  if(off > ip->size || off + n < off)
./fs.c:494:    return -1;
./fs.c:496:    return -1;
./fs.c:499:    bp = bread(ip->dev, bmap(ip, off/BSIZE));
./fs.c:500:    m = min(n - tot, BSIZE - off%BSIZE);
./fs.c:501:    memmove(bp->data + off%BSIZE, src, m);
./fs.c:506:  if(n > 0 && off > ip->size){
./fs.c:507:    ip->size = off;
./fs.c:530:  if(dp->type != T_DIR)
./fs.c:533:  for(off = 0; off < dp->size; off += sizeof(de)){
./fs.c:543:      return iget(dp->dev, inum);
./fs.c:561:    return -1;
./fs.c:565:  for(off = 0; off < dp->size; off += sizeof(de)){
./fs.c:608:  len = path - s;
./fs.c:632:    ip = idup(myproc()->cwd);
./fs.c:636:    if(ip->type != T_DIR){
./vm.c:25:  c->gdt[SEG_KCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, 0);
./vm.c:26:  c->gdt[SEG_KDATA] = SEG(STA_W, 0, 0xffffffff, 0);
./vm.c:27:  c->gdt[SEG_UCODE] = SEG(STA_X|STA_R, 0, 0xffffffff, DPL_USER);
./vm.c:28:  c->gdt[SEG_UDATA] = SEG(STA_W, 0, 0xffffffff, DPL_USER);
./vm.c:29:  lgdt(c->gdt, sizeof(c->gdt));
./vm.c:59:// be page-aligned.
./vm.c:67:  last = (char*)PGROUNDDOWN(((uint)va) + size - 1);
./vm.c:70:      return -1;
./vm.c:130:    if(mappages(pgdir, k->virt, k->phys_end - k->phys_start,
./vm.c:131:                (uint)k->phys_start, k->perm) < 0) {
./vm.c:147:// Switch h/w page table register to the kernel-only page table,
./vm.c:161:  if(p->kstack == 0)
./vm.c:163:  if(p->pgdir == 0)
./vm.c:167:  mycpu()->gdt[SEG_TSS] = SEG16(STS_T32A, &mycpu()->ts,
./vm.c:168:                                sizeof(mycpu()->ts)-1, 0);
./vm.c:169:  mycpu()->gdt[SEG_TSS].s = 0;
./vm.c:170:  mycpu()->ts.ss0 = SEG_KDATA << 3;
./vm.c:171:  mycpu()->ts.esp0 = (uint)p->kstack + KSTACKSIZE;
./vm.c:174:  mycpu()->ts.iomb = (ushort) 0xFFFF;
./vm.c:176:  lcr3(V2P(p->pgdir));  // switch to process's address space
./vm.c:195:// Load a program segment into pgdir.  addr must be page-aligned
./vm.c:209:    if(sz - i < PGSIZE)
./vm.c:210:      n = sz - i;
./vm.c:214:      return -1;
./vm.c:250:      p->rss++;
./vm.c:257:// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
./vm.c:273:      a = PGADDR(PDX(a) + 1, 0, 0) - PGSIZE;
./vm.c:285:      if(p->rss > 0)  // Prevent underflow
./vm.c:286:        p->rss--;
./vm.c:352:    //acquire(&np->lock);
./vm.c:353:    np->rss++;
./vm.c:354:    //release(&np->lock);
./vm.c:392:      return -1;
./vm.c:393:    n = PGSIZE - (va - va0);
./vm.c:396:    memmove(pa0 + (va - va0), buf, n);
./vm.c:397:    len -= n;
./ioapic.d:1:ioapic.o: ioapic.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./zombie.d:1:zombie.o: zombie.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./kbd.c:17:    return -1;
./kbd.c:39:      c += 'A' - 'a';
./kbd.c:41:      c += 'a' - 'A';
./trap.d:1:trap.o: trap.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./runoff.list:59:# low-level hardware
./runoff.list:69:# user-level
./param.h:2:#define KSTACKSIZE 4096  // size of per-process kernel stack
./param.h:6:#define NINODE       50  // maximum number of active i-nodes
./param.h:11:#define LOGSIZE      (MAXOPBLOCKS*3)  // max data blocks in on-disk log
./spinp:3:if [ $# != 1 ] || [ ! -f "$1" ]; then
./spinp:8:rm -f $1.trail
./spinp:9:spin -a $1 || exit 1
./spinp:10:cc -DSAFETY -DREACH -DMEMLIM=500 -o pan pan.c
./spinp:11:pan -i
./spinp:13:if [ -f $1.trail ]; then
./spinp:14:	spin -t -p $1
./main.c:58:  xchg(&(mycpu()->started), 1); // tell startothers() we're up
./main.c:64:// Start the non-boot (AP) processors.
./main.c:87:    *(void**)(code-4) = stack + KSTACKSIZE;
./main.c:88:    *(void(**)(void))(code-8) = mpenter;
./main.c:89:    *(int**)(code-12) = (void *) V2P(entrypgdir);
./main.c:91:    lapicstartap(c->apicid, V2P(code));
./main.c:94:    while(c->started == 0)
./runoff1:5:if($ARGV[0] eq "-v") {
./runoff1:9:if($ARGV[0] eq "-n") {
./runoff1:14:$n = int(($n+49)/50)*50 - 1;
./runoff1:54:			if($lines[$j] =~ /PAGEBREAK:\s*([0-9]+)/){
./runoff1:79:		if($breakbefore - $i < 50 - $breaksize && $lastblank > $breakbefore && $lastblank >= $i+50 - 5){
./runoff1:88:		if($breakbefore - $i < 50 - $breaksize && $breakbefore != @lines){
./entryother.S:5:# Each non-boot CPU ("AP") is started up in response to a STARTUP
./entryother.S:6:# IPI from the boot CPU.  Section B.4.2 of the Multi-Processor
./entryother.S:8:# set to XY00:0000, where XY is an 8-bit value sent with the
./entryother.S:9:# STARTUP. Thus this code must start at a 4096-byte boundary.
./entryother.S:16:# a newly allocated per-core stack in start-4,the address of the
./entryother.S:17:# place to jump to (mpenter) in start-8, and the physical address
./entryother.S:18:# of entrypgdir in start-12.
./entryother.S:41:  # Complete the transition to 32-bit protected mode by using a long jmp
./entryother.S:47:.code32  # Tell assembler to generate 32-bit code now.
./entryother.S:49:  # Set up the protected-mode data segment registers
./entryother.S:51:  movw    %ax, %ds                # -> DS: Data Segment
./entryother.S:52:  movw    %ax, %es                # -> ES: Extra Segment
./entryother.S:53:  movw    %ax, %ss                # -> SS: Stack Segment
./entryother.S:55:  movw    %ax, %fs                # -> FS
./entryother.S:56:  movw    %ax, %gs                # -> GS
./entryother.S:63:  movl    (start-12), %eax
./entryother.S:71:  movl    (start-4), %esp
./entryother.S:73:  call	 *(start-8)
./entryother.S:91:  .word   (gdtdesc - gdt - 1)
./dot-bochsrc:12:# version is only available when you use "--with-wx" on the configure 
./dot-bochsrc:27:# different platforms.  If you run configure with multiple --with-* options, 
./dot-bochsrc:37:#   macintosh      use MacOS pre-10
./dot-bochsrc:69:# distribution called BIOS-bochs-latest. The ROM BIOS is usually loaded
./dot-bochsrc:77:romimage: file=$BXSHARE/BIOS-bochs-latest
./dot-bochsrc:83:# This defines cpu-related parameters inside Bochs:
./dot-bochsrc:93:#  --enable-show-ips option enabled, to find your workstation's capability.
./dot-bochsrc:97:#  IPS is used to calibrate many time-dependent events within the bochs 
./dot-bochsrc:107:#  650Mhz Athlon K-7 with Linux 2.4.4/egcs-2.91.66  2 to  2.5 Mips
./dot-bochsrc:108:#  400Mhz Pentium II with Linux 2.0.36/egcs-1.0.3   1 to  1.8 Mips
./dot-bochsrc:126:# OPTROMIMAGE[1-4]:
./dot-bochsrc:128:# read-only area, typically between C8000 and EFFFF. These optional
./dot-bochsrc:130:# F0000-FFFFF) and the videobios (located at C0000-C7FFF).
./dot-bochsrc:150:#vgaromimage: file=bios/VGABIOS-elpin-2.40
./dot-bochsrc:151:vgaromimage: file=$BXSHARE/VGABIOS-lgpl-latest
./dot-bochsrc:152:#vgaromimage: file=bios/VGABIOS-lgpl-latest-cirrus
./dot-bochsrc:205:# ata[0-3]: enabled=[0|1], ioaddr1=addr, ioaddr2=addr, irq=number
./dot-bochsrc:224:# ATA[0-3]-MASTER, ATA[0-3]-SLAVE
./dot-bochsrc:253:# bximage geometry autodetection can be used (cylinders=0 -> cylinders are
./dot-bochsrc:263:#   ata0-master: type=disk, mode=flat, path=10M.sample, cylinders=306, heads=4, spt=17
./dot-bochsrc:264:#   ata0-slave:  type=disk, mode=flat, path=20M.sample, cylinders=615, heads=4, spt=17
./dot-bochsrc:265:#   ata1-master: type=disk, mode=flat, path=30M.sample, cylinders=615, heads=6, spt=17
./dot-bochsrc:266:#   ata1-slave:  type=disk, mode=flat, path=46M.sample, cylinders=940, heads=6, spt=17
./dot-bochsrc:267:#   ata2-master: type=disk, mode=flat, path=62M.sample, cylinders=940, heads=8, spt=17
./dot-bochsrc:268:#   ata2-slave:  type=disk, mode=flat, path=112M.sample, cylinders=900, heads=15, spt=17
./dot-bochsrc:269:#   ata3-master: type=disk, mode=flat, path=483M.sample, cylinders=1024, heads=15, spt=63
./dot-bochsrc:270:#   ata3-slave:  type=cdrom, path=iso.sample, status=inserted
./dot-bochsrc:272:ata0-master: type=disk, mode=flat, path="xv6.img", cylinders=100, heads=10, spt=10
./dot-bochsrc:273:ata0-slave: type=disk, mode=flat, path="fs.img", cylinders=1024, heads=1, spt=1
./dot-bochsrc:274:#ata0-slave: type=cdrom, path=D:, status=inserted
./dot-bochsrc:275:#ata0-slave: type=cdrom, path=/dev/cdrom, status=inserted
./dot-bochsrc:276:#ata0-slave: type=cdrom, path="drive", status=inserted
./dot-bochsrc:277:#ata0-slave: type=cdrom, path=/dev/rcd0d, status=inserted 
./dot-bochsrc:342:# '-' the output is written to the console. If you really don't want it,
./dot-bochsrc:363:#   logprefix: %t-%e-@%i-%d
./dot-bochsrc:399:# If you really don't want it, make it /dev/null or '-'. :^(
./dot-bochsrc:406:debugger_log: -
./dot-bochsrc:419:# specified as the 'dev' parameter), 'raw' (use the real serial port - under
./dot-bochsrc:420:# construction for win32), 'mouse' (standard serial mouse - requires
./dot-bochsrc:478:#      non-continuous sound.  750000 is usually a good value.  This needs a
./dot-bochsrc:491:# of emulated instructions-per-second your workstation can do, for this
./dot-bochsrc:540:# 'mode=mouse') and 'usb' (3-button mouse - one of the USB ports must be
./dot-bochsrc:541:# connected with the 'mouse' device - requires PCI and USB support).
./dot-bochsrc:553:#                   non-shared colormap.  This colormap will be used
./dot-bochsrc:609:#   vnet: ARP, ICMP-echo(ping), DHCP and read/write TFTP are simulated.
./dot-bochsrc:633:#   keyboard_mapping: enabled=1, map=gui/keymaps/x11-pc-de.map
./dot-bochsrc:642:# exception is french macs, that do have a "at"-like keyboard.
./dot-bochsrc:653:# 3 key names (listed below) separated with a '-' character. The old-style
./dot-bochsrc:654:# syntax (without the '-') still works for the key combinations supported
./dot-bochsrc:662:#   user_shortcut: keys=ctrl-alt-del
./dot-bochsrc:664:#user_shortcut: keys=ctrl-alt-del
./dot-bochsrc:685:# have a 3-button USB mouse.
./dot-bochsrc:712:#-------------------------
./dot-bochsrc:714:#-------------------------
./dot-bochsrc:735:# vgaromimage: :bios:VGABIOS-elpin-2.40
./dot-bochsrc:736:# romimage: file=:bios:BIOS-bochs-latest, address=0xf0000
./pageswap.d:1:pageswap.o: pageswap.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./mkdir.asm:2:_mkdir:     file format elf32-i386
./mkdir.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./mkdir.asm:108:  9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./mkdir.asm:143:  return (uchar)*p - (uchar)*q;
./mkdir.asm:146:  e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./mkdir.asm:152:  return (uchar)*p - (uchar)*q;
./mkdir.asm:157:  f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./mkdir.asm:160:  return (uchar)*p - (uchar)*q;
./mkdir.asm:227: 152:	8b 7d fc             	mov    -0x4(%ebp),%edi
./mkdir.asm:284: 1a5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./mkdir.asm:305: 1c4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./mkdir.asm:307: 1cb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./mkdir.asm:326: 1ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
./mkdir.asm:357:    return -1;
./mkdir.asm:373: 234:	8d 65 f8             	lea    -0x8(%ebp),%esp
./mkdir.asm:380:    return -1;
./mkdir.asm:401: 25a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./mkdir.asm:410:    n = n*10 + *s++ - '0';
./mkdir.asm:413: 276:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./mkdir.asm:416: 27d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./mkdir.asm:421: 285:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./mkdir.asm:444:  while(n-- > 0)
./mkdir.asm:455:  while(n-- > 0)
./mkdir.asm:624:    x = -xx;
./mkdir.asm:628: 37d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./mkdir.asm:634:    x = -xx;
./mkdir.asm:643: 395:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./mkdir.asm:654: 3b2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./mkdir.asm:661: 3be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./mkdir.asm:664:    buf[i++] = '-';
./mkdir.asm:665: 3c5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./mkdir.asm:667:  while(--i >= 0)
./mkdir.asm:669: 3cc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./mkdir.asm:670: 3cf:	8b 75 c0             	mov    -0x40(%ebp),%esi
./mkdir.asm:677: 3de:	88 45 d7             	mov    %al,-0x29(%ebp)
./mkdir.asm:678: 3e1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./mkdir.asm:683:  while(--i >= 0)
./mkdir.asm:690: 3f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./mkdir.asm:730: 42e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./mkdir.asm:733: 438:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./mkdir.asm:744: 448:	8d 45 e7             	lea    -0x19(%ebp),%eax
./mkdir.asm:745: 44b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./mkdir.asm:750: 457:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./mkdir.asm:782: 490:	8d 65 f4             	lea    -0xc(%ebp),%esp
./mkdir.asm:792: 4a3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./mkdir.asm:793: 4a6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./mkdir.asm:796: 4ad:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./mkdir.asm:800: 4b9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./mkdir.asm:802: 4be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./mkdir.asm:813: 4d0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./mkdir.asm:824: 4e9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./mkdir.asm:830: 4f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./mkdir.asm:834: 4fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
./mkdir.asm:845: 516:	8d 55 e7             	lea    -0x19(%ebp),%edx
./mkdir.asm:846: 519:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./mkdir.asm:851: 523:	88 45 e7             	mov    %al,-0x19(%ebp)
./mkdir.asm:865: 53c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./mkdir.asm:869: 546:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./mkdir.asm:876: 557:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./mkdir.asm:879: 55d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./mkdir.asm:885: 565:	88 45 e7             	mov    %al,-0x19(%ebp)
./mkdir.asm:892: 571:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./mkdir.asm:900: 583:	88 5d e7             	mov    %bl,-0x19(%ebp)
./mkdir.asm:901: 586:	8d 55 e7             	lea    -0x19(%ebp),%edx
./mkdir.asm:920:  bp = (Header*)ap - 1;
./mkdir.asm:921:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./mkdir.asm:929:  bp = (Header*)ap - 1;
./mkdir.asm:930: 5ae:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./mkdir.asm:931:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./mkdir.asm:933:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./mkdir.asm:935:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./mkdir.asm:940:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./mkdir.asm:944:  if(bp + bp->s.size == p->s.ptr){
./mkdir.asm:945: 5c6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./mkdir.asm:949:    bp->s.size += p->s.ptr->s.size;
./mkdir.asm:950:    bp->s.ptr = p->s.ptr->s.ptr;
./mkdir.asm:951: 5d0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./mkdir.asm:953:    bp->s.ptr = p->s.ptr;
./mkdir.asm:954:  if(p + p->s.size == bp){
./mkdir.asm:959:    p->s.size += bp->s.size;
./mkdir.asm:960:    p->s.ptr = bp->s.ptr;
./mkdir.asm:963:    p->s.ptr = bp;
./mkdir.asm:975:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./mkdir.asm:984:    bp->s.size += p->s.ptr->s.size;
./mkdir.asm:986: 603:	89 73 fc             	mov    %esi,-0x4(%ebx)
./mkdir.asm:987:    bp->s.ptr = p->s.ptr->s.ptr;
./mkdir.asm:990: 60a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./mkdir.asm:991:  if(p + p->s.size == bp){
./mkdir.asm:996:    p->s.size += bp->s.size;
./mkdir.asm:997: 617:	03 53 fc             	add    -0x4(%ebx),%edx
./mkdir.asm:1000:    p->s.size += bp->s.size;
./mkdir.asm:1002:    p->s.ptr = bp->s.ptr;
./mkdir.asm:1003: 622:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./mkdir.asm:1029:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./mkdir.asm:1033:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./mkdir.asm:1043:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./mkdir.asm:1045:    if(p->s.size >= nunits){
./mkdir.asm:1057:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./mkdir.asm:1059:    if(p->s.size >= nunits){
./mkdir.asm:1063:        p->s.size = nunits;
./mkdir.asm:1076:  if(p == (char*)-1)
./mkdir.asm:1080:  hp->s.size = nu;
./mkdir.asm:1096: 6b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./mkdir.asm:1106:      if(p->s.size == nunits)
./mkdir.asm:1109:        p->s.size -= nunits;
./mkdir.asm:1112:        p += p->s.size;
./mkdir.asm:1114:        p->s.size = nunits;
./mkdir.asm:1119: 6d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./mkdir.asm:1139:    if(p->s.size >= nunits){
./mkdir.asm:1143:        prevp->s.ptr = p->s.ptr;
./printpcs:6:for p in i386-jos-elf-addr2line addr2line; do
./printpcs:8:       $p -h 2>&1 | grep -q '\belf32-i386\b'; then
./printpcs:13:# Enable as much pretty-printing as this addr2line can do
./printpcs:14:$p $($p -h | grep ' -[aipsf] ' | awk '{print $1}') -e kernel "$@"
./grep.asm:2:_grep:     file format elf32-i386
./grep.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./grep.asm:26:  19:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./grep.asm:41:  27:	83 7d e4 02          	cmpl   $0x2,-0x1c(%ebp)
./grep.asm:49:  30:	89 45 e0             	mov    %eax,-0x20(%ebp)
./grep.asm:67:  4a:	ff 75 e0             	push   -0x20(%ebp)
./grep.asm:74:  5d:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
./grep.asm:221: 164:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:234: 175:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:263: 1ab:	80 7e ff 00          	cmpb   $0x0,-0x1(%esi)
./grep.asm:276: 1c7:	8d 65 f8             	lea    -0x8(%ebp),%esp
./grep.asm:286: 1d6:	8d 65 f8             	lea    -0x8(%ebp),%esp
./grep.asm:308: 1fe:	89 7d e0             	mov    %edi,-0x20(%ebp)
./grep.asm:311: 204:	89 45 dc             	mov    %eax,-0x24(%ebp)
./grep.asm:315:  while((n = read(fd, buf+m, sizeof(buf)-m-1)) > 0){
./grep.asm:316: 210:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./grep.asm:329: 238:	01 45 e0             	add    %eax,-0x20(%ebp)
./grep.asm:330: 23b:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./grep.asm:350: 270:	89 7d e4             	mov    %edi,-0x1c(%ebp)
./grep.asm:358: 283:	80 7f ff 00          	cmpb   $0x0,-0x1(%edi)
./grep.asm:368:        write(1, p, q+1 - p);
./grep.asm:369: 29a:	8b 7d e4             	mov    -0x1c(%ebp),%edi
./grep.asm:376:        write(1, p, q+1 - p);
./grep.asm:392: 2cb:	89 55 e4             	mov    %edx,-0x1c(%ebp)
./grep.asm:394: 2cf:	ff 75 dc             	push   -0x24(%ebp)
./grep.asm:396:        write(1, p, q+1 - p);
./grep.asm:397: 2d7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./grep.asm:400:        write(1, p, q+1 - p);
./grep.asm:405:        write(1, p, q+1 - p);
./grep.asm:414: 2fa:	8b 45 e0             	mov    -0x20(%ebp),%eax
./grep.asm:417:      m -= p - buf;
./grep.asm:421:      m -= p - buf;
./grep.asm:423: 30f:	29 45 e0             	sub    %eax,-0x20(%ebp)
./grep.asm:424: 312:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./grep.asm:433: 329:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
./grep.asm:436: 335:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:474: 37c:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:481: 388:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:525: 3be:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./grep.asm:560:  return (uchar)*p - (uchar)*q;
./grep.asm:563: 401:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./grep.asm:569:  return (uchar)*p - (uchar)*q;
./grep.asm:574: 418:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./grep.asm:577:  return (uchar)*p - (uchar)*q;
./grep.asm:644: 472:	8b 7d fc             	mov    -0x4(%ebp),%edi
./grep.asm:701: 4c5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./grep.asm:722: 4e4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./grep.asm:724: 4eb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./grep.asm:743: 50a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:774:    return -1;
./grep.asm:790: 554:	8d 65 f8             	lea    -0x8(%ebp),%esp
./grep.asm:797:    return -1;
./grep.asm:818: 57a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./grep.asm:827:    n = n*10 + *s++ - '0';
./grep.asm:830: 596:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./grep.asm:833: 59d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./grep.asm:838: 5a5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./grep.asm:861:  while(n-- > 0)
./grep.asm:872:  while(n-- > 0)
./grep.asm:1041:    x = -xx;
./grep.asm:1045: 69d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./grep.asm:1051:    x = -xx;
./grep.asm:1060: 6b5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./grep.asm:1071: 6d2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./grep.asm:1078: 6de:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./grep.asm:1081:    buf[i++] = '-';
./grep.asm:1082: 6e5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./grep.asm:1084:  while(--i >= 0)
./grep.asm:1086: 6ec:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./grep.asm:1087: 6ef:	8b 75 c0             	mov    -0x40(%ebp),%esi
./grep.asm:1094: 6fe:	88 45 d7             	mov    %al,-0x29(%ebp)
./grep.asm:1095: 701:	8d 45 d7             	lea    -0x29(%ebp),%eax
./grep.asm:1100:  while(--i >= 0)
./grep.asm:1107: 719:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:1147: 74e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./grep.asm:1150: 758:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./grep.asm:1161: 768:	8d 45 e7             	lea    -0x19(%ebp),%eax
./grep.asm:1162: 76b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./grep.asm:1167: 777:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./grep.asm:1199: 7b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:1209: 7c3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./grep.asm:1210: 7c6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./grep.asm:1213: 7cd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./grep.asm:1217: 7d9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./grep.asm:1219: 7de:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./grep.asm:1230: 7f0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./grep.asm:1241: 809:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./grep.asm:1247: 816:	8b 45 d0             	mov    -0x30(%ebp),%eax
./grep.asm:1251: 81e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./grep.asm:1262: 836:	8d 55 e7             	lea    -0x19(%ebp),%edx
./grep.asm:1263: 839:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./grep.asm:1268: 843:	88 45 e7             	mov    %al,-0x19(%ebp)
./grep.asm:1282: 85c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./grep.asm:1286: 866:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./grep.asm:1293: 877:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./grep.asm:1296: 87d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./grep.asm:1302: 885:	88 45 e7             	mov    %al,-0x19(%ebp)
./grep.asm:1309: 891:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./grep.asm:1317: 8a3:	88 5d e7             	mov    %bl,-0x19(%ebp)
./grep.asm:1318: 8a6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./grep.asm:1337:  bp = (Header*)ap - 1;
./grep.asm:1338:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./grep.asm:1346:  bp = (Header*)ap - 1;
./grep.asm:1347: 8ce:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./grep.asm:1348:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./grep.asm:1350:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./grep.asm:1352:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./grep.asm:1357:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./grep.asm:1361:  if(bp + bp->s.size == p->s.ptr){
./grep.asm:1362: 8e6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./grep.asm:1366:    bp->s.size += p->s.ptr->s.size;
./grep.asm:1367:    bp->s.ptr = p->s.ptr->s.ptr;
./grep.asm:1368: 8f0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./grep.asm:1370:    bp->s.ptr = p->s.ptr;
./grep.asm:1371:  if(p + p->s.size == bp){
./grep.asm:1376:    p->s.size += bp->s.size;
./grep.asm:1377:    p->s.ptr = bp->s.ptr;
./grep.asm:1380:    p->s.ptr = bp;
./grep.asm:1392:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./grep.asm:1401:    bp->s.size += p->s.ptr->s.size;
./grep.asm:1403: 923:	89 73 fc             	mov    %esi,-0x4(%ebx)
./grep.asm:1404:    bp->s.ptr = p->s.ptr->s.ptr;
./grep.asm:1407: 92a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./grep.asm:1408:  if(p + p->s.size == bp){
./grep.asm:1413:    p->s.size += bp->s.size;
./grep.asm:1414: 937:	03 53 fc             	add    -0x4(%ebx),%edx
./grep.asm:1417:    p->s.size += bp->s.size;
./grep.asm:1419:    p->s.ptr = bp->s.ptr;
./grep.asm:1420: 942:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./grep.asm:1446:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./grep.asm:1450:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./grep.asm:1460:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./grep.asm:1462:    if(p->s.size >= nunits){
./grep.asm:1474:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./grep.asm:1476:    if(p->s.size >= nunits){
./grep.asm:1480:        p->s.size = nunits;
./grep.asm:1493:  if(p == (char*)-1)
./grep.asm:1497:  hp->s.size = nu;
./grep.asm:1513: 9d0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:1523:      if(p->s.size == nunits)
./grep.asm:1526:        p->s.size -= nunits;
./grep.asm:1529:        p += p->s.size;
./grep.asm:1531:        p->s.size = nunits;
./grep.asm:1536: 9f5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./grep.asm:1556:    if(p->s.size >= nunits){
./grep.asm:1560:        prevp->s.ptr = p->s.ptr;
./kbd.h:31:// C('A') == Control-A
./kbd.h:32:#define C(x) (x - '@')
./kbd.h:54:  '7',  '8',  '9',  '0',  '-',  '=',  '\b', '\t',
./kbd.h:62:  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
./kbd.h:84:  '8',  '9',  '-',  '4',  '5',  '6',  '+',  '1',
./README:2:our efforts to the RISC-V version
./README:3:(https://github.com/mit-pdos/xv6-riscv.git)
./README:5:xv6 is a re-implementation of Dennis Ritchie's and Ken Thompson's Unix
./README:7:but is implemented for a modern x86-based multiprocessor using ANSI C.
./README:12:to Peer Communications; ISBN: 1-57398-013-7; 1st edition (June 14,
./README:14:provides pointers to on-line resources for v6.
./README:27:Boyd-Wickizer, Anton Burtsev, Cody Cutler, Mike CAT, Tej Chajed, eyalz800,
./README:38:Copyright 2006-2018 Frans Kaashoek, Robert Morris, and Russ Cox.
./README:47:"make". On non-x86 or non-ELF machines (like OS X, even on x86), you
./README:48:will need to install a cross-compiler gcc suite capable of producing
./README:50:Then run "make TOOLPREFIX=i386-jos-elf-". Now install the QEMU PC
./proc.c:38:  return mycpu()-cpus;
./proc.c:69:  p = c->proc;
./proc.c:88:    if(p->state == UNUSED)
./proc.c:95:  p->state = EMBRYO;
./proc.c:96:  p->pid = nextpid++;
./proc.c:97:  p->ctrl_i_pending = 0;
./proc.c:102:  if((p->kstack = kalloc()) == 0){
./proc.c:103:    p->state = UNUSED;
./proc.c:106:  sp = p->kstack + KSTACKSIZE;
./proc.c:109:  sp -= sizeof *p->tf;
./proc.c:110:  p->tf = (struct trapframe*)sp;
./proc.c:114:  sp -= 4;
./proc.c:117:  sp -= sizeof *p->context;
./proc.c:118:  p->context = (struct context*)sp;
./proc.c:119:  memset(p->context, 0, sizeof *p->context);
./proc.c:120:  p->context->eip = (uint)forkret;
./proc.c:136:  if((p->pgdir = setupkvm()) == 0)
./proc.c:138:  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
./proc.c:139:  p->sz = PGSIZE;
./proc.c:140:  memset(p->tf, 0, sizeof(*p->tf));
./proc.c:141:  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
./proc.c:142:  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
./proc.c:143:  p->tf->es = p->tf->ds;
./proc.c:144:  p->tf->ss = p->tf->ds;
./proc.c:145:  p->tf->eflags = FL_IF;
./proc.c:146:  p->tf->esp = PGSIZE;
./proc.c:147:  p->tf->eip = 0;  // beginning of initcode.S
./proc.c:149:  safestrcpy(p->name, "initcode", sizeof(p->name));
./proc.c:150:  p->cwd = namei("/");
./proc.c:152:  // this assignment to p->state lets other cores
./proc.c:158:  p->state = RUNNABLE;
./proc.c:164:// Return 0 on success, -1 on failure.
./proc.c:171:  sz = curproc->sz;
./proc.c:173:    if((sz = allocuvm(curproc->pgdir, sz, sz + n,curproc)) == 0)
./proc.c:174:      return -1;
./proc.c:176:    if((sz = deallocuvm(curproc->pgdir, sz, sz + n,curproc)) == 0)
./proc.c:177:      return -1;
./proc.c:179:  curproc->sz = sz;
./proc.c:196:    return -1;
./proc.c:199:  np->rss = 0; // Initialize child RSS to 0
./proc.c:201:  if((np->pgdir = copyuvm(curproc->pgdir, curproc->sz , np)) == 0){
./proc.c:202:    kfree(np->kstack);
./proc.c:203:    np->kstack = 0;
./proc.c:204:    np->state = UNUSED;
./proc.c:205:    return -1;
./proc.c:207:  np->sz = curproc->sz;
./proc.c:208:  np->parent = curproc;
./proc.c:209:  *np->tf = *curproc->tf;
./proc.c:212:  np->tf->eax = 0;
./proc.c:215:    if(curproc->ofile[i])
./proc.c:216:      np->ofile[i] = filedup(curproc->ofile[i]);
./proc.c:217:  np->cwd = idup(curproc->cwd);
./proc.c:219:  safestrcpy(np->name, curproc->name, sizeof(curproc->name));
./proc.c:221:  pid = np->pid;
./proc.c:225:  np->state = RUNNABLE;
./proc.c:248:    if(curproc->ofile[fd]){
./proc.c:249:      fileclose(curproc->ofile[fd]);
./proc.c:250:      curproc->ofile[fd] = 0;
./proc.c:255:  iput(curproc->cwd);
./proc.c:257:  curproc->cwd = 0;
./proc.c:260:  if(curproc->pgdir) {
./proc.c:262:    deallocuvm(curproc->pgdir, 0, curproc->sz, curproc);
./proc.c:265:    for(a = 0; a < curproc->sz; a += PGSIZE) {
./proc.c:266:      pte_t *pte = walkpgdir(curproc->pgdir, (void*)a, 0);
./proc.c:275:    curproc->rss = 0;
./proc.c:281:  wakeup1(curproc->parent);
./proc.c:285:    if(p->parent == curproc){
./proc.c:286:      p->parent = initproc;
./proc.c:287:      if(p->state == ZOMBIE)
./proc.c:293:  curproc->state = ZOMBIE;
./proc.c:299:// Return -1 if this process has no children.
./proc.c:312:      if(p->parent != curproc)
./proc.c:315:      if(p->state == ZOMBIE){
./proc.c:317:        pid = p->pid;
./proc.c:318:        kfree(p->kstack);
./proc.c:319:        p->kstack = 0;
./proc.c:320:        freevm(p->pgdir,p);
./proc.c:321:        p->pid = 0;
./proc.c:322:        p->parent = 0;
./proc.c:323:        p->name[0] = 0;
./proc.c:324:        p->killed = 0;
./proc.c:325:        p->state = UNUSED;
./proc.c:332:    if(!havekids || curproc->killed){
./proc.c:334:      return -1;
./proc.c:338:    sleep(curproc, &ptable.lock);  //DOC: wait-sleep
./proc.c:343:// Per-CPU process scheduler.
./proc.c:346://  - choose a process to run
./proc.c:347://  - swtch to start running that process
./proc.c:348://  - eventually that process transfers control
./proc.c:355:  c->proc = 0;
./proc.c:366:	  //  < ------------------------------------ FOR DEBUGGING ------------------------------------------------------>
./proc.c:367:	  // if(myval == 1 && (p->pid == 2 || p->state == SUSPENDED)){
./proc.c:368:	  //  cprintf("pid : %d . state : %s , cpu : %d\n", p->pid,states[p->state],cpuid());
./proc.c:371:	  //  < ------------------------------------ FOR DEBUGGING ------------------------------------------------------>
./proc.c:373:      if(p->state != RUNNABLE)
./proc.c:380:      // cprintf("pid : %d . cpu : %d , ENTERING CPU \n", p->pid,cpuid());
./proc.c:381:      c->proc = p;
./proc.c:383:      p->state = RUNNING;
./proc.c:385:      swtch(&(c->scheduler), p->context);
./proc.c:389:      // It should have changed its p->state before coming back.
./proc.c:390:      c->proc = 0;
./proc.c:392:      // cprintf("pid : %d . cpu : %d , LEAVING CPU \n", p->pid,cpuid());
./proc.c:401:// and have changed proc->state. Saves and restores
./proc.c:404:// be proc->intena and proc->ncli, but that would
./proc.c:418:  if(mycpu()->ncli != 1)
./proc.c:420:  if(p->state == RUNNING)
./proc.c:424:  intena = mycpu()->intena;
./proc.c:425:  swtch(&p->context, mycpu()->scheduler);
./proc.c:426:  mycpu()->intena = intena;
./proc.c:443:   //  < ------------------------------------ FOR DEBUGGING ------------------------------------------------------>
./proc.c:445:  //cprintf("pid : %d , parent id : %d , state : %s , cpu : %d\n",myproc()->pid,myproc()->parent->pid,states[myproc()->state],cpuid());
./proc.c:447:  //  < ------------------------------------ FOR DEBUGGING ------------------------------------------------------>
./proc.c:454:  if(myproc()->state == SUSPENDED){
./proc.c:456:	 myval = 1;  // ----------------------------------------------------->> So that i can identify the suspended mode 
./proc.c:463:	  myproc()->state = RUNNABLE;
./proc.c:504:  // change p->state and then call sched.
./proc.c:514:  p->chan = chan;
./proc.c:515:  p->state = SLEEPING;
./proc.c:520:  p->chan = 0;
./proc.c:538:    if(p->state == SLEEPING && p->chan == chan)
./proc.c:539:      p->state = RUNNABLE;
./proc.c:561:    if(p->pid == pid){
./proc.c:562:      p->killed = 1;
./proc.c:564:      if(p->state == SLEEPING)
./proc.c:565:        p->state = RUNNABLE;
./proc.c:571:  return -1;
./proc.c:596:    if(p->state == UNUSED)
./proc.c:598:    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
./proc.c:599:      state = states[p->state];
./proc.c:602:    cprintf("%d %s %s", p->pid, state, p->name);
./proc.c:603:    if(p->state == SLEEPING){
./proc.c:604:      getcallerpcs((uint*)p->context->ebp+2, pc);
./proc.c:620:        if(p->pid == 2)
./proc.c:626:                if(p->pid > 2 && p->state != UNUSED) {
./proc.c:627:                    p->killed = 1;
./proc.c:628:					p->state = RUNNABLE;
./proc.c:634:                if(p->pid > 2 && p->state != UNUSED) {
./proc.c:635:					//acquire(&p->lock);
./proc.c:636:					//p->state = SUSPENDED;
./proc.c:637:					p->pending_suspend = 1;  // Mark for deferred suspension
./proc.c:638:					p->parent = initproc;    // Reparent to init
./proc.c:639:                    //release(&p->lock);
./proc.c:648:                if(p->state == SUSPENDED) {
./proc.c:649:                    p->state = RUNNABLE;
./proc.c:650:                    p->pending_suspend = 0;
./proc.c:651:                    // cprintf("pid : %d I am runnable now after control + F \n",p->pid);
./proc.c:657:                if(p->pid > 2 && p->state != UNUSED) {
./proc.c:658:                    p->pending_signals |= (1 << (SIGCUSTOM - 1));  // SIGCUSTOM = 4 defined in signal.h  // Mark 4th bit from LSB as 1
./proc.c:668:				if(p->pid >= 1 && (p->state == SLEEPING || p->state == RUNNING || p->state == RUNNABLE)) {
./proc.c:669:				  // Calculate user-space pages
./proc.c:670:				  int num_pages = (p->sz + PGSIZE - 1) / PGSIZE;
./proc.c:671:				  cprintf("%d %d\n", p->pid, num_pages);
./Makefile:32:# Cross-compiling (e.g., on Mac OS X)
./Makefile:33:# TOOLPREFIX = i386-jos-elf
./Makefile:34:TOOLPREFIX = i686-linux-gnu-
./Makefile:41:TOOLPREFIX := $(shell if i386-jos-elf-objdump -i 2>&1 | grep '^elf32-i386$$' >/dev/null 2>&1; \
./Makefile:42:	then echo 'i386-jos-elf-'; \
./Makefile:43:	elif objdump -i 2>&1 | grep 'elf32-i386' >/dev/null 2>&1; \
./Makefile:46:	echo "*** Error: Couldn't find an i386-*-elf version of GCC/binutils." 1>&2; \
./Makefile:47:	echo "*** Is the directory with i386-jos-elf-gcc in your PATH?" 1>&2; \
./Makefile:48:	echo "*** If your i386-*-elf toolchain is installed with a command" 1>&2; \
./Makefile:49:	echo "*** prefix other than 'i386-jos-elf-', set your TOOLPREFIX" 1>&2; \
./Makefile:56:QEMU = qemu-system-i386
./Makefile:62:	elif which qemu-system-i386 > /dev/null; \
./Makefile:63:	then echo qemu-system-i386; exit; \
./Makefile:64:	elif which qemu-system-x86_64 > /dev/null; \
./Makefile:65:	then echo qemu-system-x86_64; exit; \
./Makefile:67:	qemu=/Applications/Q.app/Contents/MacOS/i386-softmmu.app/Contents/MacOS/i386-softmmu; \
./Makefile:68:	if test -x $$qemu; then echo $$qemu; exit; fi; fi; \
./Makefile:81:CFLAGS = -fno-pic -static -fno-builtin -fno-strict-aliasing -O2 -Wall -MD -ggdb -m32 -fno-omit-frame-pointer
./Makefile:82:CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null >/dev/null 2>&1 && echo -fno-stack-protector)
./Makefile:83:ASFLAGS = -m32 -gdwarf-2 -Wa,-divide
./Makefile:85:CFLAGS += -DALPHA=25 -DBETA=10
./Makefile:87:LDFLAGS += -m $(shell $(LD) -V | grep elf_i386 2>/dev/null | head -n 1)
./Makefile:90:ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]no-pie'),)
./Makefile:91:CFLAGS += -fno-pie -no-pie
./Makefile:93:ifneq ($(shell $(CC) -dumpspecs 2>/dev/null | grep -e '[^f]nopie'),)
./Makefile:94:CFLAGS += -fno-pie -nopie
./Makefile:108:	$(CC) $(CFLAGS) -fno-pic -O -nostdinc -I. -c bootmain.c
./Makefile:109:	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c bootasm.S
./Makefile:110:	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 -o bootblock.o bootasm.o bootmain.o
./Makefile:111:	$(OBJDUMP) -S bootblock.o > bootblock.asm
./Makefile:112:	$(OBJCOPY) -S -O binary -j .text bootblock.o bootblock
./Makefile:116:	$(CC) $(CFLAGS) -fno-pic -nostdinc -I. -c entryother.S
./Makefile:117:	$(LD) $(LDFLAGS) -N -e start -Ttext 0x7000 -o bootblockother.o entryother.o
./Makefile:118:	$(OBJCOPY) -S -O binary -j .text bootblockother.o entryother
./Makefile:119:	$(OBJDUMP) -S bootblockother.o > entryother.asm
./Makefile:122:	$(CC) $(CFLAGS) -nostdinc -I. -c initcode.S
./Makefile:123:	$(LD) $(LDFLAGS) -N -e start -Ttext 0 -o initcode.out initcode.o
./Makefile:124:	$(OBJCOPY) -S -O binary initcode.out initcode
./Makefile:125:	$(OBJDUMP) -S initcode.o > initcode.asm
./Makefile:128:	$(LD) $(LDFLAGS) -T kernel.ld -o kernel entry.o $(OBJS) -b binary initcode entryother
./Makefile:129:	$(OBJDUMP) -S kernel > kernel.asm
./Makefile:130:	$(OBJDUMP) -t kernel | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernel.sym
./Makefile:138:MEMFSOBJS = $(filter-out ide.o,$(OBJS)) memide.o
./Makefile:140:	$(LD) $(LDFLAGS) -T kernel.ld -o kernelmemfs entry.o  $(MEMFSOBJS) -b binary initcode entryother fs.img
./Makefile:141:	$(OBJDUMP) -S kernelmemfs > kernelmemfs.asm
./Makefile:142:	$(OBJDUMP) -t kernelmemfs | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > kernelmemfs.sym
./Makefile:153:	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o $@ $^
./Makefile:154:	$(OBJDUMP) -S $@ > $*.asm
./Makefile:155:	$(OBJDUMP) -t $@ | sed '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' > $*.sym
./Makefile:158:	# forktest has less library code linked in - needs to be small
./Makefile:160:	$(LD) $(LDFLAGS) -N -e main -Ttext 0 -o _forktest forktest.o ulib.o usys.o
./Makefile:161:	$(OBJDUMP) -S _forktest > forktest.asm
./Makefile:164:	gcc -Werror -Wall -o mkfs mkfs.c
./Makefile:169:# http://www.gnu.org/software/make/manual/html_node/Chained-Rules.html
./Makefile:196:-include *.d
./Makefile:199:	rm -f *.tex *.dvi *.idx *.aux *.log *.ind *.ilg \
./Makefile:206:FILES = $(shell grep -v '^\#' runoff.list)
./Makefile:211:	ls -l xv6.pdf
./Makefile:218:	if [ ! -e .bochsrc ]; then ln -s dot-bochsrc .bochsrc; fi
./Makefile:219:	bochs -q
./Makefile:222:GDBPORT = $(shell expr `id -u` % 5000 + 25000)
./Makefile:224:QEMUGDB = $(shell if $(QEMU) -help | grep -q '^-gdb'; \
./Makefile:225:	then echo "-gdb tcp::$(GDBPORT)"; \
./Makefile:226:	else echo "-s -p $(GDBPORT)"; fi)
./Makefile:230:QEMUOPTS = -drive file=fs.img,index=1,media=disk,format=raw -drive file=xv6.img,index=0,media=disk,format=raw -smp $(CPUS) -m 512 $(QEMUEXTRA)
./Makefile:233:	$(QEMU) -serial mon:stdio $(QEMUOPTS)
./Makefile:235:qemu-memfs: xv6memfs.img
./Makefile:236:	$(QEMU) -drive file=xv6memfs.img,index=0,media=disk,format=raw -smp $(CPUS) -m 256
./Makefile:238:qemu-nox: fs.img xv6.img
./Makefile:239:	$(QEMU) -nographic $(QEMUOPTS)
./Makefile:244:qemu-gdb: fs.img xv6.img .gdbinit
./Makefile:246:	$(QEMU) -serial mon:stdio $(QEMUOPTS) -S $(QEMUGDB)
./Makefile:248:qemu-nox-gdb: fs.img xv6.img .gdbinit
./Makefile:250:	$(QEMU) -nographic $(QEMUOPTS) -S $(QEMUGDB)
./Makefile:262:	README dot-bochsrc *.pl toc.* runoff runoff1 runoff.list\
./Makefile:266:	rm -rf dist
./Makefile:270:		grep -v PAGEBREAK $$i >dist/$$i; \
./Makefile:276:dist-test:
./Makefile:277:	rm -rf dist
./Makefile:279:	rm -rf dist-test
./Makefile:280:	mkdir dist-test
./Makefile:281:	cp dist/* dist-test
./Makefile:282:	cd dist-test; $(MAKE) print
./Makefile:283:	cd dist-test; $(MAKE) bochs || true
./Makefile:284:	cd dist-test; $(MAKE) qemu
./Makefile:289:	rm -rf /tmp/xv6
./Makefile:290:	mkdir -p /tmp/xv6
./Makefile:292:	(cd /tmp; tar cf - xv6) | gzip >xv6-rev10.tar.gz  # the next one will be 10 (9/17)
./Makefile:294:.PHONY: dist-test dist
./kill.asm:2:_kill:     file format elf32-i386
./kill.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./kill.asm:91:  7e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kill.asm:126:  return (uchar)*p - (uchar)*q;
./kill.asm:129:  c1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kill.asm:135:  return (uchar)*p - (uchar)*q;
./kill.asm:140:  d8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kill.asm:143:  return (uchar)*p - (uchar)*q;
./kill.asm:210: 132:	8b 7d fc             	mov    -0x4(%ebp),%edi
./kill.asm:267: 185:	8d 75 e7             	lea    -0x19(%ebp),%esi
./kill.asm:288: 1a4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./kill.asm:290: 1ab:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./kill.asm:309: 1ca:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kill.asm:340:    return -1;
./kill.asm:356: 214:	8d 65 f8             	lea    -0x8(%ebp),%esp
./kill.asm:363:    return -1;
./kill.asm:384: 23a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./kill.asm:393:    n = n*10 + *s++ - '0';
./kill.asm:396: 256:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./kill.asm:399: 25d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./kill.asm:404: 265:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./kill.asm:427:  while(n-- > 0)
./kill.asm:438:  while(n-- > 0)
./kill.asm:607:    x = -xx;
./kill.asm:611: 35d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./kill.asm:617:    x = -xx;
./kill.asm:626: 375:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./kill.asm:637: 392:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./kill.asm:644: 39e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./kill.asm:647:    buf[i++] = '-';
./kill.asm:648: 3a5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./kill.asm:650:  while(--i >= 0)
./kill.asm:652: 3ac:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./kill.asm:653: 3af:	8b 75 c0             	mov    -0x40(%ebp),%esi
./kill.asm:660: 3be:	88 45 d7             	mov    %al,-0x29(%ebp)
./kill.asm:661: 3c1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./kill.asm:666:  while(--i >= 0)
./kill.asm:673: 3d9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kill.asm:713: 40e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./kill.asm:716: 418:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./kill.asm:727: 428:	8d 45 e7             	lea    -0x19(%ebp),%eax
./kill.asm:728: 42b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./kill.asm:733: 437:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./kill.asm:765: 470:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kill.asm:775: 483:	8d 55 e7             	lea    -0x19(%ebp),%edx
./kill.asm:776: 486:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./kill.asm:779: 48d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./kill.asm:783: 499:	88 5d e7             	mov    %bl,-0x19(%ebp)
./kill.asm:785: 49e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./kill.asm:796: 4b0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./kill.asm:807: 4c9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./kill.asm:813: 4d6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./kill.asm:817: 4de:	89 45 d0             	mov    %eax,-0x30(%ebp)
./kill.asm:828: 4f6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./kill.asm:829: 4f9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./kill.asm:834: 503:	88 45 e7             	mov    %al,-0x19(%ebp)
./kill.asm:848: 51c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./kill.asm:852: 526:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./kill.asm:859: 537:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./kill.asm:862: 53d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./kill.asm:868: 545:	88 45 e7             	mov    %al,-0x19(%ebp)
./kill.asm:875: 551:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./kill.asm:883: 563:	88 5d e7             	mov    %bl,-0x19(%ebp)
./kill.asm:884: 566:	8d 55 e7             	lea    -0x19(%ebp),%edx
./kill.asm:903:  bp = (Header*)ap - 1;
./kill.asm:904:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./kill.asm:912:  bp = (Header*)ap - 1;
./kill.asm:913: 58e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./kill.asm:914:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./kill.asm:916:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./kill.asm:918:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./kill.asm:923:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./kill.asm:927:  if(bp + bp->s.size == p->s.ptr){
./kill.asm:928: 5a6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./kill.asm:932:    bp->s.size += p->s.ptr->s.size;
./kill.asm:933:    bp->s.ptr = p->s.ptr->s.ptr;
./kill.asm:934: 5b0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./kill.asm:936:    bp->s.ptr = p->s.ptr;
./kill.asm:937:  if(p + p->s.size == bp){
./kill.asm:942:    p->s.size += bp->s.size;
./kill.asm:943:    p->s.ptr = bp->s.ptr;
./kill.asm:946:    p->s.ptr = bp;
./kill.asm:958:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./kill.asm:967:    bp->s.size += p->s.ptr->s.size;
./kill.asm:969: 5e3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./kill.asm:970:    bp->s.ptr = p->s.ptr->s.ptr;
./kill.asm:973: 5ea:	89 53 f8             	mov    %edx,-0x8(%ebx)
./kill.asm:974:  if(p + p->s.size == bp){
./kill.asm:979:    p->s.size += bp->s.size;
./kill.asm:980: 5f7:	03 53 fc             	add    -0x4(%ebx),%edx
./kill.asm:983:    p->s.size += bp->s.size;
./kill.asm:985:    p->s.ptr = bp->s.ptr;
./kill.asm:986: 602:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./kill.asm:1012:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./kill.asm:1016:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./kill.asm:1026:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./kill.asm:1028:    if(p->s.size >= nunits){
./kill.asm:1040:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./kill.asm:1042:    if(p->s.size >= nunits){
./kill.asm:1046:        p->s.size = nunits;
./kill.asm:1059:  if(p == (char*)-1)
./kill.asm:1063:  hp->s.size = nu;
./kill.asm:1079: 690:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kill.asm:1089:      if(p->s.size == nunits)
./kill.asm:1092:        p->s.size -= nunits;
./kill.asm:1095:        p += p->s.size;
./kill.asm:1097:        p->s.size = nunits;
./kill.asm:1102: 6b5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./kill.asm:1122:    if(p->s.size >= nunits){
./kill.asm:1126:        prevp->s.ptr = p->s.ptr;
./cuth:28:	if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
./cuth:34:	for($j=@lines-1; $j>=0; $j--){
./cuth:37:			$lines[$j] = "/* CUT-H */\n";
./cuth:39:			if(system("make CC='gcc -Werror' $obj >/dev/null 2>\&1") != 0){
./cuth:46:	writefile($file, grep {!/CUT-H/} @lines);
./printf.d:1:printf.o: printf.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./syscall.d:1:syscall.o: syscall.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./grep.d:1:grep.o: grep.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./file.d:1:file.o: file.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./exec.c:27:    return -1;
./exec.c:44:  curproc->rss = 0;
./exec.c:71:  clearpteu(pgdir, (char*)(sz - 2*PGSIZE));
./exec.c:78:    sp = (sp - (strlen(argv[argc]) + 1)) & ~3;
./exec.c:87:  ustack[2] = sp - (argc+1)*4;  // argv pointer
./exec.c:89:  sp -= (3+argc+1) * 4;
./exec.c:97:  safestrcpy(curproc->name, last, sizeof(curproc->name));
./exec.c:100:  oldpgdir = curproc->pgdir;
./exec.c:101:  curproc->pgdir = pgdir;
./exec.c:102:  curproc->sz = sz;
./exec.c:103:  curproc->tf->eip = elf.entry;  // main
./exec.c:104:  curproc->tf->esp = sp;
./exec.c:116:  return -1;
./init.d:1:init.o: init.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./show1:3:runoff1 "$@" | pr.pl -h "xv6/$@" | mpage -m50t50b -o -bLetter -T -t -2 -FLucidaSans-Typewriter83 -L60 >x.ps; gv --swap x.ps
./proc.d:1:proc.o: proc.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./echo.d:1:echo.o: echo.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./memtest.asm:2:_memtest:     file format elf32-i386
./memtest.asm:128:  ce:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./memtest.asm:163:  return (uchar)*p - (uchar)*q;
./memtest.asm:166: 111:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./memtest.asm:172:  return (uchar)*p - (uchar)*q;
./memtest.asm:177: 128:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./memtest.asm:180:  return (uchar)*p - (uchar)*q;
./memtest.asm:247: 182:	8b 7d fc             	mov    -0x4(%ebp),%edi
./memtest.asm:304: 1d5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./memtest.asm:325: 1f4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./memtest.asm:327: 1fb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./memtest.asm:346: 21a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./memtest.asm:377:    return -1;
./memtest.asm:393: 264:	8d 65 f8             	lea    -0x8(%ebp),%esp
./memtest.asm:400:    return -1;
./memtest.asm:421: 28a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./memtest.asm:430:    n = n*10 + *s++ - '0';
./memtest.asm:433: 2a6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./memtest.asm:436: 2ad:	8d 58 d0             	lea    -0x30(%eax),%ebx
./memtest.asm:441: 2b5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./memtest.asm:464:  while(n-- > 0)
./memtest.asm:475:  while(n-- > 0)
./memtest.asm:644:    x = -xx;
./memtest.asm:648: 3ad:	89 45 c0             	mov    %eax,-0x40(%ebp)
./memtest.asm:654:    x = -xx;
./memtest.asm:663: 3c5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./memtest.asm:674: 3e2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./memtest.asm:681: 3ee:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./memtest.asm:684:    buf[i++] = '-';
./memtest.asm:685: 3f5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./memtest.asm:687:  while(--i >= 0)
./memtest.asm:689: 3fc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./memtest.asm:690: 3ff:	8b 75 c0             	mov    -0x40(%ebp),%esi
./memtest.asm:697: 40e:	88 45 d7             	mov    %al,-0x29(%ebp)
./memtest.asm:698: 411:	8d 45 d7             	lea    -0x29(%ebp),%eax
./memtest.asm:703:  while(--i >= 0)
./memtest.asm:710: 429:	8d 65 f4             	lea    -0xc(%ebp),%esp
./memtest.asm:750: 45e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./memtest.asm:753: 468:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./memtest.asm:764: 478:	8d 45 e7             	lea    -0x19(%ebp),%eax
./memtest.asm:765: 47b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./memtest.asm:770: 487:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./memtest.asm:802: 4c0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./memtest.asm:812: 4d3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./memtest.asm:813: 4d6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./memtest.asm:816: 4dd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./memtest.asm:820: 4e9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./memtest.asm:822: 4ee:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./memtest.asm:833: 500:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./memtest.asm:844: 519:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./memtest.asm:850: 526:	8b 45 d0             	mov    -0x30(%ebp),%eax
./memtest.asm:854: 52e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./memtest.asm:865: 546:	8d 55 e7             	lea    -0x19(%ebp),%edx
./memtest.asm:866: 549:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./memtest.asm:871: 553:	88 45 e7             	mov    %al,-0x19(%ebp)
./memtest.asm:885: 56c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./memtest.asm:889: 576:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./memtest.asm:896: 587:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./memtest.asm:899: 58d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./memtest.asm:905: 595:	88 45 e7             	mov    %al,-0x19(%ebp)
./memtest.asm:912: 5a1:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./memtest.asm:920: 5b3:	88 5d e7             	mov    %bl,-0x19(%ebp)
./memtest.asm:921: 5b6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./memtest.asm:940:  bp = (Header*)ap - 1;
./memtest.asm:941:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./memtest.asm:949:  bp = (Header*)ap - 1;
./memtest.asm:950: 5de:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./memtest.asm:951:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./memtest.asm:953:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./memtest.asm:955:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./memtest.asm:960:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./memtest.asm:964:  if(bp + bp->s.size == p->s.ptr){
./memtest.asm:965: 5f6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./memtest.asm:969:    bp->s.size += p->s.ptr->s.size;
./memtest.asm:970:    bp->s.ptr = p->s.ptr->s.ptr;
./memtest.asm:971: 600:	89 53 f8             	mov    %edx,-0x8(%ebx)
./memtest.asm:973:    bp->s.ptr = p->s.ptr;
./memtest.asm:974:  if(p + p->s.size == bp){
./memtest.asm:979:    p->s.size += bp->s.size;
./memtest.asm:980:    p->s.ptr = bp->s.ptr;
./memtest.asm:983:    p->s.ptr = bp;
./memtest.asm:995:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./memtest.asm:1004:    bp->s.size += p->s.ptr->s.size;
./memtest.asm:1006: 633:	89 73 fc             	mov    %esi,-0x4(%ebx)
./memtest.asm:1007:    bp->s.ptr = p->s.ptr->s.ptr;
./memtest.asm:1010: 63a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./memtest.asm:1011:  if(p + p->s.size == bp){
./memtest.asm:1016:    p->s.size += bp->s.size;
./memtest.asm:1017: 647:	03 53 fc             	add    -0x4(%ebx),%edx
./memtest.asm:1020:    p->s.size += bp->s.size;
./memtest.asm:1022:    p->s.ptr = bp->s.ptr;
./memtest.asm:1023: 652:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./memtest.asm:1049:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./memtest.asm:1053:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./memtest.asm:1063:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./memtest.asm:1065:    if(p->s.size >= nunits){
./memtest.asm:1077:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./memtest.asm:1079:    if(p->s.size >= nunits){
./memtest.asm:1083:        p->s.size = nunits;
./memtest.asm:1096:  if(p == (char*)-1)
./memtest.asm:1100:  hp->s.size = nu;
./memtest.asm:1116: 6e0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./memtest.asm:1126:      if(p->s.size == nunits)
./memtest.asm:1129:        p->s.size -= nunits;
./memtest.asm:1132:        p += p->s.size;
./memtest.asm:1134:        p->s.size = nunits;
./memtest.asm:1139: 705:	8d 65 f4             	lea    -0xc(%ebp),%esp
./memtest.asm:1159:    if(p->s.size >= nunits){
./memtest.asm:1163:        prevp->s.ptr = p->s.ptr;
./init.asm:2:_init:     file format elf32-i386
./init.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./init.asm:146:  fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./init.asm:181:  return (uchar)*p - (uchar)*q;
./init.asm:184: 141:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./init.asm:190:  return (uchar)*p - (uchar)*q;
./init.asm:195: 158:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./init.asm:198:  return (uchar)*p - (uchar)*q;
./init.asm:265: 1b2:	8b 7d fc             	mov    -0x4(%ebp),%edi
./init.asm:322: 205:	8d 75 e7             	lea    -0x19(%ebp),%esi
./init.asm:343: 224:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./init.asm:345: 22b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./init.asm:364: 24a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./init.asm:395:    return -1;
./init.asm:411: 294:	8d 65 f8             	lea    -0x8(%ebp),%esp
./init.asm:418:    return -1;
./init.asm:439: 2ba:	8d 48 d0             	lea    -0x30(%eax),%ecx
./init.asm:448:    n = n*10 + *s++ - '0';
./init.asm:451: 2d6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./init.asm:454: 2dd:	8d 58 d0             	lea    -0x30(%eax),%ebx
./init.asm:459: 2e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./init.asm:482:  while(n-- > 0)
./init.asm:493:  while(n-- > 0)
./init.asm:662:    x = -xx;
./init.asm:666: 3dd:	89 45 c0             	mov    %eax,-0x40(%ebp)
./init.asm:672:    x = -xx;
./init.asm:681: 3f5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./init.asm:692: 412:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./init.asm:699: 41e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./init.asm:702:    buf[i++] = '-';
./init.asm:703: 425:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./init.asm:705:  while(--i >= 0)
./init.asm:707: 42c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./init.asm:708: 42f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./init.asm:715: 43e:	88 45 d7             	mov    %al,-0x29(%ebp)
./init.asm:716: 441:	8d 45 d7             	lea    -0x29(%ebp),%eax
./init.asm:721:  while(--i >= 0)
./init.asm:728: 459:	8d 65 f4             	lea    -0xc(%ebp),%esp
./init.asm:768: 48e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./init.asm:771: 498:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./init.asm:782: 4a8:	8d 45 e7             	lea    -0x19(%ebp),%eax
./init.asm:783: 4ab:	88 5d e7             	mov    %bl,-0x19(%ebp)
./init.asm:788: 4b7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./init.asm:820: 4f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./init.asm:830: 503:	8d 55 e7             	lea    -0x19(%ebp),%edx
./init.asm:831: 506:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./init.asm:834: 50d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./init.asm:838: 519:	88 5d e7             	mov    %bl,-0x19(%ebp)
./init.asm:840: 51e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./init.asm:851: 530:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./init.asm:862: 549:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./init.asm:868: 556:	8b 45 d0             	mov    -0x30(%ebp),%eax
./init.asm:872: 55e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./init.asm:883: 576:	8d 55 e7             	lea    -0x19(%ebp),%edx
./init.asm:884: 579:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./init.asm:889: 583:	88 45 e7             	mov    %al,-0x19(%ebp)
./init.asm:903: 59c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./init.asm:907: 5a6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./init.asm:914: 5b7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./init.asm:917: 5bd:	8d 55 e7             	lea    -0x19(%ebp),%edx
./init.asm:923: 5c5:	88 45 e7             	mov    %al,-0x19(%ebp)
./init.asm:930: 5d1:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./init.asm:938: 5e3:	88 5d e7             	mov    %bl,-0x19(%ebp)
./init.asm:939: 5e6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./init.asm:958:  bp = (Header*)ap - 1;
./init.asm:959:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./init.asm:967:  bp = (Header*)ap - 1;
./init.asm:968: 60e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./init.asm:969:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./init.asm:971:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./init.asm:973:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./init.asm:978:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./init.asm:982:  if(bp + bp->s.size == p->s.ptr){
./init.asm:983: 626:	8b 73 fc             	mov    -0x4(%ebx),%esi
./init.asm:987:    bp->s.size += p->s.ptr->s.size;
./init.asm:988:    bp->s.ptr = p->s.ptr->s.ptr;
./init.asm:989: 630:	89 53 f8             	mov    %edx,-0x8(%ebx)
./init.asm:991:    bp->s.ptr = p->s.ptr;
./init.asm:992:  if(p + p->s.size == bp){
./init.asm:997:    p->s.size += bp->s.size;
./init.asm:998:    p->s.ptr = bp->s.ptr;
./init.asm:1001:    p->s.ptr = bp;
./init.asm:1013:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./init.asm:1022:    bp->s.size += p->s.ptr->s.size;
./init.asm:1024: 663:	89 73 fc             	mov    %esi,-0x4(%ebx)
./init.asm:1025:    bp->s.ptr = p->s.ptr->s.ptr;
./init.asm:1028: 66a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./init.asm:1029:  if(p + p->s.size == bp){
./init.asm:1034:    p->s.size += bp->s.size;
./init.asm:1035: 677:	03 53 fc             	add    -0x4(%ebx),%edx
./init.asm:1038:    p->s.size += bp->s.size;
./init.asm:1040:    p->s.ptr = bp->s.ptr;
./init.asm:1041: 682:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./init.asm:1067:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./init.asm:1071:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./init.asm:1081:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./init.asm:1083:    if(p->s.size >= nunits){
./init.asm:1095:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./init.asm:1097:    if(p->s.size >= nunits){
./init.asm:1101:        p->s.size = nunits;
./init.asm:1114:  if(p == (char*)-1)
./init.asm:1118:  hp->s.size = nu;
./init.asm:1134: 710:	8d 65 f4             	lea    -0xc(%ebp),%esp
./init.asm:1144:      if(p->s.size == nunits)
./init.asm:1147:        p->s.size -= nunits;
./init.asm:1150:        p += p->s.size;
./init.asm:1152:        p->s.size = nunits;
./init.asm:1157: 735:	8d 65 f4             	lea    -0xc(%ebp),%esp
./init.asm:1177:    if(p->s.size >= nunits){
./init.asm:1181:        prevp->s.ptr = p->s.ptr;
./check.sh:9:fileNameRegex_double="assignment2_easy_[0-9]{4}[A-Z]{2}.[0-9]{4}.tar.gz"
./check.sh:10:fileNameRegex_single="assignment2_easy_[0-9]{4}[A-Z]{2}.[0-9]{4}_[0-9]{4}[A-Z]{2}.[0-9]{4}.tar.gz"
./check.sh:19:tar -xzvf $submission -C ./test_dir
./check.sh:24:expect -f expect_script.sh
./memtest.d:1:memtest.o: memtest.c /usr/i686-linux-gnu/include/stdc-predef.h param.h \
./sleep1.p:37:then a deadlock can happen, because the non-atomic
./sleep1.p:38:increment of value conflicts with the non-atomic 
./sleep1.p:76:	:: cond ->
./sleep1.p:78:	:: else ->
./sleep1.p:89:	:: w < N ->
./sleep1.p:92:	:: else ->
./sleep1.p:103:	:: i < ITER ->
./sleep1.p:106:		x = value; value = x - 1; x = 0;
./sleep1.p:109:	:: else ->
./sleep1.p:122:	:: i < ITER ->
./sleep1.p:128:	:: else ->
./mmu.h:25:// cpu->gdt[NSEGS] holds the above segments.
./mmu.h:41:  uint db : 1;         // 0 = 16-bit segment, 1 = 32-bit segment
./mmu.h:61:#define STA_W       0x2     // Writeable (non-executable segments)
./mmu.h:65:#define STS_T32A    0x9     // Available 32-bit TSS
./mmu.h:66:#define STS_IG32    0xE     // 32-bit Interrupt Gate
./mmu.h:67:#define STS_TG32    0xF     // 32-bit Trap Gate
./mmu.h:69:// A virtual address 'la' has a three-part structure as follows:
./mmu.h:71:// +--------10------+-------10-------+---------12----------+
./mmu.h:74:// +----------------+----------------+---------------------+
./mmu.h:75://  \--- PDX(va) --/ \--- PTX(va) --/
./mmu.h:94:#define PGROUNDUP(sz)  (((sz)+PGSIZE-1) & ~(PGSIZE-1))
./mmu.h:95:#define PGROUNDDOWN(a) (((a)) & ~(PGSIZE-1))
./mmu.h:168:// - istrap: 1 for a trap (= exception) gate, 0 for an interrupt gate.
./mmu.h:170:// - sel: Code segment selector for interrupt/trap handler
./mmu.h:171:// - off: Offset in code segment for interrupt/trap handler
./mmu.h:172:// - dpl: Descriptor Privilege Level -
./lapic.c:1:// The local APIC manages internal (non-I/O) interrupts.
./lapic.c:83:  // Clear error status register (requires back-to-back writes).
./lapic.c:90:  // Send an Init Level De-Assert to synchronise arbitration ID's.
./lapic.c:144:  // Send INIT (level-triggered) interrupt to reset other CPU.
./lapic.c:186:  r->second = cmos_read(SECS);
./lapic.c:187:  r->minute = cmos_read(MINS);
./lapic.c:188:  r->hour   = cmos_read(HOURS);
./lapic.c:189:  r->day    = cmos_read(DAY);
./lapic.c:190:  r->month  = cmos_read(MONTH);
./lapic.c:191:  r->year   = cmos_read(YEAR);
./lapic.c:194:// qemu seems to use 24-hour GWT and the values are BCD encoded
./lapic.c:228:  r->year += 2000;
./ulib.d:1:ulib.o: ulib.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./ide.d:1:ide.o: ide.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./expect_script.sh:1:#!/usr/bin/expect -f
./expect_script.sh:9:		exp_send -s -- $arg
./expect_script.sh:14:# 2) differing output - Some programs produce different output each time
./expect_script.sh:18:# them with wildcards.  An alternative is to use the -p flag (for
./expect_script.sh:20:# (i.e., the prompt).  The -P flag allows you to define a character to
./expect_script.sh:25:# -Don
./expect_script.sh:37:send "make qemu-nox\r"
./expect_script.sh:66:    "Ctrl-C is detected by xv6" {}
./expect_script.sh:87:    "Ctrl-B is detected by xv6" {}
./expect_script.sh:102:    "Ctrl-F is detected by xv6" {}
./expect_script.sh:115:    "Ctrl-C is detected by xv6" {}
./expect_script.sh:136:    "Ctrl-G is detected by xv6" {}
./expect_script.sh:160:    "Ctrl-C is detected by xv6" {}
./expect_script.sh:192:		exp_send -s -- $arg
./expect_script.sh:197:# 2) differing output - Some programs produce different output each time
./expect_script.sh:201:# them with wildcards.  An alternative is to use the -p flag (for
./expect_script.sh:203:# (i.e., the prompt).  The -P flag allows you to define a character to
./expect_script.sh:208:# -Don
./expect_script.sh:220:# send "make qemu-nox\r"
./expect_script.sh:260:    -re "Child (\\d+) \\(PID: (\\d+)\\) started but should not run yet.\r\n" {
./expect_script.sh:275:    -re "Child \\d+ \\(PID: (\\d+)\\) exiting.\r\nPID: (\\d+)\r\nTAT: (\\d+)\r\nWT: (\\d+)\r\nRT: (\\d+)\r\n#CS: (\\d+)" {
./printf.c:22:    x = -xx;
./printf.c:32:    buf[i++] = '-';
./printf.c:34:  while(--i >= 0)
./main.d:1:main.o: main.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./entry.S:35:  .long (-magic-flags)
./entry.S:63:  # the assembler produces a PC-relative instruction
./test3.asm:2:_test3:     file format elf32-i386
./test3.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./test3.asm:157:  fe:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test3.asm:192:  return (uchar)*p - (uchar)*q;
./test3.asm:195: 141:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test3.asm:201:  return (uchar)*p - (uchar)*q;
./test3.asm:206: 158:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test3.asm:209:  return (uchar)*p - (uchar)*q;
./test3.asm:276: 1b2:	8b 7d fc             	mov    -0x4(%ebp),%edi
./test3.asm:333: 205:	8d 75 e7             	lea    -0x19(%ebp),%esi
./test3.asm:354: 224:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./test3.asm:356: 22b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./test3.asm:375: 24a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test3.asm:406:    return -1;
./test3.asm:422: 294:	8d 65 f8             	lea    -0x8(%ebp),%esp
./test3.asm:429:    return -1;
./test3.asm:450: 2ba:	8d 48 d0             	lea    -0x30(%eax),%ecx
./test3.asm:459:    n = n*10 + *s++ - '0';
./test3.asm:462: 2d6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./test3.asm:465: 2dd:	8d 58 d0             	lea    -0x30(%eax),%ebx
./test3.asm:470: 2e5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./test3.asm:493:  while(n-- > 0)
./test3.asm:504:  while(n-- > 0)
./test3.asm:673:    x = -xx;
./test3.asm:677: 3dd:	89 45 c0             	mov    %eax,-0x40(%ebp)
./test3.asm:683:    x = -xx;
./test3.asm:692: 3f5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./test3.asm:703: 412:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./test3.asm:710: 41e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./test3.asm:713:    buf[i++] = '-';
./test3.asm:714: 425:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./test3.asm:716:  while(--i >= 0)
./test3.asm:718: 42c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./test3.asm:719: 42f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./test3.asm:726: 43e:	88 45 d7             	mov    %al,-0x29(%ebp)
./test3.asm:727: 441:	8d 45 d7             	lea    -0x29(%ebp),%eax
./test3.asm:732:  while(--i >= 0)
./test3.asm:739: 459:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test3.asm:779: 48e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./test3.asm:782: 498:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test3.asm:793: 4a8:	8d 45 e7             	lea    -0x19(%ebp),%eax
./test3.asm:794: 4ab:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test3.asm:799: 4b7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test3.asm:831: 4f0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test3.asm:841: 503:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test3.asm:842: 506:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./test3.asm:845: 50d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./test3.asm:849: 519:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test3.asm:851: 51e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./test3.asm:862: 530:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test3.asm:873: 549:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./test3.asm:879: 556:	8b 45 d0             	mov    -0x30(%ebp),%eax
./test3.asm:883: 55e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./test3.asm:894: 576:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test3.asm:895: 579:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./test3.asm:900: 583:	88 45 e7             	mov    %al,-0x19(%ebp)
./test3.asm:914: 59c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./test3.asm:918: 5a6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test3.asm:925: 5b7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./test3.asm:928: 5bd:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test3.asm:934: 5c5:	88 45 e7             	mov    %al,-0x19(%ebp)
./test3.asm:941: 5d1:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./test3.asm:949: 5e3:	88 5d e7             	mov    %bl,-0x19(%ebp)
./test3.asm:950: 5e6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./test3.asm:969:  bp = (Header*)ap - 1;
./test3.asm:970:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test3.asm:978:  bp = (Header*)ap - 1;
./test3.asm:979: 60e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./test3.asm:980:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test3.asm:982:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test3.asm:984:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./test3.asm:989:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test3.asm:993:  if(bp + bp->s.size == p->s.ptr){
./test3.asm:994: 626:	8b 73 fc             	mov    -0x4(%ebx),%esi
./test3.asm:998:    bp->s.size += p->s.ptr->s.size;
./test3.asm:999:    bp->s.ptr = p->s.ptr->s.ptr;
./test3.asm:1000: 630:	89 53 f8             	mov    %edx,-0x8(%ebx)
./test3.asm:1002:    bp->s.ptr = p->s.ptr;
./test3.asm:1003:  if(p + p->s.size == bp){
./test3.asm:1008:    p->s.size += bp->s.size;
./test3.asm:1009:    p->s.ptr = bp->s.ptr;
./test3.asm:1012:    p->s.ptr = bp;
./test3.asm:1024:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./test3.asm:1033:    bp->s.size += p->s.ptr->s.size;
./test3.asm:1035: 663:	89 73 fc             	mov    %esi,-0x4(%ebx)
./test3.asm:1036:    bp->s.ptr = p->s.ptr->s.ptr;
./test3.asm:1039: 66a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./test3.asm:1040:  if(p + p->s.size == bp){
./test3.asm:1045:    p->s.size += bp->s.size;
./test3.asm:1046: 677:	03 53 fc             	add    -0x4(%ebx),%edx
./test3.asm:1049:    p->s.size += bp->s.size;
./test3.asm:1051:    p->s.ptr = bp->s.ptr;
./test3.asm:1052: 682:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./test3.asm:1078:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./test3.asm:1082:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./test3.asm:1092:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./test3.asm:1094:    if(p->s.size >= nunits){
./test3.asm:1106:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./test3.asm:1108:    if(p->s.size >= nunits){
./test3.asm:1112:        p->s.size = nunits;
./test3.asm:1125:  if(p == (char*)-1)
./test3.asm:1129:  hp->s.size = nu;
./test3.asm:1145: 710:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test3.asm:1155:      if(p->s.size == nunits)
./test3.asm:1158:        p->s.size -= nunits;
./test3.asm:1161:        p += p->s.size;
./test3.asm:1163:        p->s.size = nunits;
./test3.asm:1168: 735:	8d 65 f4             	lea    -0xc(%ebp),%esp
./test3.asm:1188:    if(p->s.size >= nunits){
./test3.asm:1192:        prevp->s.ptr = p->s.ptr;
./runoff.spec:4:# "left" and "right" specify which page of a two-page spread a file
./runoff.spec:38:# goal is to have two action-packed 2-page spreads,
./runoff.spec:78:# with fs.c starting on 2nd column of a left page, we get these 2-page spreads:
./fs.h:1:// On-disk file system format.
./fs.h:5:#define ROOTINO 1  // root i-number
./fs.h:28:// On-disk inode structure
./console.d:1:console.o: console.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./kalloc.c:3:// and pipe buffers. Allocates 4096-byte pages.
./kalloc.c:55:    r = r->next;
./kalloc.c:88:  r->next = kmem.freelist;
./kalloc.c:94:    kmem.free_pages--;
./kalloc.c:107:    kmem.freelist = r->next;
./kalloc.c:111:    // Initialize the memory to catch use-after-free bugs
./kalloc.c:113:    kmem.free_pages--;
./kalloc.c:119:  // No pages available - release lock before swapping
./kalloc.c:131:    kmem.freelist = r->next;
./kalloc.c:136:    kmem.free_pages--;
./kalloc.c:142:  // Still no memory available - panic
./defs.h:204:// number of elements in fixed-size array
./sh.asm:2:_sh:     file format elf32-i386
./sh.asm:16:       7:	ff 71 fc             	push   -0x4(%ecx)
./sh.asm:57:  if(pid == -1)
./sh.asm:108:      buf[strlen(buf)-1] = 0;  // chop \n
./sh.asm:114:      buf[strlen(buf)-1] = 0;  // chop \n
./sh.asm:166:     167:	8d 65 f8             	lea    -0x8(%ebp),%esp
./sh.asm:194:  if(pid == -1)
./sh.asm:217:  switch(cmd->type){
./sh.asm:222:    if(ecmd->argv[0] == 0)
./sh.asm:226:    exec(ecmd->argv[0], ecmd->argv);
./sh.asm:233:    printf(2, "exec %s failed\n", ecmd->argv[0]);
./sh.asm:252:     216:	8d 45 f0             	lea    -0x10(%ebp),%eax
./sh.asm:268:     247:	ff 75 f0             	push   -0x10(%ebp)
./sh.asm:272:     250:	ff 75 f4             	push   -0xc(%ebp)
./sh.asm:287:    runcmd(lcmd->right);
./sh.asm:291:    close(rcmd->fd);
./sh.asm:295:    if(open(rcmd->file, rcmd->mode) < 0){
./sh.asm:304:      runcmd(bcmd->cmd);
./sh.asm:312:      printf(2, "open %s failed\n", rcmd->file);
./sh.asm:330:     2e4:	ff 75 f4             	push   -0xc(%ebp)
./sh.asm:334:     2ed:	ff 75 f0             	push   -0x10(%ebp)
./sh.asm:338:     2f6:	ff 75 f4             	push   -0xc(%ebp)
./sh.asm:340:      runcmd(pcmd->left);
./sh.asm:350:     312:	ff 75 f0             	push   -0x10(%ebp)
./sh.asm:354:     31b:	ff 75 f0             	push   -0x10(%ebp)
./sh.asm:358:     324:	ff 75 f4             	push   -0xc(%ebp)
./sh.asm:360:      runcmd(pcmd->right);
./sh.asm:393:  cmd->type = EXEC;
./sh.asm:398:     365:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:426:  cmd->type = REDIR;
./sh.asm:427:  cmd->cmd = subcmd;
./sh.asm:429:  cmd->type = REDIR;
./sh.asm:431:  cmd->cmd = subcmd;
./sh.asm:433:  cmd->file = file;
./sh.asm:436:  cmd->efile = efile;
./sh.asm:439:  cmd->mode = mode;
./sh.asm:442:  cmd->fd = fd;
./sh.asm:448:     3b3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:477:  cmd->type = PIPE;
./sh.asm:478:  cmd->left = left;
./sh.asm:480:  cmd->type = PIPE;
./sh.asm:482:  cmd->left = left;
./sh.asm:484:  cmd->right = right;
./sh.asm:490:     3f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:520:  cmd->type = LIST;
./sh.asm:521:  cmd->left = left;
./sh.asm:523:  cmd->type = LIST;
./sh.asm:525:  cmd->left = left;
./sh.asm:527:  cmd->right = right;
./sh.asm:533:     431:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:563:  cmd->type = BACK;
./sh.asm:564:  cmd->cmd = subcmd;
./sh.asm:566:  cmd->type = BACK;
./sh.asm:568:  cmd->cmd = subcmd;
./sh.asm:573:     46b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:669:     504:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:681:     516:	8d 48 d8             	lea    -0x28(%eax),%ecx
./sh.asm:812:     62a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:830:     64e:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:876:     697:	8d 45 e4             	lea    -0x1c(%ebp),%eax
./sh.asm:878:     69b:	8d 45 e0             	lea    -0x20(%ebp),%eax
./sh.asm:900:     6c1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./sh.asm:901:     6c4:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./sh.asm:905:     6ca:	89 55 d0             	mov    %edx,-0x30(%ebp)
./sh.asm:906:     6cd:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
./sh.asm:919:  cmd->type = REDIR;
./sh.asm:921:  cmd->cmd = subcmd;
./sh.asm:925:  cmd->cmd = subcmd;
./sh.asm:927:  cmd->file = file;
./sh.asm:928:     6f5:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
./sh.asm:930:  cmd->efile = efile;
./sh.asm:931:     6fb:	8b 55 d0             	mov    -0x30(%ebp),%edx
./sh.asm:932:  cmd->mode = mode;
./sh.asm:934:  cmd->efile = efile;
./sh.asm:936:  cmd->fd = fd;
./sh.asm:946:     720:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./sh.asm:947:     723:	8b 4d e0             	mov    -0x20(%ebp),%ecx
./sh.asm:951:     729:	89 55 d0             	mov    %edx,-0x30(%ebp)
./sh.asm:952:     72c:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
./sh.asm:965:  cmd->cmd = subcmd;
./sh.asm:967:  cmd->file = file;
./sh.asm:968:     748:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
./sh.asm:971:  cmd->efile = efile;
./sh.asm:972:     74e:	8b 55 d0             	mov    -0x30(%ebp),%edx
./sh.asm:973:  cmd->type = REDIR;
./sh.asm:975:  cmd->cmd = subcmd;
./sh.asm:977:  cmd->file = file;
./sh.asm:979:  cmd->efile = efile;
./sh.asm:981:  cmd->mode = mode;
./sh.asm:983:  cmd->fd = fd;
./sh.asm:997:     783:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1047:     7d9:	89 45 d0             	mov    %eax,-0x30(%ebp)
./sh.asm:1050:  cmd->type = EXEC;
./sh.asm:1051:     7e2:	8b 45 d0             	mov    -0x30(%ebp),%eax
./sh.asm:1059:  cmd->type = EXEC;
./sh.asm:1069:     7f9:	89 45 d4             	mov    %eax,-0x2c(%ebp)
./sh.asm:1073:    cmd->argv[argc] = q;
./sh.asm:1074:    cmd->eargv[argc] = eq;
./sh.asm:1082:     805:	ff 75 d4             	push   -0x2c(%ebp)
./sh.asm:1085:     810:	89 45 d4             	mov    %eax,-0x2c(%ebp)
./sh.asm:1096:     829:	8d 45 e4             	lea    -0x1c(%ebp),%eax
./sh.asm:1098:     82d:	8d 45 e0             	lea    -0x20(%ebp),%eax
./sh.asm:1109:    cmd->argv[argc] = q;
./sh.asm:1110:     844:	8b 45 e0             	mov    -0x20(%ebp),%eax
./sh.asm:1111:     847:	8b 55 d0             	mov    -0x30(%ebp),%edx
./sh.asm:1113:    cmd->eargv[argc] = eq;
./sh.asm:1114:     84e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./sh.asm:1130:  cmd->argv[argc] = 0;
./sh.asm:1131:  cmd->eargv[argc] = 0;
./sh.asm:1134:     876:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1142:  cmd->argv[argc] = 0;
./sh.asm:1143:     888:	8b 45 d0             	mov    -0x30(%ebp),%eax
./sh.asm:1146:  cmd->eargv[argc] = 0;
./sh.asm:1150:     89b:	8b 45 d4             	mov    -0x2c(%ebp),%eax
./sh.asm:1151:     89e:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1192:     8ee:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1228:  cmd->left = left;
./sh.asm:1230:  cmd->right = right;
./sh.asm:1234:  cmd->type = PIPE;
./sh.asm:1238:  cmd->right = right;
./sh.asm:1241:     944:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1284:     98f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./sh.asm:1286:  cmd->type = BACK;
./sh.asm:1287:     997:	8b 55 e4             	mov    -0x1c(%ebp),%edx
./sh.asm:1288:  cmd->cmd = subcmd;
./sh.asm:1290:  cmd->type = BACK;
./sh.asm:1292:  cmd->cmd = subcmd;
./sh.asm:1315:     9d4:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1350:  cmd->left = left;
./sh.asm:1352:  cmd->right = right;
./sh.asm:1356:  cmd->type = LIST;
./sh.asm:1360:  cmd->right = right;
./sh.asm:1363:     a24:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1426:     a94:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1436:    panic("syntax - missing )");
./sh.asm:1446:// NUL-terminate all the counted strings.
./sh.asm:1465:  switch(cmd->type){
./sh.asm:1471:    nulterminate(pcmd->right);
./sh.asm:1476:    nulterminate(lcmd->left);
./sh.asm:1480:    nulterminate(lcmd->right);
./sh.asm:1487:    nulterminate(bcmd->cmd);
./sh.asm:1493:     af9:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1497:    nulterminate(bcmd->cmd);
./sh.asm:1506:     b10:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1510:    for(i=0; ecmd->argv[i]; i++)
./sh.asm:1516:      *ecmd->eargv[i] = 0;
./sh.asm:1518:    for(i=0; ecmd->argv[i]; i++)
./sh.asm:1520:      *ecmd->eargv[i] = 0;
./sh.asm:1522:    for(i=0; ecmd->argv[i]; i++)
./sh.asm:1523:     b31:	8b 50 fc             	mov    -0x4(%eax),%edx
./sh.asm:1528:     b3a:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1532:    nulterminate(rcmd->cmd);
./sh.asm:1536:    *rcmd->efile = 0;
./sh.asm:1540:    *rcmd->efile = 0;
./sh.asm:1544:     b56:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1592:     ba4:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1641:     bee:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1676:  return (uchar)*p - (uchar)*q;
./sh.asm:1679:     c31:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1685:  return (uchar)*p - (uchar)*q;
./sh.asm:1690:     c48:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1693:  return (uchar)*p - (uchar)*q;
./sh.asm:1760:     ca2:	8b 7d fc             	mov    -0x4(%ebp),%edi
./sh.asm:1817:     cf5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./sh.asm:1838:     d14:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./sh.asm:1840:     d1b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./sh.asm:1859:     d3a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:1890:    return -1;
./sh.asm:1906:     d84:	8d 65 f8             	lea    -0x8(%ebp),%esp
./sh.asm:1913:    return -1;
./sh.asm:1934:     daa:	8d 48 d0             	lea    -0x30(%eax),%ecx
./sh.asm:1943:    n = n*10 + *s++ - '0';
./sh.asm:1946:     dc6:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./sh.asm:1949:     dcd:	8d 58 d0             	lea    -0x30(%eax),%ebx
./sh.asm:1954:     dd5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./sh.asm:1977:  while(n-- > 0)
./sh.asm:1988:  while(n-- > 0)
./sh.asm:2157:    x = -xx;
./sh.asm:2161:     ecd:	89 45 c0             	mov    %eax,-0x40(%ebp)
./sh.asm:2167:    x = -xx;
./sh.asm:2176:     ee5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./sh.asm:2187:     f02:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./sh.asm:2194:     f0e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./sh.asm:2197:    buf[i++] = '-';
./sh.asm:2198:     f15:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./sh.asm:2200:  while(--i >= 0)
./sh.asm:2202:     f1c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./sh.asm:2203:     f1f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./sh.asm:2210:     f2e:	88 45 d7             	mov    %al,-0x29(%ebp)
./sh.asm:2211:     f31:	8d 45 d7             	lea    -0x29(%ebp),%eax
./sh.asm:2216:  while(--i >= 0)
./sh.asm:2223:     f49:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:2263:     f7e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./sh.asm:2266:     f88:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./sh.asm:2277:     f98:	8d 45 e7             	lea    -0x19(%ebp),%eax
./sh.asm:2278:     f9b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./sh.asm:2283:     fa7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./sh.asm:2315:     fe0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:2325:     ff3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./sh.asm:2326:     ff6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./sh.asm:2329:     ffd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./sh.asm:2333:    1009:	88 5d e7             	mov    %bl,-0x19(%ebp)
./sh.asm:2335:    100e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./sh.asm:2346:    1020:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./sh.asm:2357:    1039:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./sh.asm:2363:    1046:	8b 45 d0             	mov    -0x30(%ebp),%eax
./sh.asm:2367:    104e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./sh.asm:2378:    1066:	8d 55 e7             	lea    -0x19(%ebp),%edx
./sh.asm:2379:    1069:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./sh.asm:2384:    1073:	88 45 e7             	mov    %al,-0x19(%ebp)
./sh.asm:2398:    108c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./sh.asm:2402:    1096:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./sh.asm:2409:    10a7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./sh.asm:2412:    10ad:	8d 55 e7             	lea    -0x19(%ebp),%edx
./sh.asm:2418:    10b5:	88 45 e7             	mov    %al,-0x19(%ebp)
./sh.asm:2425:    10c1:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./sh.asm:2433:    10d3:	88 5d e7             	mov    %bl,-0x19(%ebp)
./sh.asm:2434:    10d6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./sh.asm:2453:  bp = (Header*)ap - 1;
./sh.asm:2454:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./sh.asm:2462:  bp = (Header*)ap - 1;
./sh.asm:2463:    10fe:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./sh.asm:2464:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./sh.asm:2466:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./sh.asm:2468:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./sh.asm:2473:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./sh.asm:2477:  if(bp + bp->s.size == p->s.ptr){
./sh.asm:2478:    1116:	8b 73 fc             	mov    -0x4(%ebx),%esi
./sh.asm:2482:    bp->s.size += p->s.ptr->s.size;
./sh.asm:2483:    bp->s.ptr = p->s.ptr->s.ptr;
./sh.asm:2484:    1120:	89 53 f8             	mov    %edx,-0x8(%ebx)
./sh.asm:2486:    bp->s.ptr = p->s.ptr;
./sh.asm:2487:  if(p + p->s.size == bp){
./sh.asm:2492:    p->s.size += bp->s.size;
./sh.asm:2493:    p->s.ptr = bp->s.ptr;
./sh.asm:2496:    p->s.ptr = bp;
./sh.asm:2508:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./sh.asm:2517:    bp->s.size += p->s.ptr->s.size;
./sh.asm:2519:    1153:	89 73 fc             	mov    %esi,-0x4(%ebx)
./sh.asm:2520:    bp->s.ptr = p->s.ptr->s.ptr;
./sh.asm:2523:    115a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./sh.asm:2524:  if(p + p->s.size == bp){
./sh.asm:2529:    p->s.size += bp->s.size;
./sh.asm:2530:    1167:	03 53 fc             	add    -0x4(%ebx),%edx
./sh.asm:2533:    p->s.size += bp->s.size;
./sh.asm:2535:    p->s.ptr = bp->s.ptr;
./sh.asm:2536:    1172:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./sh.asm:2562:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./sh.asm:2566:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./sh.asm:2576:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./sh.asm:2578:    if(p->s.size >= nunits){
./sh.asm:2590:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./sh.asm:2592:    if(p->s.size >= nunits){
./sh.asm:2596:        p->s.size = nunits;
./sh.asm:2609:  if(p == (char*)-1)
./sh.asm:2613:  hp->s.size = nu;
./sh.asm:2629:    1200:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:2639:      if(p->s.size == nunits)
./sh.asm:2642:        p->s.size -= nunits;
./sh.asm:2645:        p += p->s.size;
./sh.asm:2647:        p->s.size = nunits;
./sh.asm:2652:    1225:	8d 65 f4             	lea    -0xc(%ebp),%esp
./sh.asm:2672:    if(p->s.size >= nunits){
./sh.asm:2676:        prevp->s.ptr = p->s.ptr;
./bootblock.asm:2:bootblock.o:     file format elf32-i386
./bootblock.asm:10:.code16                       # Assemble for 16-bit mode
./bootblock.asm:19:  movw    %ax,%ds             # -> Data Segment
./bootblock.asm:21:  movw    %ax,%es             # -> Extra Segment
./bootblock.asm:23:  movw    %ax,%ss             # -> Stack Segment
./bootblock.asm:38:  movb    $0xd1,%al               # 0xd1 -> port 0x64
./bootblock.asm:53:  movb    $0xdf,%al               # 0xdf -> port 0x60
./bootblock.asm:72:  # Complete the transition to 32-bit protected mode by using a long jmp
./bootblock.asm:81:.code32  # Tell assembler to generate 32-bit code now.
./bootblock.asm:83:  # Set up the protected-mode data segment registers
./bootblock.asm:86:  movw    %ax, %ds                # -> DS: Data Segment
./bootblock.asm:88:  movw    %ax, %es                # -> ES: Extra Segment
./bootblock.asm:90:  movw    %ax, %ss                # -> SS: Stack Segment
./bootblock.asm:94:  movw    %ax, %fs                # -> FS
./bootblock.asm:96:  movw    %ax, %gs                # -> GS
./bootblock.asm:107:  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
./bootblock.asm:113:  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
./bootblock.asm:209:  outb(0x1F7, 0x20);  // cmd 0x20 - read sectors
./bootblock.asm:249:  pa -= offset % SECTSIZE;
./bootblock.asm:260:  // We'd write more to memory than asked, but it doesn't matter --
./bootblock.asm:277:    7d35:	8d 65 f4             	lea    -0xc(%ebp),%esp
./bootblock.asm:297:  if(elf->magic != ELF_MAGIC)
./bootblock.asm:302:  ph = (struct proghdr*)((uchar*)elf + elf->phoff);
./bootblock.asm:305:  eph = ph + elf->phnum;
./bootblock.asm:315:    7d87:	8d 65 f4             	lea    -0xc(%ebp),%esp
./bootblock.asm:325:    pa = (uchar*)ph->paddr;
./bootblock.asm:327:    readseg(pa, ph->filesz, ph->off);
./bootblock.asm:333:    if(ph->memsz > ph->filesz)
./bootblock.asm:339:      stosb(pa + ph->filesz, 0, ph->memsz - ph->filesz);
./rm.asm:2:_rm:     file format elf32-i386
./rm.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./rm.asm:108:  9e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./rm.asm:143:  return (uchar)*p - (uchar)*q;
./rm.asm:146:  e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./rm.asm:152:  return (uchar)*p - (uchar)*q;
./rm.asm:157:  f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./rm.asm:160:  return (uchar)*p - (uchar)*q;
./rm.asm:227: 152:	8b 7d fc             	mov    -0x4(%ebp),%edi
./rm.asm:284: 1a5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./rm.asm:305: 1c4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./rm.asm:307: 1cb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./rm.asm:326: 1ea:	8d 65 f4             	lea    -0xc(%ebp),%esp
./rm.asm:357:    return -1;
./rm.asm:373: 234:	8d 65 f8             	lea    -0x8(%ebp),%esp
./rm.asm:380:    return -1;
./rm.asm:401: 25a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./rm.asm:410:    n = n*10 + *s++ - '0';
./rm.asm:413: 276:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./rm.asm:416: 27d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./rm.asm:421: 285:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./rm.asm:444:  while(n-- > 0)
./rm.asm:455:  while(n-- > 0)
./rm.asm:624:    x = -xx;
./rm.asm:628: 37d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./rm.asm:634:    x = -xx;
./rm.asm:643: 395:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./rm.asm:654: 3b2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./rm.asm:661: 3be:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./rm.asm:664:    buf[i++] = '-';
./rm.asm:665: 3c5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./rm.asm:667:  while(--i >= 0)
./rm.asm:669: 3cc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./rm.asm:670: 3cf:	8b 75 c0             	mov    -0x40(%ebp),%esi
./rm.asm:677: 3de:	88 45 d7             	mov    %al,-0x29(%ebp)
./rm.asm:678: 3e1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./rm.asm:683:  while(--i >= 0)
./rm.asm:690: 3f9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./rm.asm:730: 42e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./rm.asm:733: 438:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./rm.asm:744: 448:	8d 45 e7             	lea    -0x19(%ebp),%eax
./rm.asm:745: 44b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./rm.asm:750: 457:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./rm.asm:782: 490:	8d 65 f4             	lea    -0xc(%ebp),%esp
./rm.asm:792: 4a3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./rm.asm:793: 4a6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./rm.asm:796: 4ad:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./rm.asm:800: 4b9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./rm.asm:802: 4be:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./rm.asm:813: 4d0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./rm.asm:824: 4e9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./rm.asm:830: 4f6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./rm.asm:834: 4fe:	89 45 d0             	mov    %eax,-0x30(%ebp)
./rm.asm:845: 516:	8d 55 e7             	lea    -0x19(%ebp),%edx
./rm.asm:846: 519:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./rm.asm:851: 523:	88 45 e7             	mov    %al,-0x19(%ebp)
./rm.asm:865: 53c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./rm.asm:869: 546:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./rm.asm:876: 557:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./rm.asm:879: 55d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./rm.asm:885: 565:	88 45 e7             	mov    %al,-0x19(%ebp)
./rm.asm:892: 571:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./rm.asm:900: 583:	88 5d e7             	mov    %bl,-0x19(%ebp)
./rm.asm:901: 586:	8d 55 e7             	lea    -0x19(%ebp),%edx
./rm.asm:920:  bp = (Header*)ap - 1;
./rm.asm:921:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./rm.asm:929:  bp = (Header*)ap - 1;
./rm.asm:930: 5ae:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./rm.asm:931:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./rm.asm:933:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./rm.asm:935:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./rm.asm:940:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./rm.asm:944:  if(bp + bp->s.size == p->s.ptr){
./rm.asm:945: 5c6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./rm.asm:949:    bp->s.size += p->s.ptr->s.size;
./rm.asm:950:    bp->s.ptr = p->s.ptr->s.ptr;
./rm.asm:951: 5d0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./rm.asm:953:    bp->s.ptr = p->s.ptr;
./rm.asm:954:  if(p + p->s.size == bp){
./rm.asm:959:    p->s.size += bp->s.size;
./rm.asm:960:    p->s.ptr = bp->s.ptr;
./rm.asm:963:    p->s.ptr = bp;
./rm.asm:975:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./rm.asm:984:    bp->s.size += p->s.ptr->s.size;
./rm.asm:986: 603:	89 73 fc             	mov    %esi,-0x4(%ebx)
./rm.asm:987:    bp->s.ptr = p->s.ptr->s.ptr;
./rm.asm:990: 60a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./rm.asm:991:  if(p + p->s.size == bp){
./rm.asm:996:    p->s.size += bp->s.size;
./rm.asm:997: 617:	03 53 fc             	add    -0x4(%ebx),%edx
./rm.asm:1000:    p->s.size += bp->s.size;
./rm.asm:1002:    p->s.ptr = bp->s.ptr;
./rm.asm:1003: 622:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./rm.asm:1029:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./rm.asm:1033:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./rm.asm:1043:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./rm.asm:1045:    if(p->s.size >= nunits){
./rm.asm:1057:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./rm.asm:1059:    if(p->s.size >= nunits){
./rm.asm:1063:        p->s.size = nunits;
./rm.asm:1076:  if(p == (char*)-1)
./rm.asm:1080:  hp->s.size = nu;
./rm.asm:1096: 6b0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./rm.asm:1106:      if(p->s.size == nunits)
./rm.asm:1109:        p->s.size -= nunits;
./rm.asm:1112:        p += p->s.size;
./rm.asm:1114:        p->s.size = nunits;
./rm.asm:1119: 6d5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./rm.asm:1139:    if(p->s.size >= nunits){
./rm.asm:1143:        prevp->s.ptr = p->s.ptr;
./sysfile.c:2:// File-system system calls.
./sysfile.c:19:// Fetch the nth word-sized system call argument as a file descriptor
./sysfile.c:28:    return -1;
./sysfile.c:29:  if(fd < 0 || fd >= NOFILE || (f=myproc()->ofile[fd]) == 0)
./sysfile.c:30:    return -1;
./sysfile.c:47:    if(curproc->ofile[fd] == 0){
./sysfile.c:48:      curproc->ofile[fd] = f;
./sysfile.c:52:  return -1;
./sysfile.c:62:    return -1;
./sysfile.c:64:    return -1;
./sysfile.c:77:    return -1;
./sysfile.c:89:    return -1;
./sysfile.c:100:    return -1;
./sysfile.c:101:  myproc()->ofile[fd] = 0;
./sysfile.c:113:    return -1;
./sysfile.c:125:    return -1;
./sysfile.c:130:    return -1;
./sysfile.c:134:  if(ip->type == T_DIR){
./sysfile.c:137:    return -1;
./sysfile.c:140:  ip->nlink++;
./sysfile.c:147:  if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
./sysfile.c:160:  ip->nlink--;
./sysfile.c:164:  return -1;
./sysfile.c:174:  for(off=2*sizeof(de); off<dp->size; off+=sizeof(de)){
./sysfile.c:193:    return -1;
./sysfile.c:198:    return -1;
./sysfile.c:211:  if(ip->nlink < 1)
./sysfile.c:213:  if(ip->type == T_DIR && !isdirempty(ip)){
./sysfile.c:221:  if(ip->type == T_DIR){
./sysfile.c:222:    dp->nlink--;
./sysfile.c:227:  ip->nlink--;
./sysfile.c:238:  return -1;
./sysfile.c:254:    if(type == T_FILE && ip->type == T_FILE)
./sysfile.c:260:  if((ip = ialloc(dp->dev, type)) == 0)
./sysfile.c:264:  ip->major = major;
./sysfile.c:265:  ip->minor = minor;
./sysfile.c:266:  ip->nlink = 1;
./sysfile.c:270:    dp->nlink++;  // for ".."
./sysfile.c:272:    // No ip->nlink++ for ".": avoid cyclic ref count.
./sysfile.c:273:    if(dirlink(ip, ".", ip->inum) < 0 || dirlink(ip, "..", dp->inum) < 0)
./sysfile.c:277:  if(dirlink(dp, name, ip->inum) < 0)
./sysfile.c:294:    return -1;
./sysfile.c:302:      return -1;
./sysfile.c:307:      return -1;
./sysfile.c:310:    if(ip->type == T_DIR && omode != O_RDONLY){
./sysfile.c:313:      return -1;
./sysfile.c:322:    return -1;
./sysfile.c:327:  f->type = FD_INODE;
./sysfile.c:328:  f->ip = ip;
./sysfile.c:329:  f->off = 0;
./sysfile.c:330:  f->readable = !(omode & O_WRONLY);
./sysfile.c:331:  f->writable = (omode & O_WRONLY) || (omode & O_RDWR);
./sysfile.c:344:    return -1;
./sysfile.c:364:    return -1;
./sysfile.c:381:    return -1;
./sysfile.c:384:  if(ip->type != T_DIR){
./sysfile.c:387:    return -1;
./sysfile.c:390:  iput(curproc->cwd);
./sysfile.c:392:  curproc->cwd = ip;
./sysfile.c:404:    return -1;
./sysfile.c:409:      return -1;
./sysfile.c:411:      return -1;
./sysfile.c:417:      return -1;
./sysfile.c:430:    return -1;
./sysfile.c:432:    return -1;
./sysfile.c:433:  fd0 = -1;
./sysfile.c:436:      myproc()->ofile[fd0] = 0;
./sysfile.c:439:    return -1;
./kill.d:1:kill.o: kill.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./pageswap.c:37:  return -1;
./pageswap.c:51:    memmove(b->data, (char*)page + i*BSIZE, BSIZE);
./pageswap.c:61:    memmove((char*)page + i*BSIZE, b->data, BSIZE);
./pageswap.c:86:  int max_rss = -1;
./pageswap.c:89:    if(p->state != UNUSED && p->rss > max_rss) {
./pageswap.c:90:      max_rss = p->rss;
./pageswap.c:92:    } else if(p->state != UNUSED && p->rss == max_rss) {
./pageswap.c:93:      if(victim && p->pid < victim->pid) {
./pageswap.c:103:  pde_t *pgdir = p->pgdir;
./pageswap.c:157:  // victim->sz -= PGSIZE;
./pageswap.c:159:  victim->rss--;
./pageswap.c:163:// Handle page fault (swapped-in)
./pageswap.c:191:  // curproc->sz += PGSIZE;  // Add page size when swapping in
./pageswap.c:192:  curproc->rss++;
./pageswap.c:206:    Th -= (Th * beta) / 100;
./picirq.c:6:#define IO_PIC1         0x20    // Master (IRQs 0-7)
./picirq.c:7:#define IO_PIC2         0xA0    // Slave (IRQs 8-15)
./user.h:4://------------------------------------------------------------------------------------------------------>
./user.h:7://------------------------------------------------------------------------------------------------------>
./umalloc.c:29:  bp = (Header*)ap - 1;
./umalloc.c:30:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./umalloc.c:31:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./umalloc.c:33:  if(bp + bp->s.size == p->s.ptr){
./umalloc.c:34:    bp->s.size += p->s.ptr->s.size;
./umalloc.c:35:    bp->s.ptr = p->s.ptr->s.ptr;
./umalloc.c:37:    bp->s.ptr = p->s.ptr;
./umalloc.c:38:  if(p + p->s.size == bp){
./umalloc.c:39:    p->s.size += bp->s.size;
./umalloc.c:40:    p->s.ptr = bp->s.ptr;
./umalloc.c:42:    p->s.ptr = bp;
./umalloc.c:55:  if(p == (char*)-1)
./umalloc.c:58:  hp->s.size = nu;
./umalloc.c:69:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./umalloc.c:74:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./umalloc.c:75:    if(p->s.size >= nunits){
./umalloc.c:76:      if(p->s.size == nunits)
./umalloc.c:77:        prevp->s.ptr = p->s.ptr;
./umalloc.c:79:        p->s.size -= nunits;
./umalloc.c:80:        p += p->s.size;
./umalloc.c:81:        p->s.size = nunits;
./mp.c:63:    if((mp = mpsearch1(p-1024, 1024)))
./mp.c:80:  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
./mp.c:82:  conf = (struct mpconf*) P2V((uint) mp->physaddr);
./mp.c:87:  if(conf->version != 1 && conf->version != 4)
./mp.c:89:  if(sum((uchar*)conf, conf->length) != 0)
./mp.c:107:  if(conf->length <= 0 || conf->length > 1024) // Validate conf->length
./mp.c:110:  lapic = (uint*)conf->lapicaddr;
./mp.c:111:  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
./mp.c:116:        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
./mp.c:123:      ioapicid = ioapic->apicno;
./mp.c:139:  if(mp->imcrp){
./log.d:1:log.o: log.c /usr/i686-linux-gnu/include/stdc-predef.h types.h defs.h \
./zombie.asm:2:_zombie:     file format elf32-i386
./zombie.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./zombie.asm:63:  4e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./zombie.asm:98:  return (uchar)*p - (uchar)*q;
./zombie.asm:101:  91:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./zombie.asm:107:  return (uchar)*p - (uchar)*q;
./zombie.asm:112:  a8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./zombie.asm:115:  return (uchar)*p - (uchar)*q;
./zombie.asm:182: 102:	8b 7d fc             	mov    -0x4(%ebp),%edi
./zombie.asm:239: 155:	8d 75 e7             	lea    -0x19(%ebp),%esi
./zombie.asm:260: 174:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./zombie.asm:262: 17b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./zombie.asm:281: 19a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./zombie.asm:312:    return -1;
./zombie.asm:328: 1e4:	8d 65 f8             	lea    -0x8(%ebp),%esp
./zombie.asm:335:    return -1;
./zombie.asm:356: 20a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./zombie.asm:365:    n = n*10 + *s++ - '0';
./zombie.asm:368: 226:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./zombie.asm:371: 22d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./zombie.asm:376: 235:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./zombie.asm:399:  while(n-- > 0)
./zombie.asm:410:  while(n-- > 0)
./zombie.asm:579:    x = -xx;
./zombie.asm:583: 32d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./zombie.asm:589:    x = -xx;
./zombie.asm:598: 345:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./zombie.asm:609: 362:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./zombie.asm:616: 36e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./zombie.asm:619:    buf[i++] = '-';
./zombie.asm:620: 375:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./zombie.asm:622:  while(--i >= 0)
./zombie.asm:624: 37c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./zombie.asm:625: 37f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./zombie.asm:632: 38e:	88 45 d7             	mov    %al,-0x29(%ebp)
./zombie.asm:633: 391:	8d 45 d7             	lea    -0x29(%ebp),%eax
./zombie.asm:638:  while(--i >= 0)
./zombie.asm:645: 3a9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./zombie.asm:685: 3de:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./zombie.asm:688: 3e8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./zombie.asm:699: 3f8:	8d 45 e7             	lea    -0x19(%ebp),%eax
./zombie.asm:700: 3fb:	88 5d e7             	mov    %bl,-0x19(%ebp)
./zombie.asm:705: 407:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./zombie.asm:737: 440:	8d 65 f4             	lea    -0xc(%ebp),%esp
./zombie.asm:747: 453:	8d 55 e7             	lea    -0x19(%ebp),%edx
./zombie.asm:748: 456:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./zombie.asm:751: 45d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./zombie.asm:755: 469:	88 5d e7             	mov    %bl,-0x19(%ebp)
./zombie.asm:757: 46e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./zombie.asm:768: 480:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./zombie.asm:779: 499:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./zombie.asm:785: 4a6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./zombie.asm:789: 4ae:	89 45 d0             	mov    %eax,-0x30(%ebp)
./zombie.asm:800: 4c6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./zombie.asm:801: 4c9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./zombie.asm:806: 4d3:	88 45 e7             	mov    %al,-0x19(%ebp)
./zombie.asm:820: 4ec:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./zombie.asm:824: 4f6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./zombie.asm:831: 507:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./zombie.asm:834: 50d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./zombie.asm:840: 515:	88 45 e7             	mov    %al,-0x19(%ebp)
./zombie.asm:847: 521:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./zombie.asm:855: 533:	88 5d e7             	mov    %bl,-0x19(%ebp)
./zombie.asm:856: 536:	8d 55 e7             	lea    -0x19(%ebp),%edx
./zombie.asm:875:  bp = (Header*)ap - 1;
./zombie.asm:876:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./zombie.asm:884:  bp = (Header*)ap - 1;
./zombie.asm:885: 55e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./zombie.asm:886:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./zombie.asm:888:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./zombie.asm:890:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./zombie.asm:895:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./zombie.asm:899:  if(bp + bp->s.size == p->s.ptr){
./zombie.asm:900: 576:	8b 73 fc             	mov    -0x4(%ebx),%esi
./zombie.asm:904:    bp->s.size += p->s.ptr->s.size;
./zombie.asm:905:    bp->s.ptr = p->s.ptr->s.ptr;
./zombie.asm:906: 580:	89 53 f8             	mov    %edx,-0x8(%ebx)
./zombie.asm:908:    bp->s.ptr = p->s.ptr;
./zombie.asm:909:  if(p + p->s.size == bp){
./zombie.asm:914:    p->s.size += bp->s.size;
./zombie.asm:915:    p->s.ptr = bp->s.ptr;
./zombie.asm:918:    p->s.ptr = bp;
./zombie.asm:930:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./zombie.asm:939:    bp->s.size += p->s.ptr->s.size;
./zombie.asm:941: 5b3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./zombie.asm:942:    bp->s.ptr = p->s.ptr->s.ptr;
./zombie.asm:945: 5ba:	89 53 f8             	mov    %edx,-0x8(%ebx)
./zombie.asm:946:  if(p + p->s.size == bp){
./zombie.asm:951:    p->s.size += bp->s.size;
./zombie.asm:952: 5c7:	03 53 fc             	add    -0x4(%ebx),%edx
./zombie.asm:955:    p->s.size += bp->s.size;
./zombie.asm:957:    p->s.ptr = bp->s.ptr;
./zombie.asm:958: 5d2:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./zombie.asm:984:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./zombie.asm:988:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./zombie.asm:998:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./zombie.asm:1000:    if(p->s.size >= nunits){
./zombie.asm:1012:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./zombie.asm:1014:    if(p->s.size >= nunits){
./zombie.asm:1018:        p->s.size = nunits;
./zombie.asm:1031:  if(p == (char*)-1)
./zombie.asm:1035:  hp->s.size = nu;
./zombie.asm:1051: 660:	8d 65 f4             	lea    -0xc(%ebp),%esp
./zombie.asm:1061:      if(p->s.size == nunits)
./zombie.asm:1064:        p->s.size -= nunits;
./zombie.asm:1067:        p += p->s.size;
./zombie.asm:1069:        p->s.size = nunits;
./zombie.asm:1074: 685:	8d 65 f4             	lea    -0xc(%ebp),%esp
./zombie.asm:1094:    if(p->s.size >= nunits){
./zombie.asm:1098:        prevp->s.ptr = p->s.ptr;
./ls.d:1:ls.o: ls.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./x86.h:67:  pd[0] = size-1;
./x86.h:81:  pd[0] = size-1;
./x86.h:125:  // The + in "+m" denotes a read-modify-write operand.
./runoff:14:mkdir -p fmt
./runoff:15:rm -f fmt/*
./runoff:18:files=`grep -v '^#' runoff.list | awk '{print $1}'`
./runoff:22:	./runoff1 -n $n $i >fmt/$i
./runoff:23:	nn=`tail -1 fmt/$i | sed 's/ .*//; s/^0*//'`
./runoff:31:pr -e8 -t runoff.list | awk '
./runoff:32:/^[a-z0-9]/ {
./runoff:44:}' | pr -3 -t >>fmt/toc
./runoff:48:perl -e '
./runoff:63:			print STDERR "assuming that sheet 1 is a $1 page.  double-check!\n";
./runoff:117:perl -e '
./runoff:127:		if (/^[0-9]+ typedef .* u(int|short|long|char);/) {
./runoff:130:		if (/^[0-9]+ extern/) {
./runoff:133:		if (/^[0-9]+ struct [a-zA-Z0-9_]+;/) {
./runoff:136:		if (/^([0-9]+) #define +([A-za-z0-9_]+) +?\(.*/) {
./runoff:139:		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+) +([^ ]+)/) {
./runoff:142:		elsif (/^([0-9]+) #define +([A-Za-z0-9_]+)/) {
./runoff:146:		if(/^^([0-9]+) \.globl ([a-zA-Z0-9_]+)/){
./runoff:149:		if(/^^([0-9]+) ([a-zA-Z0-9_]+):$/ && $isglobl{$2}){
./runoff:157:		if (/^([0-9]+) (((static|struct|extern|union|enum) +)*([A-Za-z0-9_]+))( .*)? +([A-Za-z_][A-Za-z0-9_]*)(,|;|=| =)/) {
./runoff:161:		elsif(/^([0-9]+) (enum|struct|union) +([A-Za-z0-9_]+) +{/){ 
./runoff:180:perl -n -e 'print if s/^([0-9]+ [a-zA-Z0-9_]+)\(.*$/\1/;' alltext |
./runoff:181:	egrep -v ' (STUB|usage|main|if|for)$' >>defs
./runoff:182:#perl -n -e 'print if s/^([0-9]+) STUB\(([a-zA-Z0-9_]+)\)$/\1 \2/;' alltext \
./runoff:188:for i in `awk '{print $2}' defs | sort -f | uniq`
./runoff:190:	defs=`egrep '^[0-9]+ '$i'( |$)' defs | awk '{print $1}'`
./runoff:192:	uses=`egrep -h '([^a-zA-Z_0-9])'$i'($|[^a-zA-Z_0-9])' alltext | awk '{print $1}'`
./runoff:195:		echo $uses |fmt -29 | sed 's/^/    /'
./runoff:214:	../pr.pl -h "table of contents" toc
./runoff:215:	# pr -t -2 t.defs | ../pr.pl -h "definitions" | pad
./runoff:216:	pr -t -l50 -2 refs | ../pr.pl -h "cross-references" | pad
./runoff:217:	# pr.pl -h "definitions" -2 t.defs | pad
./runoff:218:	# pr.pl -h "cross-references" -2 refs | pad
./runoff:223:		../pr.pl -h "xv6/$i" $i
./runoff:225:) | mpage -m50t50b -o -bLetter -T -t -2 -FCourier -L60 >all.ps
./runoff:229:nicefont=LucidaSans-Typewriter83
./runoff:230:if [ ! -f ../$nicefont ]
./runoff:232:	if git cat-file blob font:$nicefont > ../$nicefont~; then
./runoff:236:if [ -f ../$nicefont ]
./LICENSE:3:Copyright (c) 2006-2018 Frans Kaashoek, Robert Morris, Russ Cox,
./sh.c:70:  switch(cmd->type){
./sh.c:76:    if(ecmd->argv[0] == 0)
./sh.c:78:    exec(ecmd->argv[0], ecmd->argv);
./sh.c:79:    printf(2, "exec %s failed\n", ecmd->argv[0]);
./sh.c:84:    close(rcmd->fd);
./sh.c:85:    if(open(rcmd->file, rcmd->mode) < 0){
./sh.c:86:      printf(2, "open %s failed\n", rcmd->file);
./sh.c:89:    runcmd(rcmd->cmd);
./sh.c:95:      runcmd(lcmd->left);
./sh.c:97:    runcmd(lcmd->right);
./sh.c:109:      runcmd(pcmd->left);
./sh.c:116:      runcmd(pcmd->right);
./sh.c:127:      runcmd(bcmd->cmd);
./sh.c:140:    return -1;
./sh.c:162:      buf[strlen(buf)-1] = 0;  // chop \n
./sh.c:187:  if(pid == -1)
./sh.c:202:  cmd->type = EXEC;
./sh.c:213:  cmd->type = REDIR;
./sh.c:214:  cmd->cmd = subcmd;
./sh.c:215:  cmd->file = file;
./sh.c:216:  cmd->efile = efile;
./sh.c:217:  cmd->mode = mode;
./sh.c:218:  cmd->fd = fd;
./sh.c:229:  cmd->type = PIPE;
./sh.c:230:  cmd->left = left;
./sh.c:231:  cmd->right = right;
./sh.c:242:  cmd->type = LIST;
./sh.c:243:  cmd->left = left;
./sh.c:244:  cmd->right = right;
./sh.c:255:  cmd->type = BACK;
./sh.c:256:  cmd->cmd = subcmd;
./sh.c:409:    panic("syntax - missing )");
./sh.c:436:    cmd->argv[argc] = q;
./sh.c:437:    cmd->eargv[argc] = eq;
./sh.c:443:  cmd->argv[argc] = 0;
./sh.c:444:  cmd->eargv[argc] = 0;
./sh.c:448:// NUL-terminate all the counted strings.
./sh.c:462:  switch(cmd->type){
./sh.c:465:    for(i=0; ecmd->argv[i]; i++)
./sh.c:466:      *ecmd->eargv[i] = 0;
./sh.c:471:    nulterminate(rcmd->cmd);
./sh.c:472:    *rcmd->efile = 0;
./sh.c:477:    nulterminate(pcmd->left);
./sh.c:478:    nulterminate(pcmd->right);
./sh.c:483:    nulterminate(lcmd->left);
./sh.c:484:    nulterminate(lcmd->right);
./sh.c:489:    nulterminate(bcmd->cmd);
./sh.d:1:sh.o: sh.c /usr/i686-linux-gnu/include/stdc-predef.h types.h user.h \
./test2.c:9:  return fib(n - 1) + fib(n - 2);
./kalloc.d:1:kalloc.o: kalloc.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./sleeplock.c:16:  initlock(&lk->lk, "sleep lock");
./sleeplock.c:17:  lk->name = name;
./sleeplock.c:18:  lk->locked = 0;
./sleeplock.c:19:  lk->pid = 0;
./sleeplock.c:25:  acquire(&lk->lk);
./sleeplock.c:26:  while (lk->locked) {
./sleeplock.c:27:    sleep(lk, &lk->lk);
./sleeplock.c:29:  lk->locked = 1;
./sleeplock.c:30:  lk->pid = myproc()->pid;
./sleeplock.c:31:  release(&lk->lk);
./sleeplock.c:37:  acquire(&lk->lk);
./sleeplock.c:38:  lk->locked = 0;
./sleeplock.c:39:  lk->pid = 0;
./sleeplock.c:41:  release(&lk->lk);
./sleeplock.c:49:  acquire(&lk->lk);
./sleeplock.c:50:  r = lk->locked && (lk->pid == myproc()->pid);
./sleeplock.c:51:  release(&lk->lk);
./memide.c:32:  // no-op
./memide.c:43:  if(!holdingsleep(&b->lock))
./memide.c:45:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
./memide.c:47:  if(b->dev != 1)
./memide.c:49:  if(b->blockno >= disksize)
./memide.c:52:  p = memdisk + b->blockno*BSIZE;
./memide.c:54:  if(b->flags & B_DIRTY){
./memide.c:55:    b->flags &= ~B_DIRTY;
./memide.c:56:    memmove(p, b->data, BSIZE);
./memide.c:58:    memmove(b->data, p, BSIZE);
./memide.c:59:  b->flags |= B_VALID;
./forktest.asm:2:_forktest:     file format elf32-i386
./forktest.asm:38:  2d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./forktest.asm:78:  for(; n > 0; n--){
./forktest.asm:86:  for(; n > 0; n--){
./forktest.asm:89:  if(wait() != -1){
./forktest.asm:103:  c5:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./forktest.asm:167: 13e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./forktest.asm:202:  return (uchar)*p - (uchar)*q;
./forktest.asm:205: 181:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./forktest.asm:211:  return (uchar)*p - (uchar)*q;
./forktest.asm:216: 198:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./forktest.asm:219:  return (uchar)*p - (uchar)*q;
./forktest.asm:286: 1f2:	8b 7d fc             	mov    -0x4(%ebp),%edi
./forktest.asm:343: 245:	8d 75 e7             	lea    -0x19(%ebp),%esi
./forktest.asm:364: 264:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./forktest.asm:366: 26b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./forktest.asm:385: 28a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./forktest.asm:416:    return -1;
./forktest.asm:432: 2d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
./forktest.asm:439:    return -1;
./forktest.asm:460: 2fa:	8d 48 d0             	lea    -0x30(%eax),%ecx
./forktest.asm:469:    n = n*10 + *s++ - '0';
./forktest.asm:472: 316:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./forktest.asm:475: 31d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./forktest.asm:480: 325:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./forktest.asm:503:  while(n-- > 0)
./forktest.asm:514:  while(n-- > 0)
./tom.c:9:    return fib(n - 1) + fib(n - 2);
./pipe.c:33:  p->readopen = 1;
./pipe.c:34:  p->writeopen = 1;
./pipe.c:35:  p->nwrite = 0;
./pipe.c:36:  p->nread = 0;
./pipe.c:37:  initlock(&p->lock, "pipe");
./pipe.c:38:  (*f0)->type = FD_PIPE;
./pipe.c:39:  (*f0)->readable = 1;
./pipe.c:40:  (*f0)->writable = 0;
./pipe.c:41:  (*f0)->pipe = p;
./pipe.c:42:  (*f1)->type = FD_PIPE;
./pipe.c:43:  (*f1)->readable = 0;
./pipe.c:44:  (*f1)->writable = 1;
./pipe.c:45:  (*f1)->pipe = p;
./pipe.c:56:  return -1;
./pipe.c:62:  acquire(&p->lock);
./pipe.c:64:    p->writeopen = 0;
./pipe.c:65:    wakeup(&p->nread);
./pipe.c:67:    p->readopen = 0;
./pipe.c:68:    wakeup(&p->nwrite);
./pipe.c:70:  if(p->readopen == 0 && p->writeopen == 0){
./pipe.c:71:    release(&p->lock);
./pipe.c:74:    release(&p->lock);
./pipe.c:83:  acquire(&p->lock);
./pipe.c:85:    while(p->nwrite == p->nread + PIPESIZE){  //DOC: pipewrite-full
./pipe.c:86:      if(p->readopen == 0 || myproc()->killed){
./pipe.c:87:        release(&p->lock);
./pipe.c:88:        return -1;
./pipe.c:90:      wakeup(&p->nread);
./pipe.c:91:      sleep(&p->nwrite, &p->lock);  //DOC: pipewrite-sleep
./pipe.c:93:    p->data[p->nwrite++ % PIPESIZE] = addr[i];
./pipe.c:95:  wakeup(&p->nread);  //DOC: pipewrite-wakeup1
./pipe.c:96:  release(&p->lock);
./pipe.c:105:  acquire(&p->lock);
./pipe.c:106:  while(p->nread == p->nwrite && p->writeopen){  //DOC: pipe-empty
./pipe.c:107:    if(myproc()->killed){
./pipe.c:108:      release(&p->lock);
./pipe.c:109:      return -1;
./pipe.c:111:    sleep(&p->nread, &p->lock); //DOC: piperead-sleep
./pipe.c:113:  for(i = 0; i < n; i++){  //DOC: piperead-copy
./pipe.c:114:    if(p->nread == p->nwrite)
./pipe.c:116:    addr[i] = p->data[p->nread++ % PIPESIZE];
./pipe.c:118:  wakeup(&p->nwrite);  //DOC: piperead-wakeup
./pipe.c:119:  release(&p->lock);
./echo.asm:2:_echo:     file format elf32-i386
./echo.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./echo.asm:43:  45:	8b 44 9f fc          	mov    -0x4(%edi,%ebx,4),%eax
./echo.asm:87:  8e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./echo.asm:122:  return (uchar)*p - (uchar)*q;
./echo.asm:125:  d1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./echo.asm:131:  return (uchar)*p - (uchar)*q;
./echo.asm:136:  e8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./echo.asm:139:  return (uchar)*p - (uchar)*q;
./echo.asm:206: 142:	8b 7d fc             	mov    -0x4(%ebp),%edi
./echo.asm:263: 195:	8d 75 e7             	lea    -0x19(%ebp),%esi
./echo.asm:284: 1b4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./echo.asm:286: 1bb:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./echo.asm:305: 1da:	8d 65 f4             	lea    -0xc(%ebp),%esp
./echo.asm:336:    return -1;
./echo.asm:352: 224:	8d 65 f8             	lea    -0x8(%ebp),%esp
./echo.asm:359:    return -1;
./echo.asm:380: 24a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./echo.asm:389:    n = n*10 + *s++ - '0';
./echo.asm:392: 266:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./echo.asm:395: 26d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./echo.asm:400: 275:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./echo.asm:423:  while(n-- > 0)
./echo.asm:434:  while(n-- > 0)
./echo.asm:603:    x = -xx;
./echo.asm:607: 36d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./echo.asm:613:    x = -xx;
./echo.asm:622: 385:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./echo.asm:633: 3a2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./echo.asm:640: 3ae:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./echo.asm:643:    buf[i++] = '-';
./echo.asm:644: 3b5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./echo.asm:646:  while(--i >= 0)
./echo.asm:648: 3bc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./echo.asm:649: 3bf:	8b 75 c0             	mov    -0x40(%ebp),%esi
./echo.asm:656: 3ce:	88 45 d7             	mov    %al,-0x29(%ebp)
./echo.asm:657: 3d1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./echo.asm:662:  while(--i >= 0)
./echo.asm:669: 3e9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./echo.asm:709: 41e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./echo.asm:712: 428:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./echo.asm:723: 438:	8d 45 e7             	lea    -0x19(%ebp),%eax
./echo.asm:724: 43b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./echo.asm:729: 447:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./echo.asm:761: 480:	8d 65 f4             	lea    -0xc(%ebp),%esp
./echo.asm:771: 493:	8d 55 e7             	lea    -0x19(%ebp),%edx
./echo.asm:772: 496:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./echo.asm:775: 49d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./echo.asm:779: 4a9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./echo.asm:781: 4ae:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./echo.asm:792: 4c0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./echo.asm:803: 4d9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./echo.asm:809: 4e6:	8b 45 d0             	mov    -0x30(%ebp),%eax
./echo.asm:813: 4ee:	89 45 d0             	mov    %eax,-0x30(%ebp)
./echo.asm:824: 506:	8d 55 e7             	lea    -0x19(%ebp),%edx
./echo.asm:825: 509:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./echo.asm:830: 513:	88 45 e7             	mov    %al,-0x19(%ebp)
./echo.asm:844: 52c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./echo.asm:848: 536:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./echo.asm:855: 547:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./echo.asm:858: 54d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./echo.asm:864: 555:	88 45 e7             	mov    %al,-0x19(%ebp)
./echo.asm:871: 561:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./echo.asm:879: 573:	88 5d e7             	mov    %bl,-0x19(%ebp)
./echo.asm:880: 576:	8d 55 e7             	lea    -0x19(%ebp),%edx
./echo.asm:899:  bp = (Header*)ap - 1;
./echo.asm:900:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./echo.asm:908:  bp = (Header*)ap - 1;
./echo.asm:909: 59e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./echo.asm:910:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./echo.asm:912:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./echo.asm:914:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./echo.asm:919:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./echo.asm:923:  if(bp + bp->s.size == p->s.ptr){
./echo.asm:924: 5b6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./echo.asm:928:    bp->s.size += p->s.ptr->s.size;
./echo.asm:929:    bp->s.ptr = p->s.ptr->s.ptr;
./echo.asm:930: 5c0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./echo.asm:932:    bp->s.ptr = p->s.ptr;
./echo.asm:933:  if(p + p->s.size == bp){
./echo.asm:938:    p->s.size += bp->s.size;
./echo.asm:939:    p->s.ptr = bp->s.ptr;
./echo.asm:942:    p->s.ptr = bp;
./echo.asm:954:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./echo.asm:963:    bp->s.size += p->s.ptr->s.size;
./echo.asm:965: 5f3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./echo.asm:966:    bp->s.ptr = p->s.ptr->s.ptr;
./echo.asm:969: 5fa:	89 53 f8             	mov    %edx,-0x8(%ebx)
./echo.asm:970:  if(p + p->s.size == bp){
./echo.asm:975:    p->s.size += bp->s.size;
./echo.asm:976: 607:	03 53 fc             	add    -0x4(%ebx),%edx
./echo.asm:979:    p->s.size += bp->s.size;
./echo.asm:981:    p->s.ptr = bp->s.ptr;
./echo.asm:982: 612:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./echo.asm:1008:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./echo.asm:1012:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./echo.asm:1022:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./echo.asm:1024:    if(p->s.size >= nunits){
./echo.asm:1036:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./echo.asm:1038:    if(p->s.size >= nunits){
./echo.asm:1042:        p->s.size = nunits;
./echo.asm:1055:  if(p == (char*)-1)
./echo.asm:1059:  hp->s.size = nu;
./echo.asm:1075: 6a0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./echo.asm:1085:      if(p->s.size == nunits)
./echo.asm:1088:        p->s.size -= nunits;
./echo.asm:1091:        p += p->s.size;
./echo.asm:1093:        p->s.size = nunits;
./echo.asm:1098: 6c5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./echo.asm:1118:    if(p->s.size >= nunits){
./echo.asm:1122:        prevp->s.ptr = p->s.ptr;
./traps.h:3:// Processor-defined:
./traps.h:6:#define T_NMI            2      // non-maskable interrupt
./ide.c:1:// Simple PIO-based (non-DMA) IDE driver code.
./ide.c:28:// idequeue->qnext points to the next buf to be processed.
./ide.c:46:    return -1;
./ide.c:56:  ioapicenable(IRQ_IDE, ncpu - 1);
./ide.c:78:  if(b->blockno >= FSSIZE)
./ide.c:81:  int sector = b->blockno * sector_per_block;
./ide.c:93:  outb(0x1f6, 0xe0 | ((b->dev&1)<<4) | ((sector>>24)&0x0f));
./ide.c:94:  if(b->flags & B_DIRTY){
./ide.c:96:    outsl(0x1f0, b->data, BSIZE/4);
./ide.c:115:  idequeue = b->qnext;
./ide.c:118:  if(!(b->flags & B_DIRTY) && idewait(1) >= 0)
./ide.c:119:    insl(0x1f0, b->data, BSIZE/4);
./ide.c:122:  b->flags |= B_VALID;
./ide.c:123:  b->flags &= ~B_DIRTY;
./ide.c:142:  if(!holdingsleep(&b->lock))
./ide.c:144:  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
./ide.c:146:  if(b->dev != 0 && !havedisk1)
./ide.c:149:  acquire(&idelock);  //DOC:acquire-lock
./ide.c:152:  b->qnext = 0;
./ide.c:153:  for(pp=&idequeue; *pp; pp=&(*pp)->qnext)  //DOC:insert-queue
./ide.c:162:  while((b->flags & (B_VALID|B_DIRTY)) != B_VALID){
./cat.asm:2:_cat:     file format elf32-i386
./cat.asm:16:   7:	ff 71 fc             	push   -0x4(%ecx)
./cat.asm:27:  1e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./cat.asm:54:  4a:	39 75 e4             	cmp    %esi,-0x1c(%ebp)
./cat.asm:117:  d5:	8d 65 f8             	lea    -0x8(%ebp),%esp
./cat.asm:173: 12e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./cat.asm:208:  return (uchar)*p - (uchar)*q;
./cat.asm:211: 171:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./cat.asm:217:  return (uchar)*p - (uchar)*q;
./cat.asm:222: 188:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./cat.asm:225:  return (uchar)*p - (uchar)*q;
./cat.asm:292: 1e2:	8b 7d fc             	mov    -0x4(%ebp),%edi
./cat.asm:349: 235:	8d 75 e7             	lea    -0x19(%ebp),%esi
./cat.asm:370: 254:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./cat.asm:372: 25b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./cat.asm:391: 27a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./cat.asm:422:    return -1;
./cat.asm:438: 2c4:	8d 65 f8             	lea    -0x8(%ebp),%esp
./cat.asm:445:    return -1;
./cat.asm:466: 2ea:	8d 48 d0             	lea    -0x30(%eax),%ecx
./cat.asm:475:    n = n*10 + *s++ - '0';
./cat.asm:478: 306:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./cat.asm:481: 30d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./cat.asm:486: 315:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./cat.asm:509:  while(n-- > 0)
./cat.asm:520:  while(n-- > 0)
./cat.asm:689:    x = -xx;
./cat.asm:693: 40d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./cat.asm:699:    x = -xx;
./cat.asm:708: 425:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./cat.asm:719: 442:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./cat.asm:726: 44e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./cat.asm:729:    buf[i++] = '-';
./cat.asm:730: 455:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./cat.asm:732:  while(--i >= 0)
./cat.asm:734: 45c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./cat.asm:735: 45f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./cat.asm:742: 46e:	88 45 d7             	mov    %al,-0x29(%ebp)
./cat.asm:743: 471:	8d 45 d7             	lea    -0x29(%ebp),%eax
./cat.asm:748:  while(--i >= 0)
./cat.asm:755: 489:	8d 65 f4             	lea    -0xc(%ebp),%esp
./cat.asm:795: 4be:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./cat.asm:798: 4c8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./cat.asm:809: 4d8:	8d 45 e7             	lea    -0x19(%ebp),%eax
./cat.asm:810: 4db:	88 5d e7             	mov    %bl,-0x19(%ebp)
./cat.asm:815: 4e7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./cat.asm:847: 520:	8d 65 f4             	lea    -0xc(%ebp),%esp
./cat.asm:857: 533:	8d 55 e7             	lea    -0x19(%ebp),%edx
./cat.asm:858: 536:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./cat.asm:861: 53d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./cat.asm:865: 549:	88 5d e7             	mov    %bl,-0x19(%ebp)
./cat.asm:867: 54e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./cat.asm:878: 560:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./cat.asm:889: 579:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./cat.asm:895: 586:	8b 45 d0             	mov    -0x30(%ebp),%eax
./cat.asm:899: 58e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./cat.asm:910: 5a6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./cat.asm:911: 5a9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./cat.asm:916: 5b3:	88 45 e7             	mov    %al,-0x19(%ebp)
./cat.asm:930: 5cc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./cat.asm:934: 5d6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./cat.asm:941: 5e7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./cat.asm:944: 5ed:	8d 55 e7             	lea    -0x19(%ebp),%edx
./cat.asm:950: 5f5:	88 45 e7             	mov    %al,-0x19(%ebp)
./cat.asm:957: 601:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./cat.asm:965: 613:	88 5d e7             	mov    %bl,-0x19(%ebp)
./cat.asm:966: 616:	8d 55 e7             	lea    -0x19(%ebp),%edx
./cat.asm:985:  bp = (Header*)ap - 1;
./cat.asm:986:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./cat.asm:994:  bp = (Header*)ap - 1;
./cat.asm:995: 63e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./cat.asm:996:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./cat.asm:998:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./cat.asm:1000:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./cat.asm:1005:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./cat.asm:1009:  if(bp + bp->s.size == p->s.ptr){
./cat.asm:1010: 656:	8b 73 fc             	mov    -0x4(%ebx),%esi
./cat.asm:1014:    bp->s.size += p->s.ptr->s.size;
./cat.asm:1015:    bp->s.ptr = p->s.ptr->s.ptr;
./cat.asm:1016: 660:	89 53 f8             	mov    %edx,-0x8(%ebx)
./cat.asm:1018:    bp->s.ptr = p->s.ptr;
./cat.asm:1019:  if(p + p->s.size == bp){
./cat.asm:1024:    p->s.size += bp->s.size;
./cat.asm:1025:    p->s.ptr = bp->s.ptr;
./cat.asm:1028:    p->s.ptr = bp;
./cat.asm:1040:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./cat.asm:1049:    bp->s.size += p->s.ptr->s.size;
./cat.asm:1051: 693:	89 73 fc             	mov    %esi,-0x4(%ebx)
./cat.asm:1052:    bp->s.ptr = p->s.ptr->s.ptr;
./cat.asm:1055: 69a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./cat.asm:1056:  if(p + p->s.size == bp){
./cat.asm:1061:    p->s.size += bp->s.size;
./cat.asm:1062: 6a7:	03 53 fc             	add    -0x4(%ebx),%edx
./cat.asm:1065:    p->s.size += bp->s.size;
./cat.asm:1067:    p->s.ptr = bp->s.ptr;
./cat.asm:1068: 6b2:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./cat.asm:1094:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./cat.asm:1098:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./cat.asm:1108:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./cat.asm:1110:    if(p->s.size >= nunits){
./cat.asm:1122:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./cat.asm:1124:    if(p->s.size >= nunits){
./cat.asm:1128:        p->s.size = nunits;
./cat.asm:1141:  if(p == (char*)-1)
./cat.asm:1145:  hp->s.size = nu;
./cat.asm:1161: 740:	8d 65 f4             	lea    -0xc(%ebp),%esp
./cat.asm:1171:      if(p->s.size == nunits)
./cat.asm:1174:        p->s.size -= nunits;
./cat.asm:1177:        p += p->s.size;
./cat.asm:1179:        p->s.size = nunits;
./cat.asm:1184: 765:	8d 65 f4             	lea    -0xc(%ebp),%esp
./cat.asm:1204:    if(p->s.size >= nunits){
./cat.asm:1208:        prevp->s.ptr = p->s.ptr;
./sign.pl:14:$buf .= "\0" x (510-$n);
./bootasm.S:5:# Start the first CPU: switch to 32-bit protected mode, jump into C.
./bootasm.S:10:.code16                       # Assemble for 16-bit mode
./bootasm.S:17:  movw    %ax,%ds             # -> Data Segment
./bootasm.S:18:  movw    %ax,%es             # -> Extra Segment
./bootasm.S:19:  movw    %ax,%ss             # -> Stack Segment
./bootasm.S:28:  movb    $0xd1,%al               # 0xd1 -> port 0x64
./bootasm.S:36:  movb    $0xdf,%al               # 0xdf -> port 0x60
./bootasm.S:48:  # Complete the transition to 32-bit protected mode by using a long jmp
./bootasm.S:53:.code32  # Tell assembler to generate 32-bit code now.
./bootasm.S:55:  # Set up the protected-mode data segment registers
./bootasm.S:57:  movw    %ax, %ds                # -> DS: Data Segment
./bootasm.S:58:  movw    %ax, %es                # -> ES: Extra Segment
./bootasm.S:59:  movw    %ax, %ss                # -> SS: Stack Segment
./bootasm.S:61:  movw    %ax, %fs                # -> FS
./bootasm.S:62:  movw    %ax, %gs                # -> GS
./bootasm.S:70:  movw    $0x8a00, %ax            # 0x8a00 -> port 0x8a00
./bootasm.S:73:  movw    $0x8ae0, %ax            # 0x8ae0 -> port 0x8a00
./bootasm.S:86:  .word   (gdtdesc - gdt - 1)             # sizeof(gdt) - 1
./usertests.c:16:// does chdir() call iput(p->cwd) in a transaction?
./usertests.c:41:// does exit() call iput(p->cwd) in a transaction?
./usertests.c:78://      return -1;
./usertests.c:220:      if(n == MAXFILE - 1){
./usertests.c:751:    printf(1, "link non-existant succeeded! oops\n");
./usertests.c:807:      i = de.name[1] - '0';
./usertests.c:956:    printf(1, "unlink dd (non-empty dir) succeeded!\n");
./usertests.c:1102:    printf(1, "unlink non-empty dd succeeded!\n");
./usertests.c:1399:  for(; n > 0; n--){
./usertests.c:1406:  if(wait() != -1){
./usertests.c:1444:    printf(stdout, "sbrk test failed post-fork\n");
./usertests.c:1454:  amt = (BIG) - (uint)a;
./usertests.c:1460:  lastaddr = (char*) (BIG-1);
./usertests.c:1463:  // can one de-allocate?
./usertests.c:1465:  c = sbrk(-4096);
./usertests.c:1471:  if(c != a - 4096){
./usertests.c:1476:  // can one re-allocate that page?
./usertests.c:1480:    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
./usertests.c:1485:    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
./usertests.c:1490:  c = sbrk(-(sbrk(0) - oldbrk));
./usertests.c:1521:      sbrk(BIG - (uint)sbrk(0));
./usertests.c:1526:    if(pids[i] != -1)
./usertests.c:1533:    if(pids[i] == -1)
./usertests.c:1544:    sbrk(-(sbrk(0) - oldbrk));
./usertests.c:1583:    if(link("nosuchfile", (char*)p) != -1){
./usertests.c:1617:  unlink("bigarg-ok");
./usertests.c:1622:    for(i = 0; i < MAXARG-1; i++)
./usertests.c:1624:    args[MAXARG-1] = 0;
./usertests.c:1628:    fd = open("bigarg-ok", O_CREATE);
./usertests.c:1636:  fd = open("bigarg-ok", 0);
./usertests.c:1642:  unlink("bigarg-ok");
./usertests.c:1692:    nfiles--;
./usertests.c:1735:  read(fd, sbrk(0) - 1, -1);
./usertests.c:1754:    printf(1, "already ran user tests -- rebuild fs.img\n");
./usertests.asm:2:_usertests:     file format elf32-i386
./usertests.asm:16:       7:	ff 71 fc             	push   -0x4(%ecx)
./usertests.asm:35:    printf(1, "already ran user tests -- rebuild fs.img\n");
./usertests.asm:570:     5ce:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:709:      if(n == MAXFILE - 1){
./usertests.asm:729:     783:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:857:     8e1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:982:     a25:	8d 45 e0             	lea    -0x20(%ebp),%eax
./usertests.asm:1002:     a55:	ff 75 e4             	push   -0x1c(%ebp)
./usertests.asm:1014:     a70:	ff 75 e0             	push   -0x20(%ebp)
./usertests.asm:1054:     ad6:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1062:     ae1:	ff 75 e0             	push   -0x20(%ebp)
./usertests.asm:1086:     b1e:	ff 75 e4             	push   -0x1c(%ebp)
./usertests.asm:1101:     b48:	ff 75 e0             	push   -0x20(%ebp)
./usertests.asm:1184:     c03:	8d 45 e0             	lea    -0x20(%ebp),%eax
./usertests.asm:1198:     c1d:	ff 75 e0             	push   -0x20(%ebp)
./usertests.asm:1204:     c2f:	ff 75 e4             	push   -0x1c(%ebp)
./usertests.asm:1211:     c46:	ff 75 e4             	push   -0x1c(%ebp)
./usertests.asm:1219:     c5b:	ff 75 e4             	push   -0x1c(%ebp)
./usertests.asm:1225:     c70:	ff 75 e0             	push   -0x20(%ebp)
./usertests.asm:1232:     c83:	ff 75 e0             	push   -0x20(%ebp)
./usertests.asm:1269:     cdf:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1325:     d5d:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:1339:     d7a:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:1351:     d93:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:1443:     e58:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:1480:     eaf:	8d 75 de             	lea    -0x22(%ebp),%esi
./usertests.asm:1487:     ebf:	89 45 d4             	mov    %eax,-0x2c(%ebp)
./usertests.asm:1520:     f0b:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
./usertests.asm:1531:     f21:	8d 7d e8             	lea    -0x18(%ebp),%edi
./usertests.asm:1544:     f3c:	89 45 d0             	mov    %eax,-0x30(%ebp)
./usertests.asm:1553:     f53:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./usertests.asm:1556:     f59:	ff 75 d0             	push   -0x30(%ebp)
./usertests.asm:1561:     f68:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./usertests.asm:1585:     f93:	ff 75 d0             	push   -0x30(%ebp)
./usertests.asm:1591:     fa7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./usertests.asm:1604:     fcf:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1618:     fe9:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1632:    1003:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1664:    103b:	c7 45 d8 8e 41 00 00 	movl   $0x418e,-0x28(%ebp)
./usertests.asm:1665:    1042:	c7 45 dc d7 42 00 00 	movl   $0x42d7,-0x24(%ebp)
./usertests.asm:1666:    1049:	c7 45 e0 db 42 00 00 	movl   $0x42db,-0x20(%ebp)
./usertests.asm:1667:    1050:	c7 45 e4 91 41 00 00 	movl   $0x4191,-0x1c(%ebp)
./usertests.asm:1674:    1066:	8b 74 9d d8          	mov    -0x28(%ebp,%ebx,4),%esi
./usertests.asm:1698:    10a7:	8b 44 b5 d8          	mov    -0x28(%ebp,%esi,4),%eax
./usertests.asm:1706:    10b5:	89 45 d0             	mov    %eax,-0x30(%ebp)
./usertests.asm:1713:    10c3:	89 75 cc             	mov    %esi,-0x34(%ebp)
./usertests.asm:1714:    10c6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
./usertests.asm:1719:    10dd:	ff 75 d4             	push   -0x2c(%ebp)
./usertests.asm:1743:    1111:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
./usertests.asm:1745:    1117:	8b 75 cc             	mov    -0x34(%ebp),%esi
./usertests.asm:1754:    1132:	ff 75 d0             	push   -0x30(%ebp)
./usertests.asm:1769:    115d:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1884:    126e:	8d 75 c8             	lea    -0x38(%ebp),%esi
./usertests.asm:1890:    1280:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
./usertests.asm:1902:    1298:	88 45 c6             	mov    %al,-0x3a(%ebp)
./usertests.asm:1906:    12a0:	88 55 c7             	mov    %dl,-0x39(%ebp)
./usertests.asm:1908:    12a3:	0f b6 45 c6          	movzbl -0x3a(%ebp),%eax
./usertests.asm:1912:    12aa:	88 5d c8             	mov    %bl,-0x38(%ebp)
./usertests.asm:1914:    12ad:	88 45 c9             	mov    %al,-0x37(%ebp)
./usertests.asm:1921:    12bb:	80 7d c7 00          	cmpb   $0x0,-0x39(%ebp)
./usertests.asm:1941:    12f0:	8d 47 c0             	lea    -0x40(%edi),%eax
./usertests.asm:1943:    12f8:	88 45 c7             	mov    %al,-0x39(%ebp)
./usertests.asm:1949:    1300:	88 45 c8             	mov    %al,-0x38(%ebp)
./usertests.asm:1951:    1303:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
./usertests.asm:1952:    1307:	88 45 c9             	mov    %al,-0x37(%ebp)
./usertests.asm:1972:    1333:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:1996:    1363:	c6 45 ca 00          	movb   $0x0,-0x36(%ebp)
./usertests.asm:1997:    1367:	8d 75 c8             	lea    -0x38(%ebp),%esi
./usertests.asm:1999:    136a:	88 45 c8             	mov    %al,-0x38(%ebp)
./usertests.asm:2006:    1376:	88 45 c9             	mov    %al,-0x37(%ebp)
./usertests.asm:2042:    13c9:	88 45 c9             	mov    %al,-0x37(%ebp)
./usertests.asm:2186:    153f:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:2365:    171d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:2385:    printf(1, "link non-existant succeeded! oops\n");
./usertests.asm:2452:    17d8:	8d 5d ad             	lea    -0x53(%ebp),%ebx
./usertests.asm:2459:    17ea:	c6 45 ad 43          	movb   $0x43,-0x53(%ebp)
./usertests.asm:2462:    17f1:	c6 45 af 00          	movb   $0x0,-0x51(%ebp)
./usertests.asm:2498:    1849:	88 45 ae             	mov    %al,-0x52(%ebp)
./usertests.asm:2547:    18c5:	8d 45 c0             	lea    -0x40(%ebp),%eax
./usertests.asm:2557:    18db:	8d 7d b0             	lea    -0x50(%ebp),%edi
./usertests.asm:2562:    18e6:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%ebp)
./usertests.asm:2576:    1903:	66 83 7d b0 00       	cmpw   $0x0,-0x50(%ebp)
./usertests.asm:2579:    190a:	80 7d b2 43          	cmpb   $0x43,-0x4e(%ebp)
./usertests.asm:2581:    1910:	80 7d b4 00          	cmpb   $0x0,-0x4c(%ebp)
./usertests.asm:2583:      i = de.name[1] - '0';
./usertests.asm:2584:    1916:	0f be 45 b3          	movsbl -0x4d(%ebp),%eax
./usertests.asm:2590:    1926:	80 7c 05 c0 00       	cmpb   $0x0,-0x40(%ebp,%eax,1)
./usertests.asm:2593:    1931:	83 45 a4 01          	addl   $0x1,-0x5c(%ebp)
./usertests.asm:2595:    1935:	c6 44 05 c0 01       	movb   $0x1,-0x40(%ebp,%eax,1)
./usertests.asm:2616:    196c:	83 7d a4 28          	cmpl   $0x28,-0x5c(%ebp)
./usertests.asm:2652:    19c5:	88 45 ae             	mov    %al,-0x52(%ebp)
./usertests.asm:2711:    1a57:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:2732:    1a87:	8d 45 b2             	lea    -0x4e(%ebp),%eax
./usertests.asm:2749:    1ab2:	8d 45 b2             	lea    -0x4e(%ebp),%eax
./usertests.asm:2780:    1af9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
./usertests.asm:2785:    1b04:	83 7d e4 01          	cmpl   $0x1,-0x1c(%ebp)
./usertests.asm:2831:    1b7b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
./usertests.asm:2842:    1b96:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:2899:    1c22:	8d 7d de             	lea    -0x22(%ebp),%edi
./usertests.asm:2910:    1c35:	c6 45 de 78          	movb   $0x78,-0x22(%ebp)
./usertests.asm:2914:    1c3c:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
./usertests.asm:2917:    1c43:	88 45 df             	mov    %al,-0x21(%ebp)
./usertests.asm:2922:    1c4e:	88 45 e0             	mov    %al,-0x20(%ebp)
./usertests.asm:2945:    1c85:	c6 45 de 78          	movb   $0x78,-0x22(%ebp)
./usertests.asm:2949:    1c8c:	c6 45 e1 00          	movb   $0x0,-0x1f(%ebp)
./usertests.asm:2952:    1c93:	88 45 df             	mov    %al,-0x21(%ebp)
./usertests.asm:2957:    1c9e:	88 45 e0             	mov    %al,-0x20(%ebp)
./usertests.asm:2975:    1ccb:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:3348:    214f:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:3512:    printf(1, "unlink dd (non-empty dir) succeeded!\n");
./usertests.asm:3552:    printf(1, "unlink non-empty dd succeeded!\n");
./usertests.asm:3705:    249f:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:3846:    2600:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:4286:    2aa4:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:4453:    2c4b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:4500:  for(; n > 0; n--){
./usertests.asm:4508:  for(; n > 0; n--){
./usertests.asm:4511:  if(wait() != -1){
./usertests.asm:4521:    2ce7:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:4569:    2d57:	89 45 a4             	mov    %eax,-0x5c(%ebp)
./usertests.asm:4626:  amt = (BIG) - (uint)a;
./usertests.asm:4643:  c = sbrk(-4096);
./usertests.asm:4647:  c = sbrk(-4096);
./usertests.asm:4657:  if(c != a - 4096){
./usertests.asm:4658:    2e33:	8d 93 00 f0 ff ff    	lea    -0x1000(%ebx),%edx
./usertests.asm:4693:  c = sbrk(-(sbrk(0) - oldbrk));
./usertests.asm:4697:  c = sbrk(-(sbrk(0) - oldbrk));
./usertests.asm:4700:    2eab:	8b 45 a4             	mov    -0x5c(%ebp),%eax
./usertests.asm:4730:    2f00:	8d 45 b8             	lea    -0x48(%ebp),%eax
./usertests.asm:4736:    2f14:	8d 5d c0             	lea    -0x40(%ebp),%ebx
./usertests.asm:4737:    2f17:	8d 75 e8             	lea    -0x18(%ebp),%esi
./usertests.asm:4745:    if(pids[i] != -1)
./usertests.asm:4750:    2f37:	8d 45 b7             	lea    -0x49(%ebp),%eax
./usertests.asm:4753:    2f3d:	ff 75 b8             	push   -0x48(%ebp)
./usertests.asm:4768:    if(pids[i] == -1)
./usertests.asm:4791:    2f9d:	39 45 a4             	cmp    %eax,-0x5c(%ebp)
./usertests.asm:4800:    2fb8:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:4806:      sbrk(BIG - (uint)sbrk(0));
./usertests.asm:4819:    2fe5:	ff 75 bc             	push   -0x44(%ebp)
./usertests.asm:4828:    sbrk(-(sbrk(0) - oldbrk));
./usertests.asm:4833:    300e:	8b 45 a4             	mov    -0x5c(%ebp),%eax
./usertests.asm:4893:    printf(stdout, "sbrk de-allocation didn't really deallocate\n");
./usertests.asm:4919:    printf(stdout, "sbrk test failed post-fork\n");
./usertests.asm:4927:    printf(stdout, "sbrk re-allocation failed, a %x c %x\n", a, c);
./usertests.asm:4995:    if(link("nosuchfile", (char*)p) != -1){
./usertests.asm:5015:    3207:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:5076:  unlink("bigarg-ok");
./usertests.asm:5089:  fd = open("bigarg-ok", 0);
./usertests.asm:5102:  unlink("bigarg-ok");
./usertests.asm:5112:    for(i = 0; i < MAXARG-1; i++)
./usertests.asm:5119:    for(i = 0; i < MAXARG-1; i++)
./usertests.asm:5125:    args[MAXARG-1] = 0;
./usertests.asm:5131:    args[MAXARG-1] = 0;
./usertests.asm:5147:    fd = open("bigarg-ok", O_CREATE);
./usertests.asm:5202:    33ed:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
./usertests.asm:5206:    33f3:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
./usertests.asm:5210:    33fd:	88 45 a9             	mov    %al,-0x57(%ebp)
./usertests.asm:5222:    341c:	88 55 aa             	mov    %dl,-0x56(%ebp)
./usertests.asm:5236:    3437:	88 55 ab             	mov    %dl,-0x55(%ebp)
./usertests.asm:5245:    344b:	88 45 ac             	mov    %al,-0x54(%ebp)
./usertests.asm:5247:    344e:	8d 45 a8             	lea    -0x58(%ebp),%eax
./usertests.asm:5254:    345f:	8d 45 a8             	lea    -0x58(%ebp),%eax
./usertests.asm:5300:    34c9:	8d 45 a8             	lea    -0x58(%ebp),%eax
./usertests.asm:5319:    34f5:	c6 45 a8 66          	movb   $0x66,-0x58(%ebp)
./usertests.asm:5323:    34fb:	c6 45 ad 00          	movb   $0x0,-0x53(%ebp)
./usertests.asm:5327:    3505:	88 45 a9             	mov    %al,-0x57(%ebp)
./usertests.asm:5339:    351e:	88 55 aa             	mov    %dl,-0x56(%ebp)
./usertests.asm:5354:    353e:	88 55 ab             	mov    %dl,-0x55(%ebp)
./usertests.asm:5358:    nfiles--;
./usertests.asm:5366:    3555:	88 45 ac             	mov    %al,-0x54(%ebp)
./usertests.asm:5368:    3558:	8d 45 a8             	lea    -0x58(%ebp),%eax
./usertests.asm:5382:    357b:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:5458:  read(fd, sbrk(0) - 1, -1);
./usertests.asm:5479:    364b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:5538:    36ae:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:5573:  return (uchar)*p - (uchar)*q;
./usertests.asm:5576:    36f1:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:5582:  return (uchar)*p - (uchar)*q;
./usertests.asm:5587:    3708:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:5590:  return (uchar)*p - (uchar)*q;
./usertests.asm:5657:    3762:	8b 7d fc             	mov    -0x4(%ebp),%edi
./usertests.asm:5714:    37b5:	8d 75 e7             	lea    -0x19(%ebp),%esi
./usertests.asm:5735:    37d4:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./usertests.asm:5737:    37db:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./usertests.asm:5756:    37fa:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:5787:    return -1;
./usertests.asm:5803:    3844:	8d 65 f8             	lea    -0x8(%ebp),%esp
./usertests.asm:5810:    return -1;
./usertests.asm:5831:    386a:	8d 48 d0             	lea    -0x30(%eax),%ecx
./usertests.asm:5840:    n = n*10 + *s++ - '0';
./usertests.asm:5843:    3886:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./usertests.asm:5846:    388d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./usertests.asm:5851:    3895:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./usertests.asm:5874:  while(n-- > 0)
./usertests.asm:5885:  while(n-- > 0)
./usertests.asm:6054:    x = -xx;
./usertests.asm:6058:    398d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./usertests.asm:6064:    x = -xx;
./usertests.asm:6073:    39a5:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./usertests.asm:6084:    39c2:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./usertests.asm:6091:    39ce:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./usertests.asm:6094:    buf[i++] = '-';
./usertests.asm:6095:    39d5:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./usertests.asm:6097:  while(--i >= 0)
./usertests.asm:6099:    39dc:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./usertests.asm:6100:    39df:	8b 75 c0             	mov    -0x40(%ebp),%esi
./usertests.asm:6107:    39ee:	88 45 d7             	mov    %al,-0x29(%ebp)
./usertests.asm:6108:    39f1:	8d 45 d7             	lea    -0x29(%ebp),%eax
./usertests.asm:6113:  while(--i >= 0)
./usertests.asm:6120:    3a09:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:6160:    3a3e:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./usertests.asm:6163:    3a48:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./usertests.asm:6174:    3a58:	8d 45 e7             	lea    -0x19(%ebp),%eax
./usertests.asm:6175:    3a5b:	88 5d e7             	mov    %bl,-0x19(%ebp)
./usertests.asm:6180:    3a67:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./usertests.asm:6212:    3aa0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:6222:    3ab3:	8d 55 e7             	lea    -0x19(%ebp),%edx
./usertests.asm:6223:    3ab6:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./usertests.asm:6226:    3abd:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./usertests.asm:6230:    3ac9:	88 5d e7             	mov    %bl,-0x19(%ebp)
./usertests.asm:6232:    3ace:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./usertests.asm:6243:    3ae0:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./usertests.asm:6254:    3af9:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./usertests.asm:6260:    3b06:	8b 45 d0             	mov    -0x30(%ebp),%eax
./usertests.asm:6264:    3b0e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./usertests.asm:6275:    3b26:	8d 55 e7             	lea    -0x19(%ebp),%edx
./usertests.asm:6276:    3b29:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./usertests.asm:6281:    3b33:	88 45 e7             	mov    %al,-0x19(%ebp)
./usertests.asm:6295:    3b4c:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./usertests.asm:6299:    3b56:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./usertests.asm:6306:    3b67:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./usertests.asm:6309:    3b6d:	8d 55 e7             	lea    -0x19(%ebp),%edx
./usertests.asm:6315:    3b75:	88 45 e7             	mov    %al,-0x19(%ebp)
./usertests.asm:6322:    3b81:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./usertests.asm:6330:    3b93:	88 5d e7             	mov    %bl,-0x19(%ebp)
./usertests.asm:6331:    3b96:	8d 55 e7             	lea    -0x19(%ebp),%edx
./usertests.asm:6350:  bp = (Header*)ap - 1;
./usertests.asm:6351:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./usertests.asm:6359:  bp = (Header*)ap - 1;
./usertests.asm:6360:    3bbe:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./usertests.asm:6361:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./usertests.asm:6363:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./usertests.asm:6365:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./usertests.asm:6370:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./usertests.asm:6374:  if(bp + bp->s.size == p->s.ptr){
./usertests.asm:6375:    3bd6:	8b 73 fc             	mov    -0x4(%ebx),%esi
./usertests.asm:6379:    bp->s.size += p->s.ptr->s.size;
./usertests.asm:6380:    bp->s.ptr = p->s.ptr->s.ptr;
./usertests.asm:6381:    3be0:	89 53 f8             	mov    %edx,-0x8(%ebx)
./usertests.asm:6383:    bp->s.ptr = p->s.ptr;
./usertests.asm:6384:  if(p + p->s.size == bp){
./usertests.asm:6389:    p->s.size += bp->s.size;
./usertests.asm:6390:    p->s.ptr = bp->s.ptr;
./usertests.asm:6393:    p->s.ptr = bp;
./usertests.asm:6405:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./usertests.asm:6414:    bp->s.size += p->s.ptr->s.size;
./usertests.asm:6416:    3c13:	89 73 fc             	mov    %esi,-0x4(%ebx)
./usertests.asm:6417:    bp->s.ptr = p->s.ptr->s.ptr;
./usertests.asm:6420:    3c1a:	89 53 f8             	mov    %edx,-0x8(%ebx)
./usertests.asm:6421:  if(p + p->s.size == bp){
./usertests.asm:6426:    p->s.size += bp->s.size;
./usertests.asm:6427:    3c27:	03 53 fc             	add    -0x4(%ebx),%edx
./usertests.asm:6430:    p->s.size += bp->s.size;
./usertests.asm:6432:    p->s.ptr = bp->s.ptr;
./usertests.asm:6433:    3c32:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./usertests.asm:6459:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./usertests.asm:6463:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./usertests.asm:6473:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./usertests.asm:6475:    if(p->s.size >= nunits){
./usertests.asm:6487:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./usertests.asm:6489:    if(p->s.size >= nunits){
./usertests.asm:6493:        p->s.size = nunits;
./usertests.asm:6506:  if(p == (char*)-1)
./usertests.asm:6510:  hp->s.size = nu;
./usertests.asm:6526:    3cc0:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:6536:      if(p->s.size == nunits)
./usertests.asm:6539:        p->s.size -= nunits;
./usertests.asm:6542:        p += p->s.size;
./usertests.asm:6544:        p->s.size = nunits;
./usertests.asm:6549:    3ce5:	8d 65 f4             	lea    -0xc(%ebp),%esp
./usertests.asm:6569:    if(p->s.size >= nunits){
./usertests.asm:6573:        prevp->s.ptr = p->s.ptr;
./stressfs.asm:2:_stressfs:     file format elf32-i386
./stressfs.asm:20:   c:	ff 71 fc             	push   -0x4(%ecx)
./stressfs.asm:29:  14:	8d b5 e8 fd ff ff    	lea    -0x218(%ebp),%esi
./stressfs.asm:39:  24:	66 89 85 e6 fd ff ff 	mov    %ax,-0x21a(%ebp)
./stressfs.asm:44:  32:	c7 85 de fd ff ff 73 	movl   $0x65727473,-0x222(%ebp)
./stressfs.asm:46:  3c:	c7 85 e2 fd ff ff 73 	movl   $0x73667373,-0x21e(%ebp)
./stressfs.asm:78:  81:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax
./stressfs.asm:82:  8d:	00 9d e6 fd ff ff    	add    %bl,-0x21a(%ebp)
./stressfs.asm:114:  d6:	8d 85 de fd ff ff    	lea    -0x222(%ebp),%eax
./stressfs.asm:176: 13e:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./stressfs.asm:211:  return (uchar)*p - (uchar)*q;
./stressfs.asm:214: 181:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./stressfs.asm:220:  return (uchar)*p - (uchar)*q;
./stressfs.asm:225: 198:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./stressfs.asm:228:  return (uchar)*p - (uchar)*q;
./stressfs.asm:295: 1f2:	8b 7d fc             	mov    -0x4(%ebp),%edi
./stressfs.asm:352: 245:	8d 75 e7             	lea    -0x19(%ebp),%esi
./stressfs.asm:373: 264:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
./stressfs.asm:375: 26b:	88 44 1a ff          	mov    %al,-0x1(%edx,%ebx,1)
./stressfs.asm:394: 28a:	8d 65 f4             	lea    -0xc(%ebp),%esp
./stressfs.asm:425:    return -1;
./stressfs.asm:441: 2d4:	8d 65 f8             	lea    -0x8(%ebp),%esp
./stressfs.asm:448:    return -1;
./stressfs.asm:469: 2fa:	8d 48 d0             	lea    -0x30(%eax),%ecx
./stressfs.asm:478:    n = n*10 + *s++ - '0';
./stressfs.asm:481: 316:	8d 4c 48 d0          	lea    -0x30(%eax,%ecx,2),%ecx
./stressfs.asm:484: 31d:	8d 58 d0             	lea    -0x30(%eax),%ebx
./stressfs.asm:489: 325:	8b 5d fc             	mov    -0x4(%ebp),%ebx
./stressfs.asm:512:  while(n-- > 0)
./stressfs.asm:523:  while(n-- > 0)
./stressfs.asm:692:    x = -xx;
./stressfs.asm:696: 41d:	89 45 c0             	mov    %eax,-0x40(%ebp)
./stressfs.asm:702:    x = -xx;
./stressfs.asm:711: 435:	89 45 c4             	mov    %eax,-0x3c(%ebp)
./stressfs.asm:722: 452:	88 54 35 d7          	mov    %dl,-0x29(%ebp,%esi,1)
./stressfs.asm:729: 45e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
./stressfs.asm:732:    buf[i++] = '-';
./stressfs.asm:733: 465:	c6 44 35 d8 2d       	movb   $0x2d,-0x28(%ebp,%esi,1)
./stressfs.asm:735:  while(--i >= 0)
./stressfs.asm:737: 46c:	8d 5d d8             	lea    -0x28(%ebp),%ebx
./stressfs.asm:738: 46f:	8b 75 c0             	mov    -0x40(%ebp),%esi
./stressfs.asm:745: 47e:	88 45 d7             	mov    %al,-0x29(%ebp)
./stressfs.asm:746: 481:	8d 45 d7             	lea    -0x29(%ebp),%eax
./stressfs.asm:751:  while(--i >= 0)
./stressfs.asm:758: 499:	8d 65 f4             	lea    -0xc(%ebp),%esp
./stressfs.asm:798: 4ce:	89 4d d0             	mov    %ecx,-0x30(%ebp)
./stressfs.asm:801: 4d8:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./stressfs.asm:812: 4e8:	8d 45 e7             	lea    -0x19(%ebp),%eax
./stressfs.asm:813: 4eb:	88 5d e7             	mov    %bl,-0x19(%ebp)
./stressfs.asm:818: 4f7:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./stressfs.asm:850: 530:	8d 65 f4             	lea    -0xc(%ebp),%esp
./stressfs.asm:860: 543:	8d 55 e7             	lea    -0x19(%ebp),%edx
./stressfs.asm:861: 546:	c6 45 e7 25          	movb   $0x25,-0x19(%ebp)
./stressfs.asm:864: 54d:	89 55 d4             	mov    %edx,-0x2c(%ebp)
./stressfs.asm:868: 559:	88 5d e7             	mov    %bl,-0x19(%ebp)
./stressfs.asm:870: 55e:	8b 55 d4             	mov    -0x2c(%ebp),%edx
./stressfs.asm:881: 570:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./stressfs.asm:892: 589:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./stressfs.asm:898: 596:	8b 45 d0             	mov    -0x30(%ebp),%eax
./stressfs.asm:902: 59e:	89 45 d0             	mov    %eax,-0x30(%ebp)
./stressfs.asm:913: 5b6:	8d 55 e7             	lea    -0x19(%ebp),%edx
./stressfs.asm:914: 5b9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
./stressfs.asm:919: 5c3:	88 45 e7             	mov    %al,-0x19(%ebp)
./stressfs.asm:933: 5dc:	8b 75 d4             	mov    -0x2c(%ebp),%esi
./stressfs.asm:937: 5e6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./stressfs.asm:944: 5f7:	8b 5d d0             	mov    -0x30(%ebp),%ebx
./stressfs.asm:947: 5fd:	8d 55 e7             	lea    -0x19(%ebp),%edx
./stressfs.asm:953: 605:	88 45 e7             	mov    %al,-0x19(%ebp)
./stressfs.asm:960: 611:	89 5d d0             	mov    %ebx,-0x30(%ebp)
./stressfs.asm:968: 623:	88 5d e7             	mov    %bl,-0x19(%ebp)
./stressfs.asm:969: 626:	8d 55 e7             	lea    -0x19(%ebp),%edx
./stressfs.asm:988:  bp = (Header*)ap - 1;
./stressfs.asm:989:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./stressfs.asm:997:  bp = (Header*)ap - 1;
./stressfs.asm:998: 64e:	8d 4b f8             	lea    -0x8(%ebx),%ecx
./stressfs.asm:999:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./stressfs.asm:1001:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./stressfs.asm:1003:  for(p = freep; !(bp > p && bp < p->s.ptr); p = p->s.ptr)
./stressfs.asm:1008:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./stressfs.asm:1012:  if(bp + bp->s.size == p->s.ptr){
./stressfs.asm:1013: 666:	8b 73 fc             	mov    -0x4(%ebx),%esi
./stressfs.asm:1017:    bp->s.size += p->s.ptr->s.size;
./stressfs.asm:1018:    bp->s.ptr = p->s.ptr->s.ptr;
./stressfs.asm:1019: 670:	89 53 f8             	mov    %edx,-0x8(%ebx)
./stressfs.asm:1021:    bp->s.ptr = p->s.ptr;
./stressfs.asm:1022:  if(p + p->s.size == bp){
./stressfs.asm:1027:    p->s.size += bp->s.size;
./stressfs.asm:1028:    p->s.ptr = bp->s.ptr;
./stressfs.asm:1031:    p->s.ptr = bp;
./stressfs.asm:1043:    if(p >= p->s.ptr && (bp > p || bp < p->s.ptr))
./stressfs.asm:1052:    bp->s.size += p->s.ptr->s.size;
./stressfs.asm:1054: 6a3:	89 73 fc             	mov    %esi,-0x4(%ebx)
./stressfs.asm:1055:    bp->s.ptr = p->s.ptr->s.ptr;
./stressfs.asm:1058: 6aa:	89 53 f8             	mov    %edx,-0x8(%ebx)
./stressfs.asm:1059:  if(p + p->s.size == bp){
./stressfs.asm:1064:    p->s.size += bp->s.size;
./stressfs.asm:1065: 6b7:	03 53 fc             	add    -0x4(%ebx),%edx
./stressfs.asm:1068:    p->s.size += bp->s.size;
./stressfs.asm:1070:    p->s.ptr = bp->s.ptr;
./stressfs.asm:1071: 6c2:	8b 4b f8             	mov    -0x8(%ebx),%ecx
./stressfs.asm:1097:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./stressfs.asm:1101:  nunits = (nbytes + sizeof(Header) - 1)/sizeof(Header) + 1;
./stressfs.asm:1111:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./stressfs.asm:1113:    if(p->s.size >= nunits){
./stressfs.asm:1125:  for(p = prevp->s.ptr; ; prevp = p, p = p->s.ptr){
./stressfs.asm:1127:    if(p->s.size >= nunits){
./stressfs.asm:1131:        p->s.size = nunits;
./stressfs.asm:1144:  if(p == (char*)-1)
./stressfs.asm:1148:  hp->s.size = nu;
./stressfs.asm:1164: 750:	8d 65 f4             	lea    -0xc(%ebp),%esp
./stressfs.asm:1174:      if(p->s.size == nunits)
./stressfs.asm:1177:        p->s.size -= nunits;
./stressfs.asm:1180:        p += p->s.size;
./stressfs.asm:1182:        p->s.size = nunits;
./stressfs.asm:1187: 775:	8d 65 f4             	lea    -0xc(%ebp),%esp
./stressfs.asm:1207:    if(p->s.size >= nunits){
./stressfs.asm:1211:        prevp->s.ptr = p->s.ptr;
./entryother.asm:2:bootblockother.o:     file format elf32-i386
./entryother.asm:39:  # Complete the transition to 32-bit protected mode by using a long jmp
./entryother.asm:49:.code32  # Tell assembler to generate 32-bit code now.
./entryother.asm:51:  # Set up the protected-mode data segment registers
./entryother.asm:54:  movw    %ax, %ds                # -> DS: Data Segment
./entryother.asm:56:  movw    %ax, %es                # -> ES: Extra Segment
./entryother.asm:58:  movw    %ax, %ss                # -> SS: Stack Segment
./entryother.asm:62:  movw    %ax, %fs                # -> FS
./entryother.asm:64:  movw    %ax, %gs                # -> GS
./entryother.asm:75:  movl    (start-12), %eax
./entryother.asm:88:  movl    (start-4), %esp
./entryother.asm:91:  call	 *(start-8)
./sysproc.c:35:    return -1;
./sysproc.c:42:  return myproc()->pid;
./sysproc.c:52:    return -1;
./sysproc.c:53:  addr = myproc()->sz;
./sysproc.c:55:    return -1;
./sysproc.c:66:    return -1;
./sysproc.c:69:  while(ticks - ticks0 < n){
./sysproc.c:70:    if(myproc()->killed){
./sysproc.c:72:      return -1;
./sysproc.c:93://------------------------------------------------------------------------------------------------------------->
./sysproc.c:99:        return -1;
./sysproc.c:100:    myproc()->sighandler = handler;
./sysproc.c:104://-------------------------------------------------------------------------------------------------------------->
./console.c:39:    x = -xx;
./console.c:49:    buf[i++] = '-';
./console.c:51:  while(--i >= 0)
./console.c:146:    pos += 80 - pos%80;
./console.c:148:    if(pos > 0) --pos;
./console.c:157:    pos -= 80;
./console.c:158:    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
./console.c:192:#define C(x)  ((x)-'@')  // Control-x // ASCII
./console.c:205:      cprintf("Ctrl - P is detected by xv6\n");
./console.c:209:            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
./console.c:210:        input.e--;
./console.c:217:        input.e--;
./console.c:223:		cprintf("Ctrl - C is detected by xv6\n");
./console.c:227:		cprintf("Ctrl - B is detected by xv6\n");
./console.c:231:		cprintf("Ctrl - F is detected by xv6\n");
./console.c:235:		cprintf("Ctrl - G is detected by xv6\n");
./console.c:243:      if(c != 0 && input.e-input.r < INPUT_BUF){
./console.c:273:      if(myproc()->killed){
./console.c:276:        return -1;
./console.c:284:        // caller gets a 0-byte result.
./console.c:285:        input.r--;
./console.c:290:    --n;
./console.c:297:  return target - n;
./.git/hooks/pre-applypatch.sample:4:# by applypatch from an e-mail message.
./.git/hooks/pre-applypatch.sample:6:# The hook should exit with non-zero status after issuing an
./.git/hooks/pre-applypatch.sample:9:# To enable this hook, rename this file to "pre-applypatch".
./.git/hooks/pre-applypatch.sample:11:. git-sh-setup
./.git/hooks/pre-applypatch.sample:12:precommit="$(git rev-parse --git-path hooks/pre-commit)"
./.git/hooks/pre-applypatch.sample:13:test -x "$precommit" && exec "$precommit" ${1+"$@"}
./.git/hooks/fsmonitor-watchman.sample:16:# To enable this hook, rename this file to "query-watchman" and set
./.git/hooks/fsmonitor-watchman.sample:17:# 'git config core.fsmonitor .git/hooks/query-watchman'
./.git/hooks/fsmonitor-watchman.sample:26:	die "Unsupported query-fsmonitor hook version '$version'.\n" .
./.git/hooks/fsmonitor-watchman.sample:49:		output_result($o->{clock}, @{$o->{files}});
./.git/hooks/fsmonitor-watchman.sample:57:	# open (my $fh, ">", ".git/watchman-output.out");
./.git/hooks/fsmonitor-watchman.sample:74:	return $json_pkg->new->utf8->decode($response);
./.git/hooks/fsmonitor-watchman.sample:78:	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
./.git/hooks/fsmonitor-watchman.sample:102:	# open (my $fh, ">", ".git/watchman-query.json");
./.git/hooks/fsmonitor-watchman.sample:111:	# open ($fh, ">", ".git/watchman-response.json");
./.git/hooks/fsmonitor-watchman.sample:120:	return $json_pkg->new->utf8->decode($response);
./.git/hooks/fsmonitor-watchman.sample:125:	my $error = $output->{error};
./.git/hooks/fsmonitor-watchman.sample:127:		$retry--;
./.git/hooks/fsmonitor-watchman.sample:131:		$output = $json_pkg->new->utf8->decode($response);
./.git/hooks/fsmonitor-watchman.sample:132:		$error = $output->{error};
./.git/hooks/fsmonitor-watchman.sample:137:		# open (my $fh, ">", ".git/watchman-output.out");
./.git/hooks/fsmonitor-watchman.sample:145:		$error = $output->{error};
./.git/hooks/fsmonitor-watchman.sample:150:		output_result($o->{clock}, ("/"));
./.git/hooks/fsmonitor-watchman.sample:151:		$last_update_token = $o->{clock};
./.git/hooks/push-to-checkout.sample:3:# An example hook script to update a checked-out tree on a git push.
./.git/hooks/push-to-checkout.sample:5:# This hook is invoked by git-receive-pack(1) when it reacts to git
./.git/hooks/push-to-checkout.sample:23:# It can exit with a non-zero status to refuse the push (when it does
./.git/hooks/push-to-checkout.sample:34:# For example, the hook can simply run git read-tree -u -m HEAD "$1"
./.git/hooks/push-to-checkout.sample:36:# with git push, as the two-tree form of git read-tree -u -m is
./.git/hooks/push-to-checkout.sample:41:# The below is a more-or-less exact translation to shell of the C code
./.git/hooks/push-to-checkout.sample:42:# for the default behaviour for git's push-to-checkout hook defined in
./.git/hooks/push-to-checkout.sample:43:# the push_to_deploy() function in builtin/receive-pack.c.
./.git/hooks/push-to-checkout.sample:50:if ! git update-index -q --ignore-submodules --refresh
./.git/hooks/push-to-checkout.sample:52:	die "Up-to-date check failed"
./.git/hooks/push-to-checkout.sample:55:if ! git diff-files --quiet --ignore-submodules --
./.git/hooks/push-to-checkout.sample:63:if git cat-file -e HEAD 2>/dev/null
./.git/hooks/push-to-checkout.sample:67:	head=$(git hash-object -t tree --stdin </dev/null)
./.git/hooks/push-to-checkout.sample:70:if ! git diff-index --quiet --cached --ignore-submodules $head --
./.git/hooks/push-to-checkout.sample:75:if ! git read-tree -u -m "$commit"
./.git/hooks/pre-commit.sample:5:# exit with non-zero status after issuing an appropriate message if
./.git/hooks/pre-commit.sample:8:# To enable this hook, rename this file to "pre-commit".
./.git/hooks/pre-commit.sample:10:if git rev-parse --verify HEAD >/dev/null 2>&1
./.git/hooks/pre-commit.sample:15:	against=$(git hash-object -t tree /dev/null)
./.git/hooks/pre-commit.sample:18:# If you want to allow non-ASCII filenames set this variable to true.
./.git/hooks/pre-commit.sample:19:allownonascii=$(git config --type=bool hooks.allownonascii)
./.git/hooks/pre-commit.sample:24:# Cross platform projects tend to avoid non-ASCII filenames; prevent
./.git/hooks/pre-commit.sample:31:	test $(git diff --cached --name-only --diff-filter=A -z $against |
./.git/hooks/pre-commit.sample:32:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
./.git/hooks/pre-commit.sample:35:Error: Attempt to add a non-ASCII file name.
./.git/hooks/pre-commit.sample:49:exec git diff-index --check --cached $against --
./.git/hooks/pre-push.sample:5:# pushed.  If this script exits with a non-zero status nothing will be pushed.
./.git/hooks/pre-push.sample:9:# $1 -- Name of the remote to which the push is being done
./.git/hooks/pre-push.sample:10:# $2 -- URL to which the push is being done
./.git/hooks/pre-push.sample:25:zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
./.git/hooks/pre-push.sample:44:		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
./.git/hooks/pre-push.sample:45:		if test -n "$commit"
./.git/hooks/pre-rebase.sample:5:# The "pre-rebase" hook is run just before "git rebase" starts doing
./.git/hooks/pre-rebase.sample:7:# non-zero status.
./.git/hooks/pre-rebase.sample:11:# $1 -- the upstream the series was forked from.
./.git/hooks/pre-rebase.sample:12:# $2 -- the branch being rebased (or empty when rebasing the current branch).
./.git/hooks/pre-rebase.sample:24:	topic=`git symbolic-ref HEAD` ||
./.git/hooks/pre-rebase.sample:40:git show-ref -q "$topic" || {
./.git/hooks/pre-rebase.sample:46:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
./.git/hooks/pre-rebase.sample:47:if test -z "$not_in_master"
./.git/hooks/pre-rebase.sample:54:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
./.git/hooks/pre-rebase.sample:55:only_next_2=`git rev-list ^master           ${publish} | sort`
./.git/hooks/pre-rebase.sample:58:	not_in_topic=`git rev-list "^$topic" master`
./.git/hooks/pre-rebase.sample:59:	if test -z "$not_in_topic"
./.git/hooks/pre-rebase.sample:67:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
./.git/hooks/pre-rebase.sample:68:	/usr/bin/perl -e '
./.git/hooks/pre-rebase.sample:72:			/^([0-9a-f]+) /;
./.git/hooks/pre-rebase.sample:76:				/^([0-9a-f]+) (.*)$/;
./.git/hooks/pre-rebase.sample:79:			if (!exists $not_in_next{$elem->[0]}) {
./.git/hooks/pre-rebase.sample:84:				print STDERR " $elem->[1]\n";
./.git/hooks/pre-rebase.sample:125:    build on top of it -- other people may already want to
./.git/hooks/pre-rebase.sample:133:		   o---o---o---o---o---o---o---o---o---o "next"
./.git/hooks/pre-rebase.sample:135:		 /   a---a---b A     /           /
./.git/hooks/pre-rebase.sample:137:	       /   /   c---c---c---c B         /
./.git/hooks/pre-rebase.sample:139:	     /   /   /   b---b C     \       /
./.git/hooks/pre-rebase.sample:141:    ---o---o---o---o---o---o---o---o---o---o---o "master"
./.git/hooks/pre-rebase.sample:158:	git rev-list ^master ^topic next
./.git/hooks/pre-rebase.sample:159:	git rev-list ^master        next
./.git/hooks/pre-rebase.sample:165:	git rev-list master..topic
./.git/hooks/prepare-commit-msg.sample:7:# message file.  If the hook fails with a non-zero status,
./.git/hooks/prepare-commit-msg.sample:10:# To enable this hook, rename this file to "prepare-commit-msg".
./.git/hooks/prepare-commit-msg.sample:15:# The second includes the output of "git diff --name-status -r"
./.git/hooks/prepare-commit-msg.sample:17:# commented because it doesn't cope with --amend or with squashed
./.git/hooks/prepare-commit-msg.sample:20:# The third example adds a Signed-off-by line to the message, that can
./.git/hooks/prepare-commit-msg.sample:27:/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
./.git/hooks/prepare-commit-msg.sample:31:#    /usr/bin/perl -i.bak -pe '
./.git/hooks/prepare-commit-msg.sample:32:#       print "\n" . `git diff --cached --name-status -r`
./.git/hooks/prepare-commit-msg.sample:37:# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
./.git/hooks/prepare-commit-msg.sample:38:# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
./.git/hooks/prepare-commit-msg.sample:39:# if test -z "$COMMIT_SOURCE"
./.git/hooks/prepare-commit-msg.sample:41:#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
./.git/hooks/applypatch-msg.sample:4:# applypatch from an e-mail message.
./.git/hooks/applypatch-msg.sample:6:# The hook should exit with non-zero status after issuing an
./.git/hooks/applypatch-msg.sample:10:# To enable this hook, rename this file to "applypatch-msg".
./.git/hooks/applypatch-msg.sample:12:. git-sh-setup
./.git/hooks/applypatch-msg.sample:13:commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
./.git/hooks/applypatch-msg.sample:14:test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
./.git/hooks/update.sample:4:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
./.git/hooks/update.sample:9:# ------
./.git/hooks/update.sample:27:# --- Command line
./.git/hooks/update.sample:32:# --- Safety check
./.git/hooks/update.sample:33:if [ -z "$GIT_DIR" ]; then
./.git/hooks/update.sample:40:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
./.git/hooks/update.sample:45:# --- Config
./.git/hooks/update.sample:46:allowunannotated=$(git config --type=bool hooks.allowunannotated)
./.git/hooks/update.sample:47:allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
./.git/hooks/update.sample:48:denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
./.git/hooks/update.sample:49:allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
./.git/hooks/update.sample:50:allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
./.git/hooks/update.sample:53:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
./.git/hooks/update.sample:61:# --- Check types
./.git/hooks/update.sample:63:zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
./.git/hooks/update.sample:67:	newrev_type=$(git cat-file -t $newrev)
./.git/hooks/update.sample:72:		# un-annotated tag
./.git/hooks/update.sample:75:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
./.git/hooks/update.sample:76:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
./.git/hooks/update.sample:89:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
./.git/hooks/update.sample:98:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
./.git/hooks/update.sample:127:# --- Finished
./.git/hooks/commit-msg.sample:5:# that has the commit message.  The hook should exit with non-zero
./.git/hooks/commit-msg.sample:9:# To enable this hook, rename this file to "commit-msg".
./.git/hooks/commit-msg.sample:11:# Uncomment the below to add a Signed-off-by line to the message.
./.git/hooks/commit-msg.sample:12:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
./.git/hooks/commit-msg.sample:15:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
./.git/hooks/commit-msg.sample:16:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
./.git/hooks/commit-msg.sample:18:# This example catches duplicate Signed-off-by lines.
./.git/hooks/commit-msg.sample:20:test "" = "$(grep '^Signed-off-by: ' "$1" |
./.git/hooks/commit-msg.sample:21:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
./.git/hooks/commit-msg.sample:22:	echo >&2 Duplicate Signed-off-by lines.
./.git/hooks/pre-receive.sample:7:# To enable this hook, rename this file to "pre-receive".
./.git/hooks/pre-receive.sample:9:if test -n "$GIT_PUSH_OPTION_COUNT"
./.git/hooks/pre-receive.sample:12:	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
./.git/hooks/pre-receive.sample:17:			echo "echo from the pre-receive-hook: ${value#*=}" >&2
./.git/hooks/sendemail-validate.sample:6:# The hook should exit with non-zero status after issuing an appropriate
./.git/hooks/sendemail-validate.sample:9:# To enable this hook, rename this file to "sendemail-validate".
./.git/hooks/sendemail-validate.sample:34:	git am -3 "$file" || return
./.git/hooks/sendemail-validate.sample:46:# main -------------------------------------------------------------------------
./.git/hooks/sendemail-validate.sample:50:	remote=$(git config --default origin --get sendemail.validateRemote) &&
./.git/hooks/sendemail-validate.sample:51:	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
./.git/hooks/sendemail-validate.sample:52:	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
./.git/hooks/sendemail-validate.sample:53:	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
./.git/hooks/sendemail-validate.sample:54:	git config --replace-all sendemail.validateWorktree "$worktree"
./.git/hooks/sendemail-validate.sample:56:	worktree=$(git config --get sendemail.validateWorktree)
./.git/hooks/sendemail-validate.sample:58:	echo "sendemail-validate: error: failed to prepare worktree" >&2
./.git/hooks/sendemail-validate.sample:65:if grep -q "^diff --git " "$1"
./.git/hooks/sendemail-validate.sample:74:	git config --unset-all sendemail.validateWorktree &&
./.git/hooks/sendemail-validate.sample:75:	trap 'git worktree remove -ff "$worktree"' EXIT &&
./.git/hooks/pre-merge-commit.sample:5:# exit with non-zero status after issuing an appropriate message to
./.git/hooks/pre-merge-commit.sample:8:# To enable this hook, rename this file to "pre-merge-commit".
./.git/hooks/pre-merge-commit.sample:10:. git-sh-setup
./.git/hooks/pre-merge-commit.sample:11:test -x "$GIT_DIR/hooks/pre-commit" &&
./.git/hooks/pre-merge-commit.sample:12:        exec "$GIT_DIR/hooks/pre-commit"
./.git/hooks/post-update.sample:6:# To enable this hook, rename this file to "post-update".
./.git/hooks/post-update.sample:8:exec git update-server-info
./.git/logs/refs/remotes/origin/HEAD:1:0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 sambit <sambit@sambit.(none)> 1739813636 +0000	clone: from https://github.com/mit-pdos/xv6-public.git
./.git/logs/refs/heads/master:1:0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 sambit <sambit@sambit.(none)> 1739813636 +0000	clone: from https://github.com/mit-pdos/xv6-public.git
./.git/logs/HEAD:1:0000000000000000000000000000000000000000 eeb7b415dbcb12cc362d0783e41c3d1f44066b17 sambit <sambit@sambit.(none)> 1739813636 +0000	clone: from https://github.com/mit-pdos/xv6-public.git
./.git/info/exclude:1:# git ls-files --others --exclude-from=.git/info/exclude
./.git/packed-refs:1:# pack-refs with: peeled fully-peeled sorted 
./.git/packed-refs:3:af0e851a3a8a7d13bc2f2d596b58500594040892 refs/tags/osdi12-submit
./.git/packed-refs:6:05e0b1218dcebe1f40028531b51926df8ae52be0 refs/tags/xv6-2006
./.git/packed-refs:8:42f3c3f7be9717b66ba6e133a113c0f751c53133 refs/tags/xv6-2007
./.git/packed-refs:9:adcd16c3f7588b4a28d37495f05e94278c9e3a1e refs/tags/xv6-2008
./.git/packed-refs:10:124fe7e457c0dc9b671c7ffccb56004eb61da4f0 refs/tags/xv6-2010
./.git/packed-refs:11:5922cdbbcc4fdbd76eec9e0dad9f650e4c86ee99 refs/tags/xv6-rev0
./.git/packed-refs:13:81f31a773dd49b001437eaed3975438585ff9911 refs/tags/xv6-rev1
./.git/packed-refs:15:b818915f793cd20c5d1e24f668534a9d690f3cc8 refs/tags/xv6-rev11
./.git/packed-refs:16:30dab73b68b816877dc8f78504ceca0808c976eb refs/tags/xv6-rev3
./.git/packed-refs:18:113005d48f09a4e3939940d72a77bf6973ea8755 refs/tags/xv6-rev4
./.git/packed-refs:20:d6aa754494b37e32862b1f78d53deedc53f66a15 refs/tags/xv6-rev5
./.git/packed-refs:22:3e9d6413d331b4c912d55bfac253af1629d4bac9 refs/tags/xv6-rev6
./.git/packed-refs:24:ccc25c0fac59067d88af52ad9f3b8cee97c3810a refs/tags/xv6-rev7
./.git/packed-refs:26:7d6f95e327f1c18570d5dd187e3d92e1aadae2cf refs/tags/xv6-rev8
./.git/packed-refs:28:5bf3fbee00fb27cb8cb4eca72dcd9fc4c288ed71 refs/tags/xv6-rev9
./.git/config:7:	url = https://github.com/mit-pdos/xv6-public.git
./test1.c:9:  return fib(n - 1) + fib(n - 2);
./rm.d:1:rm.o: rm.c /usr/i686-linux-gnu/include/stdc-predef.h types.h stat.h \
./stressfs.d:1:stressfs.o: stressfs.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./string.d:1:string.o: string.c /usr/i686-linux-gnu/include/stdc-predef.h types.h \
./uart.c:40:  // Acknowledge pre-existing interrupt conditions;
./uart.c:67:    return -1;
./uart.c:69:    return -1;
